[case testDictGet]
from typing import Dict
def f(d: Dict[int, bool]) -> bool:
    return d[0]
[out]
def f(d):
    d :: dict
    r0 :: short_int
    r1, r2 :: object
    r3 :: bool
L0:
    r0 = 0
    r1 = box(short_int, r0)
    r2 = d[r1] :: dict
    r3 = unbox(bool, r2)
    return r3

[case testDictSet]
from typing import Dict
def f(d: Dict[int, bool]) -> None:
    d[0] = False
[out]
def f(d):
    d :: dict
    r0 :: bool
    r1 :: short_int
    r2, r3 :: object
    r4 :: bool
    r5 :: None
L0:
    r0 = False
    r1 = 0
    r2 = box(short_int, r1)
    r3 = box(bool, r0)
    r4 = d.__setitem__(r2, r3) :: dict
    r5 = None
    return r5

[case testNewEmptyDict]
from typing import Dict
def f() -> None:
    d = {}  # type: Dict[bool, int]
[out]
def f():
    r0, d :: dict
    r1 :: None
L0:
    r0 = {}
    d = r0
    r1 = None
    return r1

[case testNewDictWithValues]
def f(x: object) -> None:
    d = {1: 2, '': x}
[out]
def f(x):
    x :: object
    r0, r1 :: short_int
    r2 :: str
    r3, r4 :: object
    r5, d :: dict
    r6 :: None
L0:
    r0 = 1
    r1 = 2
    r2 = unicode_1 :: static
    r3 = box(short_int, r0)
    r4 = box(short_int, r1)
    r5 = {r3: r4, r2: x}
    d = r5
    r6 = None
    return r6

[case testInDict]
from typing import Dict
def f(d: Dict[int, int]) -> bool:
    if 4 in d:
        return True
    else:
        return False
[out]
def f(d):
    d :: dict
    r0 :: short_int
    r1 :: object
    r2, r3, r4 :: bool
L0:
    r0 = 4
    r1 = box(short_int, r0)
    r2 = r1 in d :: dict
    if r2 goto L1 else goto L2 :: bool
L1:
    r3 = True
    return r3
L2:
    r4 = False
    return r4
L3:
    unreachable

[case testNotInDict]
from typing import Dict
def f(d: Dict[int, int]) -> bool:
    if 4 not in d:
        return True
    else:
        return False
[out]
def f(d):
    d :: dict
    r0 :: short_int
    r1 :: object
    r2, r3, r4, r5 :: bool
L0:
    r0 = 4
    r1 = box(short_int, r0)
    r2 = r1 in d :: dict
    r3 = !r2
    if r3 goto L1 else goto L2 :: bool
L1:
    r4 = True
    return r4
L2:
    r5 = False
    return r5
L3:
    unreachable

[case testDictUpdate]
from typing import Dict
def f(a: Dict[int, int], b: Dict[int, int]) -> None:
    a.update(b)
[out]
def f(a, b):
    a, b :: dict
    r0 :: bool
    r1, r2 :: None
L0:
    r0 = a.update(b) :: dict
    r1 = None
    r2 = None
    return r2

[case testDictKeyLvalue]
from typing import Dict
def increment(d: Dict[str, int]) -> Dict[str, int]:
    for k in d:
        d[k] += 1
    return d
[out]
def increment(d):
    d :: dict
    r0, r1 :: short_int
    r2 :: int
    r3 :: tuple[bool, int, object, object]
    r4 :: bool
    r5 :: int
    r6 :: bool
    r7 :: object
    k, r8 :: str
    r9 :: object
    r10 :: short_int
    r11, r12 :: object
    r13 :: bool
L0:
    r0 = 0
    r1 = r0
    r2 = len d :: dict
L1:
    r3 = next d, offset=r1 :: dict
    r4 = r3[0]
    r5 = r3[1]
    r1 = r5
    if r4 goto L2 else goto L4 :: bool
L2:
    r6 = assert size(d) == r2
    r7 = r3[2]
    r8 = cast(str, r7)
    k = r8
    r9 = d[k] :: dict
    r10 = 1
    r11 = box(short_int, r10)
    r12 = r9 += r11
    r13 = d.__setitem__(k, r12) :: dict
L3:
    goto L1
L4:
    return d

[case testDictDisplay]
from typing import Dict
def f(x: str, y: Dict[str, int]) -> Dict[str, int]:
    return {x: 2, **y, 'z': 3}
[out]
def f(x, y):
    x :: str
    y :: dict
    r0 :: short_int
    r1 :: str
    r2 :: short_int
    r3 :: object
    r4 :: dict
    r5 :: bool
    r6 :: object
    r7 :: bool
L0:
    r0 = 2
    r1 = unicode_3 :: static  ('z')
    r2 = 3
    r3 = box(short_int, r0)
    r4 = {x: r3}
    r5 = r4.update(y) (display) :: dict
    r6 = box(short_int, r2)
    r7 = r4.__setitem__(r1, r6) :: dict
    return r4

[case testDictIterationMethods]
from typing import Dict
def print_dict_methods(d1: Dict[int, int], d2: Dict[int, int]) -> None:
    for v in d1.values():
        if v in d2:
            return
    for k, v in d2.items():
        d2[k] += v
[out]
def print_dict_methods(d1, d2):
    d1, d2 :: dict
    r0, r1 :: short_int
    r2 :: int
    r3 :: tuple[bool, int, object, object]
    r4 :: bool
    r5 :: int
    r6 :: bool
    r7 :: object
    v, r8 :: int
    r9 :: object
    r10 :: bool
    r11 :: None
    r12, r13 :: short_int
    r14 :: int
    r15 :: tuple[bool, int, object, object]
    r16 :: bool
    r17 :: int
    r18 :: bool
    k :: int
    r19, r20 :: object
    r21, r22 :: int
    r23, r24, r25, r26, r27 :: object
    r28 :: bool
    r29 :: None
L0:
    r0 = 0
    r1 = r0
    r2 = len d1 :: dict
L1:
    r3 = next d1, offset=r1 :: dict
    r4 = r3[0]
    r5 = r3[1]
    r1 = r5
    if r4 goto L2 else goto L6 :: bool
L2:
    r6 = assert size(d1) == r2
    r7 = r3[3]
    r8 = unbox(int, r7)
    v = r8
    r9 = box(int, v)
    r10 = r9 in d2 :: dict
    if r10 goto L3 else goto L4 :: bool
L3:
    r11 = None
    return r11
L4:
L5:
    goto L1
L6:
    r12 = 0
    r13 = r12
    r14 = len d2 :: dict
L7:
    r15 = next d2, offset=r13 :: dict
    r16 = r15[0]
    r17 = r15[1]
    r13 = r17
    if r16 goto L8 else goto L10 :: bool
L8:
    r18 = assert size(d2) == r14
    r19 = r15[2]
    r20 = r15[3]
    r21 = unbox(int, r19)
    r22 = unbox(int, r20)
    k = r21
    v = r22
    r23 = box(int, k)
    r24 = d2[r23] :: dict
    r25 = box(int, v)
    r26 = r24 += r25
    r27 = box(int, k)
    r28 = d2.__setitem__(r27, r26) :: dict
L9:
    goto L7
L10:
    r29 = None
    return r29

