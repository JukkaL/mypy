# Misc test cases (compile and run)

[case testAsync]
import asyncio

async def h() -> int:
    return 1

async def g() -> int:
    await asyncio.sleep(0.01)
    return await h()

async def f() -> int:
    return await g()

loop = asyncio.get_event_loop()
result = loop.run_until_complete(f())
assert result == 1

[typing fixtures/typing-full.pyi]

[file driver.py]
from native import f
import asyncio
loop = asyncio.get_event_loop()
result = loop.run_until_complete(f())
assert result == 1

[case testTrue]
def f() -> bool:
    return True
[file driver.py]
from native import f
print(f())
[out]
True

[case testBoolIf]
def f(x: bool) -> bool:
    if x:
        return False
    else:
        return True
[file driver.py]
from native import f
print(f(True))
print(f(False))
[out]
False
True

[case testMaybeUninitVar]
class C:
    def __init__(self, x: int) -> None:
        self.x = x

def f(b: bool) -> None:
    u = C(1)
    while b:
        v = C(2)
        if v is not u:
            break
    print(v.x)
[file driver.py]
from native import f
f(True)
[out]
2

[case testUninitBoom]
def f(a: bool, b: bool) -> None:
    if a:
        x = 'lol'
    if b:
        print(x)

def g() -> None:
    try:
        [0][1]
        y = 1
    except Exception:
        pass
    print(y)

[file driver.py]
from native import f, g
from testutil import assertRaises

f(True, True)
f(False, False)
with assertRaises(NameError):
    f(False, True)
with assertRaises(NameError):
    g()
[out]
lol

[case testImports]
import testmodule

def f(x: int) -> int:
    return testmodule.factorial(5)
def g(x: int) -> int:
    from welp import foo
    return foo(x)
[file testmodule.py]
def factorial(x: int) -> int:
    if x == 0:
        return 1
    else:
        return x * factorial(x-1)
[file welp.py]
def foo(x: int) -> int:
    return x
[file driver.py]
from native import f, g
print(f(5))
print(g(5))
[out]
120
5

[case testBuiltins]
y = 10
def f(x: int) -> None:
    print(5)
    d = globals()
    assert d['y'] == 10
    d['y'] = 20
    assert y == 20
[file driver.py]
from native import f
f(5)
[out]
5

[case testImportMissing]
# The unchecked module is configured by the test harness to not be
# picked up by mypy, so we can test that we do that right thing when
# calling library modules without stubs.
import unchecked  # type: ignore
import unchecked as lol  # type: ignore
assert unchecked.x == 10
assert lol.x == 10
[file unchecked.py]
x = 10

[file driver.py]
import native

[case testOptional]
from typing import Optional

class A: pass

def f(x: Optional[A]) -> Optional[A]:
    return x

def g(x: Optional[A]) -> int:
    if x is None:
        return 1
    if x is not None:
        return 2
    return 3

def h(x: Optional[int], y: Optional[bool]) -> None:
    pass

[file driver.py]
from native import f, g, A
a = A()
assert f(None) is None
assert f(a) is a
assert g(None) == 1
assert g(a) == 2

[case testFromImport]
from testmodule import g

def f(x: int) -> int:
    return g(x)
[file testmodule.py]
def g(x: int) -> int:
    return x + 1
[file driver.py]
from native import f
assert f(1) == 2

[case testSets]
from typing import Set, List
def instantiateLiteral() -> Set[int]:
    return {1, 2, 3, 5, 8}

def fromIterator() -> List[Set[int]]:
    x = set([1, 3, 5])
    y = set((1, 3, 5))
    z = set({1: '1', 3: '3', 5: '5'})
    return [x, y, z]

def addIncrementing(s : Set[int]) -> None:
    for a in [1, 2, 3]:
        if a not in s:
            s.add(a)
            return

def replaceWith1(s : Set[int]) -> None:
    s.clear()
    s.add(1)

def remove1(s : Set[int]) -> None:
    s.remove(1)

def discard1(s: Set[int]) -> None:
    s.discard(1)

def pop(s : Set[int]) -> int:
    return s.pop()

def update(s: Set[int], x: List[int]) -> None:
    s.update(x)

[file driver.py]
from native import instantiateLiteral
from testutil import assertRaises

val = instantiateLiteral()
assert 1 in val
assert 2 in val
assert 3 in val
assert 5 in val
assert 8 in val
assert len(val) == 5
assert val == {1, 2, 3, 5, 8}
s = 0
for i in val:
    s += i
assert s == 19

from native import fromIterator
sets = fromIterator()
for s in sets:
    assert s == {1, 3, 5}

from native import addIncrementing
s = set()
addIncrementing(s)
assert s == {1}
addIncrementing(s)
assert s == {1, 2}
addIncrementing(s)
assert s == {1, 2, 3}

from native import replaceWith1
s = {3, 7, 12}
replaceWith1(s)
assert s == {1}

from native import remove1
import traceback
s = {1, 4, 6}
remove1(s)
assert s == {4, 6}
with assertRaises(KeyError, '1'):
    remove1(s)

from native import discard1
s = {1, 4, 6}
discard1(s)
assert s == {4, 6}
discard1(s)
assert s == {4, 6}

from native import pop
s = {1, 2, 3}
x = pop(s)
assert len(s) == 2
assert x in [1, 2, 3]
y = pop(s)
assert len(s) == 1
assert y in [1, 2, 3]
assert x != y
z = pop(s)
assert len(s) == 0
assert z in [1, 2, 3]
assert x != z
assert y != z
with assertRaises(KeyError, 'pop from an empty set'):
    pop(s)

from native import update
s = {1, 2, 3}
update(s, [5, 4, 3])
assert s == {1, 2, 3, 4, 5}

[case testWith]
from typing import Any
class Thing:
    def __init__(self, x: str) -> None:
        self.x = x
    def __enter__(self) -> str:
        print('enter!', self.x)
        if self.x == 'crash':
            raise Exception('ohno')
        return self.x
    def __exit__(self, x: Any, y: Any, z: Any) -> None:
        print('exit!', self.x, y)

def foo(i: int) -> int:
    with Thing('a') as x:
        print("yooo?", x)
        if i == 0:
            return 10
        elif i == 1:
            raise Exception('exception!')
    return -1

def bar() -> None:
    with Thing('a') as x, Thing('b') as y:
        print("yooo?", x, y)

def baz() -> None:
    with Thing('a') as x, Thing('crash') as y:
        print("yooo?", x, y)

[file driver.py]
from native import foo, bar, baz
assert foo(0) == 10
print('== foo ==')
try:
    foo(1)
except Exception:
    print('caught')
assert foo(2) == -1

print('== bar ==')
bar()

print('== baz ==')
try:
    baz()
except Exception:
    print('caught')

[out]
enter! a
yooo? a
exit! a None
== foo ==
enter! a
yooo? a
exit! a exception!
caught
enter! a
yooo? a
exit! a None
== bar ==
enter! a
enter! b
yooo? a b
exit! b None
exit! a None
== baz ==
enter! a
enter! crash
exit! a ohno
caught

[case testGenericEquality]
def eq(a: object, b: object) -> bool:
    if a == b:
        return True
    else:
        return False
def ne(a: object, b: object) -> bool:
    if a != b:
        return True
    else:
        return False
def f(o: object) -> bool:
    if [1, 2] == o:
        return True
    else:
        return False
[file driver.py]
from native import eq, ne, f
assert eq('xz', 'x' + 'z')
assert not eq('x', 'y')
assert not ne('xz', 'x' + 'z')
assert ne('x', 'y')
assert f([1, 2])
assert not f([2, 2])
assert not f(1)

[case testGenericBinaryOps]
from typing import Any
def add(x: Any, y: Any) -> Any:
    return x + y
def subtract(x: Any, y: Any) -> Any:
    return x - y
def multiply(x: Any, y: Any) -> Any:
    return x * y
def floor_div(x: Any, y: Any) -> Any:
    return x // y
def true_div(x: Any, y: Any) -> Any:
    return x / y
def remainder(x: Any, y: Any) -> Any:
    return x % y
def power(x: Any, y: Any) -> Any:
    return x ** y
def lshift(x: Any, y: Any) -> Any:
    return x << y
def rshift(x: Any, y: Any) -> Any:
    return x >> y
def num_and(x: Any, y: Any) -> Any:
    return x & y
def num_xor(x: Any, y: Any) -> Any:
    return x ^ y
def num_or(x: Any, y: Any) -> Any:
    return x | y
def lt(x: Any, y: Any) -> Any:
    if x < y:
        return True
    else:
        return False
def le(x: Any, y: Any) -> Any:
    if x <= y:
        return True
    else:
        return False
def gt(x: Any, y: Any) -> Any:
    if x > y:
        return True
    else:
        return False
def ge(x: Any, y: Any) -> Any:
    if x >= y:
        return True
    else:
        return False
def contains(x: Any, y: Any) -> Any:
    if x in y:
        return True
    else:
        return False
def identity(x: Any, y: Any) -> Any:
    if x is y:
        return True
    else:
        return False
def disidentity(x: Any, y: Any) -> Any:
    if x is not y:
        return True
    else:
        return False
def not_eq_cond(a: Any, b: Any) -> bool:
    if not (a == b):
        return True
    else:
        return False
def eq2(a: Any, b: Any) -> bool:
    return a == b
def slice1(x: Any) -> Any:
    return x[:]
def slice2(x: Any, y: Any) -> Any:
    return x[y:]
def slice3(x: Any, y: Any) -> Any:
    return x[:y]
def slice4(x: Any, y: Any, z: Any) -> Any:
    return x[y:z]
def slice5(x: Any, y: Any, z: Any, zz: Any) -> Any:
    return x[y:z:zz]
[file driver.py]
from native import *
assert add(5, 6) == 11
assert add('x', 'y') == 'xy'
assert subtract(8, 3) == 5
assert multiply(8, 3) == 24
assert floor_div(8, 3) == 2
assert true_div(7, 2) == 3.5
assert remainder(11, 4) == 3
assert remainder('%.3d', 5) == '005'
assert remainder('%d-%s', (5, 'xy')) == '5-xy'
assert power(3, 4) == 81
assert lshift(5, 3) == 40
assert rshift(41, 3) == 5
assert num_and(99, 56) == 32
assert num_xor(99, 56) == 91
assert num_or(99, 56) == 123
assert lt('a', 'b')
assert not lt('a', 'a')
assert not lt('b', 'a')
assert not gt('a', 'b')
assert not gt('a', 'a')
assert gt('b', 'a')
assert le('a', 'b')
assert le('a', 'a')
assert not le('b', 'a')
assert not ge('a', 'b')
assert ge('a', 'a')
assert ge('b', 'a')
assert contains('x', 'axb')
assert not contains('X', 'axb')
assert contains('x', {'x', 'y'})
a = [1, 3, 5]
assert slice1(a) == a
assert slice1(a) is not a
assert slice2(a, 1) == [3, 5]
assert slice3(a, -1) == [1, 3]
assert slice4(a, 1, -1) == [3]
assert slice5(a, 2, 0, -1) == [5, 3]
o1, o2 = object(), object()
assert identity(o1, o1)
assert not identity(o1, o2)
assert not disidentity(o1, o1)
assert disidentity(o1, o2)
assert eq2('xz', 'x' + 'z')
assert not eq2('x', 'y')
assert not not_eq_cond('xz', 'x' + 'z')
assert not_eq_cond('x', 'y')

[case testGenericMiscOps]
from typing import Any
def neg(x: Any) -> Any:
    return -x
def pos(x: Any) -> Any:
    return +x
def invert(x: Any) -> Any:
    return ~x
def get_item(o: Any, k: Any) -> Any:
    return o[k]
def set_item(o: Any, k: Any, v: Any) -> Any:
    o[k] = v
[file driver.py]
from native import *
assert neg(6) == -6
assert pos(6) == 6
assert invert(6) == -7
d = {'x': 5}
assert get_item(d, 'x') == 5
set_item(d, 'y', 6)
assert d['y'] == 6

[case testSubclassAttributeAccess]
from mypy_extensions import trait

class A:
    v = 0

class B(A):
    v = 1

class C(B):
    v = 2

[file driver.py]
from native import A, B, C

a = A()
b = B()
c = C()

[case testAnyAttributeAndMethodAccess]
from typing import Any, List
class C:
    a: int
    def m(self, x: int, a: List[int]) -> int:
        return self.a + x + a[0]
def get_a(x: Any) -> Any:
    return x.a
def set_a(x: Any, y: Any) -> None:
    x.a = y
def call_m(x: Any) -> Any:
    return x.m(1, [3])
[file driver.py]
from native import C, get_a, set_a, call_m
class D:
    def m(self, x, a):
        return self.a + x + a[0]

c = C()
c.a = 6
d = D()
d.a = 2
assert get_a(c) == 6
assert get_a(d) == 2
assert call_m(c) == 10
assert call_m(d) == 6
set_a(c, 5)
assert c.a == 5
set_a(d, 4)
assert d.a == 4
try:
    get_a(object())
except AttributeError:
    pass
else:
    assert False
try:
    call_m(object())
except AttributeError:
    pass
else:
    assert False
try:
    set_a(object(), 5)
except AttributeError:
    pass
else:
    assert False

[case testFloat]
def assign_and_return_float_sum() -> float:
    f1 = 1.0
    f2 = 2.0
    f3 = 3.0
    return f1 * f2 + f3

def from_int(i: int) -> float:
    return float(i)

def to_int(x: float) -> int:
    return int(x)

def get_complex() -> complex:
    return 5.0j + 3.0

[file driver.py]
from native import assign_and_return_float_sum, from_int, to_int, get_complex
sum = 0.0
for i in range(10):
    sum += assign_and_return_float_sum()
assert sum == 50.0

assert str(from_int(10)) == '10.0'
assert str(to_int(3.14)) == '3'
assert str(to_int(3)) == '3'
assert get_complex() == 3+5j

[case testBytes]
def f(x: bytes) -> bytes:
    return x

def concat(a: bytes, b: bytes) -> bytes:
    return a + b

def eq(a: bytes, b: bytes) -> bool:
    return a == b

def neq(a: bytes, b: bytes) -> bool:
    return a != b

def join() -> bytes:
    seq = (b'1', b'"', b'\xf0')
    return b'\x07'.join(seq)
[file driver.py]
from native import f, concat, eq, neq, join
assert f(b'123') == b'123'
assert f(b'\x07 \x0b " \t \x7f \xf0') == b'\x07 \x0b " \t \x7f \xf0'
assert concat(b'123', b'456') == b'123456'
assert eq(b'123', b'123')
assert not eq(b'123', b'1234')
assert neq(b'123', b'1234')
assert join() == b'1\x07"\x07\xf0'

[case testDisplays]
from typing import List, Set, Tuple, Sequence, Dict, Any

def listDisplay(x: List[int], y: List[int]) -> List[int]:
    return [1, 2, *x, *y, 3]

def setDisplay(x: Set[int], y: Set[int]) -> Set[int]:
    return {1, 2, *x, *y, 3}

def tupleDisplay(x: Sequence[str], y: Sequence[str]) -> Tuple[str, ...]:
    return ('1', '2', *x, *y, '3')

def dictDisplay(x: str, y1: Dict[str, int], y2: Dict[str, int]) -> Dict[str, int]:
    return {x: 2, **y1, 'z': 3, **y2}

[file driver.py]
from native import listDisplay, setDisplay, tupleDisplay, dictDisplay
assert listDisplay([4], [5, 6]) == [1, 2, 4, 5, 6, 3]
assert setDisplay({4}, {5}) == {1, 2, 3, 4, 5}
assert tupleDisplay(['4', '5'], ['6']) == ('1', '2', '4', '5', '6', '3')
assert dictDisplay('x', {'y1': 1}, {'y2': 2, 'z': 5}) == {'x': 2, 'y1': 1, 'y2': 2, 'z': 5}

[case testArbitraryLvalues]
from typing import List, Dict, Any

class O(object):
    def __init__(self) -> None:
        self.x = 1

def increment_attr(a: Any) -> Any:
    a.x += 1
    return a

def increment_attr_o(o: O) -> O:
    o.x += 1
    return o

def increment_all_indices(l: List[int]) -> List[int]:
    for i in range(len(l)):
        l[i] += 1
    return l

def increment_all_keys(d: Dict[str, int]) -> Dict[str, int]:
    for k in d:
        d[k] += 1
    return d

[file driver.py]
from native import O, increment_attr, increment_attr_o, increment_all_indices, increment_all_keys

class P(object):
    def __init__(self) -> None:
        self.x = 0

assert increment_attr(P()).x == 1
assert increment_attr_o(O()).x == 2
assert increment_all_indices([1, 2, 3]) == [2, 3, 4]
assert increment_all_keys({'a':1, 'b':2, 'c':3}) == {'a':2, 'b':3, 'c':4}

[case testControlFlowExprs]
from typing import Tuple
def foo() -> object:
    print('foo')
    return 'foo'
def bar() -> object:
    print('bar')
    return 'bar'
def t(x: int) -> int:
    print(x)
    return x

def f(b: bool) -> Tuple[object, object, object]:
    x = foo() if b else bar()
    y = b or foo()
    z = b and foo()
    return (x, y, z)
def g() -> Tuple[object, object]:
    return (foo() or bar(), foo() and bar())

def nand(p: bool, q: bool) -> bool:
    if not (p and q):
        return True
    return False

def chained(x: int, y: int, z: int) -> bool:
    return t(x) < t(y) > t(z)

def chained2(x: int, y: int, z: int, w: int) -> bool:
    return t(x) < t(y) < t(z) < t(w)
[file driver.py]
from native import f, g, nand, chained, chained2
assert f(True) == ('foo', True, 'foo')
print()
assert f(False) == ('bar', 'foo', False)
print()
assert g() == ('foo', 'bar')

assert nand(True, True) == False
assert nand(True, False) == True
assert nand(False, True) == True
assert nand(False, False) == True

print()
assert chained(10, 20, 15) == True
print()
assert chained(10, 20, 30) == False
print()
assert chained(21, 20, 30) == False
print()
assert chained2(1, 2, 3, 4) == True
print()
assert chained2(1, 0, 3, 4) == False
print()
assert chained2(1, 2, 0, 4) == False
[out]
foo
foo

bar
foo

foo
foo
bar

10
20
15

10
20
30

21
20

1
2
3
4

1
0

1
2
0

[case testMultipleAssignment]
from typing import Tuple, List, Any

def from_tuple(t: Tuple[int, str]) -> List[Any]:
    x, y = t
    return [y, x]

def from_list(l: List[int]) -> List[int]:
    x, y = l
    return [y, x]

def from_any(o: Any) -> List[Any]:
    x, y = o
    return [y, x]
[file driver.py]
from native import from_tuple, from_list, from_any

assert from_tuple((1, 'x')) == ['x', 1]
assert from_list([3, 4]) == [4, 3]
assert from_any('xy') == ['y', 'x']

[case testUnpack]
from typing import List

a, *b = [1, 2, 3, 4, 5]

*c, d = [1, 2, 3, 4, 5]

e, *f = [1,2]

j, *k, l = [1, 2, 3]

m, *n, o = [1, 2, 3, 4, 5, 6]

p, q, r, *s, t = [1,2,3,4,5,6,7,8,9,10]

tup = (1,2,3)
y, *z = tup

def unpack1(l : List[int]) -> None:
    *v1, v2, v3 = l

def unpack2(l : List[int]) -> None:
    v1, *v2, v3 = l

def unpack3(l : List[int]) -> None:
    v1, v2, *v3 = l

[file driver.py]
from native import a, b, c, d, e, f, j, k, l, m, n, o, p, q, r, s, t, y, z
from native import unpack1, unpack2, unpack3
from testutil import assertRaises

assert a == 1
assert b == [2,3,4,5]
assert c == [1,2,3,4]
assert d == 5
assert e == 1
assert f == [2]
assert j == 1
assert k == [2]
assert l == 3
assert m == 1
assert n == [2,3,4,5]
assert o == 6
assert p == 1
assert q == 2
assert r == 3
assert s == [4,5,6,7,8,9]
assert t == 10
assert y == 1
assert z == [2,3]

with assertRaises(ValueError, "not enough values to unpack"):
    unpack1([1])

with assertRaises(ValueError, "not enough values to unpack"):
    unpack2([1])

with assertRaises(ValueError, "not enough values to unpack"):
    unpack3([1])

[out]

[case testModuleTopLevel]
x = 1
print(x)

def f() -> None:
    print(x + 1)

def g() -> None:
    global x
    x = 77

[file driver.py]
import native
native.f()
native.x = 5
native.f()
native.g()
print(native.x)

[out]
1
2
6
77

[case testComprehensions]
# A list comprehension
l = [str(x) + "     " + str(y) + "   " + str(x*y) for x in range(10)
     if x != 6 if x != 5 for y in range(x) if y*x != 8]

# Test short-circuiting as well
def pred(x: int) -> bool:
    if x > 6:
        raise Exception()
    return x > 3
# If we fail to short-circuit, pred(x) will be called with x=7
# eventually and will raise an exception.
l2 = [x for x in range(10) if x <= 6 if pred(x)]

# A dictionary comprehension
d = {k: k*k for k in range(10) if k != 5 if k != 6}

# A set comprehension
s = {str(x) + "     " + str(y) + "   " + str(x*y) for x in range(10)
     if x != 6 if x != 5 for y in range(x) if y*x != 8}

[file driver.py]
from native import l, l2, d, s
for a in l:
    print(a)
print(tuple(l2))
for k in sorted(d):
    print(k, d[k])
for a in sorted(s):
    print(a)
[out]
1     0   0
2     0   0
2     1   2
3     0   0
3     1   3
3     2   6
4     0   0
4     1   4
4     3   12
7     0   0
7     1   7
7     2   14
7     3   21
7     4   28
7     5   35
7     6   42
8     0   0
8     2   16
8     3   24
8     4   32
8     5   40
8     6   48
8     7   56
9     0   0
9     1   9
9     2   18
9     3   27
9     4   36
9     5   45
9     6   54
9     7   63
9     8   72
(4, 5, 6)
0 0
1 1
2 4
3 9
4 16
7 49
8 64
9 81
1     0   0
2     0   0
2     1   2
3     0   0
3     1   3
3     2   6
4     0   0
4     1   4
4     3   12
7     0   0
7     1   7
7     2   14
7     3   21
7     4   28
7     5   35
7     6   42
8     0   0
8     2   16
8     3   24
8     4   32
8     5   40
8     6   48
8     7   56
9     0   0
9     1   9
9     2   18
9     3   27
9     4   36
9     5   45
9     6   54
9     7   63
9     8   72

[case testDel]
from typing import List
from testutil import assertRaises

def printDict(dict) -> None:
    l = list(dict.keys()) # type: List[str]
    l.sort()
    for key in l:
        print(key, dict[key])
    print("#########")

def delList() -> None:
    l = [1, 2, 3]
    print(tuple(l))
    del l[1]
    print(tuple(l))

def delDict() -> None:
    d = {"one":1, "two":2}
    printDict(d)
    del d["one"]
    printDict(d)

def delListMultiple() -> None:
    l = [1, 2, 3, 4, 5, 6, 7]
    print(tuple(l))
    del l[1], l[2], l[3]
    print(tuple(l))

def delDictMultiple() -> None:
    d = {"one":1, "two":2, "three":3, "four":4}
    printDict(d)
    del d["two"], d["four"]
    printDict(d)

class Dummy():
    def __init__(self, x: int, y: int) -> None:
        self.x = x
        self.y = y

def delAttribute() -> None:
    dummy = Dummy(1, 2)
    del dummy.x
    with assertRaises(AttributeError):
        dummy.x

def delAttributeMultiple() -> None:
    dummy = Dummy(1, 2)
    del dummy.x, dummy.y
    with assertRaises(AttributeError):
        dummy.x
    with assertRaises(AttributeError):
        dummy.y

def delLocal(b: bool) -> int:
    dummy = 10
    if b:
        del dummy
    return dummy

def delLocalLoop() -> None:
    # Try deleting a local in a loop to make sure the control flow analysis works
    dummy = 1
    for i in range(10):
        print(dummy)
        dummy *= 2
        if i == 4:
            del dummy

global_var = 10
del global_var

[file driver.py]
from native import (
    delList, delDict, delListMultiple, delDictMultiple, delAttribute,
    delAttributeMultiple, delLocal, delLocalLoop,
)
import native
from testutil import assertRaises

delList()
delDict()
delListMultiple()
delDictMultiple()
delAttribute()
delAttributeMultiple()
with assertRaises(AttributeError):
    native.global_var
with assertRaises(NameError, "local variable 'dummy' referenced before assignment"):
    delLocal(True)
assert delLocal(False) == 10
with assertRaises(NameError, "local variable 'dummy' referenced before assignment"):
    delLocalLoop()
[out]
(1, 2, 3)
(1, 3)
one 1
two 2
#########
two 2
#########
(1, 2, 3, 4, 5, 6, 7)
(1, 3, 5, 7)
four 4
one 1
three 3
two 2
#########
one 1
three 3
#########
1
2
4
8
16

[case testProperty]
from typing import Callable
from mypy_extensions import trait
class Temperature:
    @property
    def celsius(self) -> float:
        return 5.0 * (self.farenheit - 32.0) / 9.0

    def __init__(self, farenheit: float) -> None:
        self.farenheit = farenheit

    def print_temp(self) -> None:
        print("F:", self.farenheit, "C:", self.celsius)

    @property
    def rankine(self) -> float:
        raise NotImplementedError

class Access:
    @property
    def number_of_accesses(self) -> int:
        self._count += 1
        return self._count
    def __init__(self) -> None:
        self._count = 0

from typing import Callable
class BaseProperty:
    @property
    def doc(self) -> str:
        return "Represents a sequence of values. Updates itself by next, which is a new value."

    @property
    def value(self) -> object:
        return self._incrementer

    @property
    def bad_value(self) -> object:
        return self._incrementer

    @property
    def next(self) -> BaseProperty:
        return BaseProperty(self._incrementer + 1)

    def __init__(self, value: int) -> None:
        self._incrementer = value

class DerivedProperty(BaseProperty):
    @property
    def value(self) -> int:
        return self._incrementer

    @property
    def bad_value(self) -> object:
        return self._incrementer

    def __init__(self, incr_func: Callable[[int], int], value: int) -> None:
        BaseProperty.__init__(self, value)
        self._incr_func = incr_func

    @property
    def next(self) -> DerivedProperty:
        return DerivedProperty(self._incr_func, self._incr_func(self.value))

class AgainProperty(DerivedProperty):
    @property
    def next(self) -> AgainProperty:
        return AgainProperty(self._incr_func, self._incr_func(self._incr_func(self.value)))

    @property
    def bad_value(self) -> int:
        return self._incrementer

def print_first_n(n: int, thing: BaseProperty) -> None:
    vals = []
    cur_thing = thing
    for _ in range(n):
        vals.append(cur_thing.value)
        cur_thing = cur_thing.next
    print ('', vals)

@trait
class Trait:
    @property
    def value(self) -> int:
        return 3

class Printer(Trait):
    def print_value(self) -> None:
        print(self.value)

[file driver.py]
from native import Temperature, Access
import traceback
x = Temperature(32.0)
try:
    print (x.rankine)
except NotImplementedError as e:
    traceback.print_exc()
print (x.celsius)
x.print_temp()

y = Temperature(212.0)
print (y.celsius)
y.print_temp()

z = Access()
print (z.number_of_accesses)
print (z.number_of_accesses)
print (z.number_of_accesses)
print (z.number_of_accesses)

from native import BaseProperty, DerivedProperty, AgainProperty, print_first_n
a = BaseProperty(7)
b = DerivedProperty((lambda x: x // 2 if (x % 2 == 0) else 3 * x + 1), 7)
c = AgainProperty((lambda x: x // 2 if (x % 2 == 0) else 3 * x + 1), 7)

def py_print_first_n(n: int, thing: BaseProperty) -> None:
    vals = []
    cur_thing = thing
    for _ in range(n):
        vals.append(cur_thing.value)
        cur_thing = cur_thing.next
    print ('', vals)

py_print_first_n(20, a)
py_print_first_n(20, b)
py_print_first_n(20, c)

print(a.next.next.next.bad_value)
print(b.next.next.next.bad_value)
print(c.next.next.next.bad_value)

print_first_n(20, a)
print_first_n(20, b)
print_first_n(20, c)

print (a.doc)
print (b.doc)
print (c.doc)

from native import Printer
Printer().print_value()
print (Printer().value)
[out]
Traceback (most recent call last):
  File "driver.py", line 5, in <module>
    print (x.rankine)
  File "native.py", line 16, in rankine
    raise NotImplementedError
NotImplementedError
0.0
F: 32.0 C: 0.0
100.0
F: 212.0 C: 100.0
1
2
3
4
 [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26]
 [7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1, 4, 2, 1]
 [7, 11, 17, 26, 40, 10, 16, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4]
10
34
26
 [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26]
 [7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1, 4, 2, 1]
 [7, 11, 17, 26, 40, 10, 16, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4]
Represents a sequence of values. Updates itself by next, which is a new value.
Represents a sequence of values. Updates itself by next, which is a new value.
Represents a sequence of values. Updates itself by next, which is a new value.
3
3

[case testPropertySetters]

from mypy_extensions import trait

class Foo():
    def __init__(self) -> None:
        self.attr = "unmodified"

class A:
    def __init__(self) -> None:
        self._x = 0
        self._foo = Foo()

    @property
    def x(self) -> int:
        return self._x

    @x.setter
    def x(self, val : int) -> None:
        self._x = val

    @property
    def foo(self) -> Foo:
        return self._foo

    @foo.setter
    def foo(self, val : Foo) -> None:
        self._foo = val

# Overrides base property setters and getters
class B(A):
    def __init__(self) -> None:
        self._x = 10

    @property
    def x(self) -> int:
        return self._x + 1

    @x.setter
    def x(self, val : int) -> None:
        self._x = val + 1

#Inerits base property setters and getters
class C(A):
    def __init__(self) -> None:
        A.__init__(self)

@trait
class D():
    def __init__(self) -> None:
        self._x = 0

    @property
    def x(self) -> int:
        return self._x

    @x.setter
    def x(self, val : int) -> None:
        self._x = val

#Inherits trait property setters and getters
class E(D):
    def __init__(self) -> None:
        D.__init__(self)

#Overrides trait property setters and getters
class F(D):
    def __init__(self) -> None:
        self._x = 10

    @property
    def x(self) -> int:
        return self._x + 10

    @x.setter
    def x(self, val : int) -> None:
        self._x = val + 10

# # Property setter and getter are subtypes of base property setters and getters
# # class G(A):
# #   def __init__(self) -> None:
# #       A.__init__(self)

# #   @property
# #   def y(self) -> int:
# #       return self._y

# #   @y.setter
# #   def y(self, val : object) -> None:
# #       self._y = val

[file other.py]
# Run in both interpreted and compiled mode

from native import A, B, C, D, E, F

a = A()
assert a.x == 0
assert a._x == 0
a.x = 1
assert a.x == 1
assert a._x == 1
a._x = 0
assert a.x == 0
assert a._x == 0
b = B()
assert b.x == 11
assert b._x == 10
b.x = 11
assert b.x == 13
b._x = 11
assert b.x == 12
c = C()
assert c.x == 0
c.x = 1000
assert c.x == 1000
e = E()
assert e.x == 0
e.x = 1000
assert e.x == 1000
f = F()
assert f.x == 20
f.x = 30
assert f.x == 50

[file driver.py]
# Run the tests in both interpreted and compiled mode
import other
import other_interpreted

[out]

[case testDunders]
from typing import Any
class Item:
    def __init__(self, value: str) -> None:
        self.value = value

    def __hash__(self) -> int:
        return hash(self.value)

    def __eq__(self, rhs: object) -> bool:
        return isinstance(rhs, Item) and self.value == rhs.value

    def __lt__(self, x: 'Item') -> bool:
        return self.value < x.value

class Subclass1(Item):
    def __bool__(self) -> bool:
        return bool(self.value)

class NonBoxedThing:
    def __getitem__(self, index: Item) -> Item:
        return Item("2 * " + index.value + " + 1")

class BoxedThing:
    def __getitem__(self, index: int) -> int:
        return 2 * index + 1

class Subclass2(BoxedThing):
    pass

class UsesNotImplemented:
    def __eq__(self, b: object) -> bool:
        return NotImplemented

def index_into(x : Any, y : Any) -> Any:
    return x[y]

def internal_index_into() -> None:
    x = BoxedThing()
    print (x[3])
    y = NonBoxedThing()
    z = Item("3")
    print(y[z].value)

def is_truthy(x: Item) -> bool:
    return True if x else False

[file driver.py]
from native import *
x = BoxedThing()
y = 3
print(x[y], index_into(x, y))

x = Subclass2()
y = 3
print(x[y], index_into(x, y))

z = NonBoxedThing()
w = Item("3")
print(z[w].value, index_into(z, w).value)

i1 = Item('lolol')
i2 = Item('lol' + 'ol')
i3 = Item('xyzzy')
assert hash(i1) == hash(i2)

assert i1 == i2
assert not i1 != i2
assert not i1 == i3
assert i1 != i3
assert i2 < i3
assert not i1 < i2
assert i1 == Subclass1('lolol')

assert is_truthy(Item(''))
assert is_truthy(Item('a'))
assert not is_truthy(Subclass1(''))
assert is_truthy(Subclass1('a'))

assert UsesNotImplemented() != object()

internal_index_into()
[out]
7 7
7 7
2 * 3 + 1 2 * 3 + 1
7
2 * 3 + 1

[case testDummyTypes]
from typing import Tuple, List, Dict, NamedTuple
from typing_extensions import Literal, TypedDict, NewType

class A:
    pass

T = List[A]
U = List[Tuple[int, str]]
Z = List[List[int]]
D = Dict[int, List[int]]
N = NewType('N', int)
G = Tuple[int, str]
def foo(x: N) -> int:
    return x
foo(N(10))
z = N(10)
Lol = NamedTuple('Lol', (('a', int), ('b', T)))
x = Lol(1, [])
def take_lol(x: Lol) -> int:
    return x.a

TD = TypedDict('TD', {'a': int})
def take_typed_dict(x: TD) -> int:
    return x['a']

def take_literal(x: Literal[1, 2, 3]) -> None:
    print(x)

[file driver.py]
import sys
from native import *

if sys.version_info[:3] > (3, 5, 2):
    assert "%s %s %s %s" % (T, U, Z, D) == "typing.List[native.A] typing.List[typing.Tuple[int, str]] typing.List[typing.List[int]] typing.Dict[int, typing.List[int]]"
print(x)
print(z)
print(take_lol(x))
print(take_typed_dict({'a': 20}))
try:
    take_typed_dict(None)
except Exception as e:
    print(type(e).__name__)


take_literal(1)
# We check that the type is the real underlying type
try:
    take_literal(None)
except Exception as e:
    print(type(e).__name__)
# ... but not that it is a valid literal value
take_literal(10)
[out]
Lol(a=1, b=[])
10
1
20
TypeError
1
TypeError
10

[case testUnion]
from typing import Union

class A:
    def __init__(self, x: int) -> None:
        self.x = x
    def f(self, y: int) -> int:
        return y + self.x

class B:
    def __init__(self, x: object) -> None:
        self.x = x
    def f(self, y: object) -> object:
        return y

def f(x: Union[A, str]) -> object:
    if isinstance(x, A):
        return x.x
    else:
        return x + 'x'

def g(x: int) -> Union[A, int]:
    if x == 0:
        return A(1)
    else:
        return x + 1

def get(x: Union[A, B]) -> object:
    return x.x

def call(x: Union[A, B]) -> object:
    return x.f(5)

[file driver.py]
from native import A, B, f, g, get, call
assert f('a') == 'ax'
assert f(A(4)) == 4
assert isinstance(g(0), A)
assert g(2) == 3
assert get(A(5)) == 5
assert get(B('x')) == 'x'
assert call(A(4)) == 9
assert call(B('x')) == 5
try:
    f(1)
except TypeError:
    pass
else:
    assert False

[case testAnyAll]
from typing import Iterable

def call_any_nested(l: Iterable[Iterable[int]], val: int = 0) -> int:
    res = any(i == val for l2 in l for i in l2)
    return 0 if res else 1

def call_any(l: Iterable[int], val: int = 0) -> int:
    res = any(i == val for i in l)
    return 0 if res else 1

def call_all(l: Iterable[int], val: int = 0) -> int:
    res = all(i == val for i in l)
    return 0 if res else 1

[file driver.py]
from native import call_any, call_all, call_any_nested

zeros = [0, 0, 0]
ones = [1, 1, 1]
mixed_001 = [0, 0, 1]
mixed_010 = [0, 1, 0]
mixed_100 = [1, 0, 0]
mixed_011 = [0, 1, 1]
mixed_101 = [1, 0, 1]
mixed_110 = [1, 1, 0]

assert call_any([]) == 1
assert call_any(zeros) == 0
assert call_any(ones) == 1
assert call_any(mixed_001) == 0
assert call_any(mixed_010) == 0
assert call_any(mixed_100) == 0
assert call_any(mixed_011) == 0
assert call_any(mixed_101) == 0
assert call_any(mixed_110) == 0

assert call_all([]) == 0
assert call_all(zeros) == 0
assert call_all(ones) == 1
assert call_all(mixed_001) == 1
assert call_all(mixed_010) == 1
assert call_all(mixed_100) == 1
assert call_all(mixed_011) == 1
assert call_all(mixed_101) == 1
assert call_all(mixed_110) == 1

assert call_any_nested([[1, 1, 1], [1, 1], []]) == 1
assert call_any_nested([[1, 1, 1], [0, 1], []]) == 0

[case testAssignModule]
import a
assert a.x == 20
a.x = 10
[file a.py]
x = 20
[file driver.py]
import native

[case testNoneStuff]
from typing import Optional
class A:
    x: int

def lol(x: A) -> None:
    setattr(x, 'x', 5)

def none() -> None:
    return

def arg(x: Optional[A]) -> bool:
    return x is None


[file driver.py]
import native
native.lol(native.A())

# Catch refcounting failures
for i in range(10000):
    native.none()
    native.arg(None)

[case testBorrowRefs]
def make_garbage(arg: object) -> None:
    b = True
    while b:
        arg = None
        b = False

[file driver.py]
from native import make_garbage
import sys

def test():
    x = object()
    r0 = sys.getrefcount(x)
    make_garbage(x)
    r1 = sys.getrefcount(x)
    assert r0 == r1

test()

[case testFinalStaticRunFail]
if False:
    from typing import Final

if bool():
    x: 'Final' = [1]

def f() -> int:
    return x[0]

[file driver.py]
from native import f
try:
    print(f())
except NameError as e:
    print(e.args[0])
[out]
value for final name "x" was not set

[case testFinalStaticRunListTupleInt]
if False:
    from typing import Final

x: 'Final' = [1]
y: 'Final' = (1, 2)
z: 'Final' = 1 + 1

def f() -> int:
    return x[0]
def g() -> int:
    return y[0]
def h() -> int:
    return z - 1

[file driver.py]
from native import f, g, h, x, y, z
print(f())
print(x[0])
print(g())
print(y)
print(h())
print(z)
[out]
1
1
1
(1, 2)
1
2

[case testCheckVersion]
import sys

# We lie about the version we are running in tests if it is 3.5, so
# that hits a crash case.
if sys.version_info[:2] == (3, 9):
    def version() -> int:
        return 9
elif sys.version_info[:2] == (3, 8):
    def version() -> int:
        return 8
elif sys.version_info[:2] == (3, 7):
    def version() -> int:
        return 7
elif sys.version_info[:2] == (3, 6):
    def version() -> int:
        return 6
else:
    raise Exception("we don't support this version yet!")


[file driver.py]
import sys
version = sys.version_info[:2]

try:
    import native
    assert version != (3, 5), "3.5 should fail!"
    assert native.version() == sys.version_info[1]
except RuntimeError:
    assert version == (3, 5), "only 3.5 should fail!"

[case testTypeErrorMessages]
from typing import Tuple
class A:
    pass
class B:
    pass

def f(x: B) -> None:
    pass
def g(x: Tuple[int, A]) -> None:
    pass
[file driver.py]
from testutil import assertRaises
from native import A, f, g

class Busted:
    pass
Busted.__module__ = None

with assertRaises(TypeError, "int"):
    f(0)
with assertRaises(TypeError, "native.A"):
    f(A())
with assertRaises(TypeError, "tuple[None, native.A]"):
    f((None, A()))
with assertRaises(TypeError, "tuple[tuple[int, str], native.A]"):
    f(((1, "ha"), A()))
with assertRaises(TypeError, "tuple[<50 items>]"):
    f(tuple(range(50)))

with assertRaises(TypeError, "errored formatting real type!"):
    f(Busted())

with assertRaises(TypeError, "tuple[int, native.A] object expected; got tuple[int, int]"):
    g((20, 30))

[case testComprehensionShadowBinder]
def foo(x: object) -> object:
    if isinstance(x, list):
        return tuple(x for x in x), x
    return None

[file driver.py]
from native import foo

assert foo(None) == None
assert foo([1, 2, 3]) == ((1, 2, 3), [1, 2, 3])

[case testReexport]
# Test that we properly handle accessing values that have been reexported
import a
def f(x: int) -> int:
    return a.g(x) + a.foo + a.b.foo

whatever = a.A()

[file a.py]
from b import g as g, A as A, foo as foo
import b

[file b.py]
def g(x: int) -> int:
    return x + 1

class A:
    pass

foo = 20

[file driver.py]
from native import f, whatever
import b

assert f(20) == 61
assert isinstance(whatever, b.A)
