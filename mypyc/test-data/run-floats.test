# Test cases for floats (compile and run)

[case testFloatOps]
from typing import Any, cast
from typing_extensions import Final
from testutil import assertRaises, float_vals, FLOAT_MAGIC
import math

def test_arithmetic() -> None:
    zero = float(0.0)
    one = zero + 1.0
    x = one + one / 2.0
    assert x == 1.5
    assert x - one == 0.5
    assert x * x == 2.25
    assert x / 2.0 == 0.75
    assert x * (-0.5) == -0.75
    assert -x == -1.5
    for x in float_vals:
        assert repr(-x) == repr(getattr(x, "__neg__")())

        for y in float_vals:
            assert repr(x + y) == repr(getattr(x, "__add__")(y))
            assert repr(x - y) == repr(getattr(x, "__sub__")(y))
            assert repr(x * y) == repr(getattr(x, "__mul__")(y))
            if y != 0:
                assert repr(x / y) == repr(getattr(x, "__truediv__")(y))

def test_mod() -> None:
    zero = float(0.0)
    one = zero + 1.0
    x = one + one / 2.0
    assert x % 0.4 == 0.29999999999999993
    assert (-x) % 0.4 == 0.10000000000000009
    assert x % -0.4 == -0.10000000000000009
    assert (-x) % -0.4 == -0.29999999999999993
    for x in float_vals:
        for y in float_vals:
            if y != 0:
                assert repr(x % y) == repr(getattr(x, "__mod__")(y))

def test_mixed_arithmetic() -> None:
    zf = float(0.0)
    zn = int()
    assert (zf + 5.5) + (zn + 1) == 6.5
    assert (zn - 2) - (zf - 5.5) == 3.5
    x = zf + 3.4
    x += zn + 2
    assert x == 5.4

def test_arithmetic_errors() -> None:
    zero = float(0.0)
    one = zero + 1.0
    with assertRaises(ZeroDivisionError, "float division by zero"):
        print(one / zero)
    with assertRaises(ZeroDivisionError, "float modulo"):
        print(one % zero)

def test_comparisons() -> None:
    zero = float(0.0)
    one = zero + 1.0
    x = one + one / 2.0
    assert x < (1.51 + zero)
    assert not (x < (1.49 + zero))
    assert x > (1.49 + zero)
    assert not (x > (1.51 + zero))
    assert x <= (1.5 + zero)
    assert not (x <= (1.49 + zero))
    assert x >= (1.5 + zero)
    assert not (x >= (1.51 + zero))
    for x in float_vals:
        for y in float_vals:
            assert (x <= y) == getattr(x, "__le__")(y)
            assert (x < y) == getattr(x, "__lt__")(y)
            assert (x >= y) == getattr(x, "__ge__")(y)
            assert (x > y) == getattr(x, "__gt__")(y)
            assert (x == y) == getattr(x, "__eq__")(y)
            assert (x != y) == getattr(x, "__ne__")(y)

def test_mixed_comparisons() -> None:
    zf = float(0.0)
    zn = int()
    if (zf + 1.0) == (zn + 1):
        assert True
    else:
        assert False
    if (zf + 1.1) == (zn + 1):
        assert False
    else:
        assert True
    assert (zf + 1.1) != (zn + 1)
    assert (zf + 1.1) > (zn + 1)
    assert not (zf + 0.9) > (zn + 1)
    assert (zn + 1) < (zf + 1.1)

def test_boxing_and_unboxing() -> None:
    x = 1.5
    boxed: Any = x
    assert repr(boxed) == "1.5"
    assert type(boxed) is float
    y: float = boxed
    assert y == x
    boxed_int: Any = 5
    assert type(boxed_int) is int
    z: float = boxed_int
    assert z == 5.0
    for xx in float_vals:
        bb: Any = xx
        yy: float = bb
        assert repr(xx) == repr(bb)
        assert repr(xx) == repr(yy)

def test_unboxing_failure() -> None:
    boxed: Any = '1.5'
    with assertRaises(TypeError):
        x: float = boxed

def test_coerce_from_int_literal() -> None:
    x: float = 34
    assert x == 34.0
    y: float = -1
    assert y == -1.0

def test_coerce_from_short_tagged_int() -> None:
    n = int() - 17
    x: float = n
    assert x == -17.0
    for i in range(-300, 300):
        y: float = i
        o: object = y
        assert o == i

def test_coerce_from_long_tagged_int() -> None:
    n = int() + 2**100
    x: float = n
    assert repr(x) == '1.2676506002282294e+30'
    n = int() - 2**100
    y: float = n
    assert repr(y) == '-1.2676506002282294e+30'

def test_coerce_from_very_long_tagged_int() -> None:
    n = int() + 10**1000
    with assertRaises(OverflowError, "int too large to convert to float"):
        x: float = n
    n = int() - 10**1000
    with assertRaises(OverflowError, "int too large to convert to float"):
        y: float = n

def str_to_float(x: str) -> float:
    return float(x)

def test_str_to_float() -> None:
    assert str_to_float("1") == 1.0
    assert str_to_float("1.234567") == 1.234567
    assert str_to_float("44324") == 44324.0
    assert str_to_float("23.4") == 23.4
    assert str_to_float("-43.44e-4") == -43.44e-4
    assert str_to_float("-43.44e-4") == -43.44e-4
    assert math.isinf(str_to_float("inf"))
    assert math.isinf(str_to_float("-inf"))
    assert str_to_float("inf") > 0.0
    assert str_to_float("-inf") < 0.0
    assert math.isnan(str_to_float("nan"))
    assert math.isnan(str_to_float("NaN"))
    assert repr(str_to_float("-0.0")) == "-0.0"

def test_abs() -> None:
    assert abs(0.0) == 0.0
    assert abs(-1.234567) == 1.234567
    assert abs(44324.732) == 44324.732
    assert abs(-23.4) == 23.4
    assert abs(-43.44e-4) == 43.44e-4

def test_float_min_max() -> None:
    for x in float_vals:
        for y in float_vals:
            min_any: Any = min
            assert repr(min(x, y)) == repr(min_any(x, y))

def default(x: float = 2) -> float:
    return x + 1

def test_float_default_value() -> None:
    assert default(1.2) == 2.2
    for i in range(-200, 200):
        assert default(float(i)) == i + 1
    assert default() == 3.0

def test_float_default_value_wrapper() -> None:
    f: Any = default
    assert f(1.2) == 2.2
    for i in range(-200, 200):
        assert f(float(i)) == i + 1
    assert f() == 3.0

class C:
    def __init__(self, x: float) -> None:
        self.x = x

def test_float_attr() -> None:
    for i in range(-200, 200):
        f = float(i)
        c = C(f)
        assert c.x == f
        a: Any = c
        assert a.x == f
        c.x = FLOAT_MAGIC
        assert c.x == FLOAT_MAGIC
        assert a.x == FLOAT_MAGIC
        a.x = 1.0
        assert a.x == 1.0
        a.x = FLOAT_MAGIC
        assert a.x == FLOAT_MAGIC

class D:
    def __init__(self, x: float) -> None:
        if x:
            self.x = x

def test_float_attr_maybe_undefned() -> None:
    for i in range(-200, 200):
        if i == 0:
            d = D(0.0)
            with assertRaises(AttributeError):
                d.x
            a: Any = d
            with assertRaises(AttributeError):
                a.x
            d.x = FLOAT_MAGIC
            assert d.x == FLOAT_MAGIC
            assert a.x == FLOAT_MAGIC
            d.x = 0.0
            assert d.x == 0.0
            assert a.x == 0.0
            a.x = FLOAT_MAGIC
            assert a.x == FLOAT_MAGIC
            d = D(0.0)
            a = cast(Any, d)
            a.x = FLOAT_MAGIC
            assert d.x == FLOAT_MAGIC
        else:
            f = float(i)
            d = D(f)
            assert d.x == f
            a2: Any = d
            assert a2.x == f

def f(x: float) -> float:
    return x + 1

def test_return_values() -> None:
    a: Any = f
    for i in range(-200, 200):
        x = float(i)
        assert f(x) == x + 1
        assert a(x) == x + 1
    for x in float_vals:
        if not math.isnan(x):
            assert f(x) == x + 1
        else:
            assert math.isnan(f(x))

def exc() -> float:
    raise IndexError('x')

def test_exception() -> None:
    with assertRaises(IndexError):
        exc()
    a: Any = exc
    with assertRaises(IndexError):
        a()

def test_undefined_local_var() -> None:
    if not int():
        x = -113.0
    assert x == -113.0
    if int():
        y = -113.0
    with assertRaises(UnboundLocalError, 'local variable "y" referenced before assignment'):
        print(y)
    if not int():
        x2 = -1.0
    assert x2 == -1.0
    if int():
        y2 = -1.0
    with assertRaises(UnboundLocalError, 'local variable "y2" referenced before assignment'):
        print(y2)
