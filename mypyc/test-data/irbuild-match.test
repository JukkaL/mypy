[case testMatchValuePattern_python3_10]
def f():
    match 123:
        case 123:
            print("matched")
[out]
def f():
    r0 :: bit
    r1 :: str
    r2 :: object
    r3 :: str
    r4 :: object
    r5 :: object[1]
    r6 :: object_ptr
    r7, r8 :: object
L0:
    r0 = 246 == 246
    if r0 goto L1 else goto L2 :: bool
L1:
    r1 = 'matched'
    r2 = builtins :: module
    r3 = 'print'
    r4 = CPyObject_GetAttr(r2, r3)
    r5 = [r1]
    r6 = load_address r5
    r7 = _PyObject_Vectorcall(r4, r6, 1, 0)
    keep_alive r1
    goto L3
L2:
L3:
    r8 = box(None, 1)
    return r8
[case testMatchOrPattern_python3_10]
def f():
    match 123:
        case 123 | 456:
            print("matched")
[out]
def f():
    r0, r1 :: bit
    r2 :: str
    r3 :: object
    r4 :: str
    r5 :: object
    r6 :: object[1]
    r7 :: object_ptr
    r8, r9 :: object
L0:
    r0 = 246 == 246
    if r0 goto L3 else goto L1 :: bool
L1:
    r1 = 246 == 912
    if r1 goto L3 else goto L2 :: bool
L2:
    goto L4
L3:
    r2 = 'matched'
    r3 = builtins :: module
    r4 = 'print'
    r5 = CPyObject_GetAttr(r3, r4)
    r6 = [r2]
    r7 = load_address r6
    r8 = _PyObject_Vectorcall(r5, r7, 1, 0)
    keep_alive r2
    goto L5
L4:
L5:
    r9 = box(None, 1)
    return r9
[case testMatchOrPatternManyPatterns_python3_10]
def f():
    match 1:
        case 1 | 2 | 3 | 4:
            print("matched")
[out]
def f():
    r0, r1, r2, r3 :: bit
    r4 :: str
    r5 :: object
    r6 :: str
    r7 :: object
    r8 :: object[1]
    r9 :: object_ptr
    r10, r11 :: object
L0:
    r0 = 2 == 2
    if r0 goto L5 else goto L1 :: bool
L1:
    r1 = 2 == 4
    if r1 goto L5 else goto L2 :: bool
L2:
    r2 = 2 == 6
    if r2 goto L5 else goto L3 :: bool
L3:
    r3 = 2 == 8
    if r3 goto L5 else goto L4 :: bool
L4:
    goto L6
L5:
    r4 = 'matched'
    r5 = builtins :: module
    r6 = 'print'
    r7 = CPyObject_GetAttr(r5, r6)
    r8 = [r4]
    r9 = load_address r8
    r10 = _PyObject_Vectorcall(r7, r9, 1, 0)
    keep_alive r4
    goto L7
L6:
L7:
    r11 = box(None, 1)
    return r11
[case testMatchClassPattern_python3_10]
def f():
    match 123:
        case int():
            print("matched")
[out]
def f():
    r0, r1 :: object
    r2 :: int32
    r3 :: bit
    r4 :: bool
    r5 :: str
    r6 :: object
    r7 :: str
    r8 :: object
    r9 :: object[1]
    r10 :: object_ptr
    r11, r12 :: object
L0:
    r0 = load_address PyLong_Type
    r1 = object 123
    r2 = PyObject_IsInstance(r1, r0)
    r3 = r2 >= 0 :: signed
    r4 = truncate r2: int32 to builtins.bool
    if r4 goto L1 else goto L2 :: bool
L1:
    r5 = 'matched'
    r6 = builtins :: module
    r7 = 'print'
    r8 = CPyObject_GetAttr(r6, r7)
    r9 = [r5]
    r10 = load_address r9
    r11 = _PyObject_Vectorcall(r8, r10, 1, 0)
    keep_alive r5
    goto L3
L2:
L3:
    r12 = box(None, 1)
    return r12
[case testMatchExaustivePattern_python3_10]
def f():
    match 123:
        case _:
            print("matched")
[out]
def f():
    r0 :: str
    r1 :: object
    r2 :: str
    r3 :: object
    r4 :: object[1]
    r5 :: object_ptr
    r6, r7 :: object
L0:
L1:
    r0 = 'matched'
    r1 = builtins :: module
    r2 = 'print'
    r3 = CPyObject_GetAttr(r1, r2)
    r4 = [r0]
    r5 = load_address r4
    r6 = _PyObject_Vectorcall(r3, r5, 1, 0)
    keep_alive r0
    goto L3
L2:
L3:
    r7 = box(None, 1)
    return r7
[case testMatchMultipleBodies_python3_10]
def f():
    match 123:
        case 123:
            print("matched")
        case 456:
            print("no match")
[out]
def f():
    r0 :: bit
    r1 :: str
    r2 :: object
    r3 :: str
    r4 :: object
    r5 :: object[1]
    r6 :: object_ptr
    r7 :: object
    r8 :: bit
    r9 :: str
    r10 :: object
    r11 :: str
    r12 :: object
    r13 :: object[1]
    r14 :: object_ptr
    r15, r16 :: object
L0:
    r0 = 246 == 246
    if r0 goto L1 else goto L2 :: bool
L1:
    r1 = 'matched'
    r2 = builtins :: module
    r3 = 'print'
    r4 = CPyObject_GetAttr(r2, r3)
    r5 = [r1]
    r6 = load_address r5
    r7 = _PyObject_Vectorcall(r4, r6, 1, 0)
    keep_alive r1
    goto L5
L2:
    r8 = 246 == 912
    if r8 goto L3 else goto L4 :: bool
L3:
    r9 = 'no match'
    r10 = builtins :: module
    r11 = 'print'
    r12 = CPyObject_GetAttr(r10, r11)
    r13 = [r9]
    r14 = load_address r13
    r15 = _PyObject_Vectorcall(r12, r14, 1, 0)
    keep_alive r9
    goto L5
L4:
L5:
    r16 = box(None, 1)
    return r16
[case testMatchMultiBodyAndComplexOr_python3_10]
def f():
    match 123:
        case 1:
            print("here 1")
        case 2 | 3:
            print("here 2 | 3")
        case 123:
            print("here 123")
[out]
def f():
    r0 :: bit
    r1 :: str
    r2 :: object
    r3 :: str
    r4 :: object
    r5 :: object[1]
    r6 :: object_ptr
    r7 :: object
    r8, r9 :: bit
    r10 :: str
    r11 :: object
    r12 :: str
    r13 :: object
    r14 :: object[1]
    r15 :: object_ptr
    r16 :: object
    r17 :: bit
    r18 :: str
    r19 :: object
    r20 :: str
    r21 :: object
    r22 :: object[1]
    r23 :: object_ptr
    r24, r25 :: object
L0:
    r0 = 246 == 2
    if r0 goto L1 else goto L2 :: bool
L1:
    r1 = 'here 1'
    r2 = builtins :: module
    r3 = 'print'
    r4 = CPyObject_GetAttr(r2, r3)
    r5 = [r1]
    r6 = load_address r5
    r7 = _PyObject_Vectorcall(r4, r6, 1, 0)
    keep_alive r1
    goto L9
L2:
    r8 = 246 == 4
    if r8 goto L5 else goto L3 :: bool
L3:
    r9 = 246 == 6
    if r9 goto L5 else goto L4 :: bool
L4:
    goto L6
L5:
    r10 = 'here 2 | 3'
    r11 = builtins :: module
    r12 = 'print'
    r13 = CPyObject_GetAttr(r11, r12)
    r14 = [r10]
    r15 = load_address r14
    r16 = _PyObject_Vectorcall(r13, r15, 1, 0)
    keep_alive r10
    goto L9
L6:
    r17 = 246 == 246
    if r17 goto L7 else goto L8 :: bool
L7:
    r18 = 'here 123'
    r19 = builtins :: module
    r20 = 'print'
    r21 = CPyObject_GetAttr(r19, r20)
    r22 = [r18]
    r23 = load_address r22
    r24 = _PyObject_Vectorcall(r21, r23, 1, 0)
    keep_alive r18
    goto L9
L8:
L9:
    r25 = box(None, 1)
    return r25
[case testMatchWithGuard_python3_10]
def f():
    match 123:
        case 123 if True:
            print("matched")
[out]
def f():
    r0 :: bit
    r1 :: str
    r2 :: object
    r3 :: str
    r4 :: object
    r5 :: object[1]
    r6 :: object_ptr
    r7, r8 :: object
L0:
    r0 = 246 == 246
    if r0 goto L1 else goto L3 :: bool
L1:
    if 1 goto L2 else goto L3 :: bool
L2:
    r1 = 'matched'
    r2 = builtins :: module
    r3 = 'print'
    r4 = CPyObject_GetAttr(r2, r3)
    r5 = [r1]
    r6 = load_address r5
    r7 = _PyObject_Vectorcall(r4, r6, 1, 0)
    keep_alive r1
    goto L4
L3:
L4:
    r8 = box(None, 1)
    return r8
[case testMatchSingleton_python3_10]
def f():
    match 123:
        case True:
            print("value is True")
        case False:
            print("value is False")
        case None:
            print("value is None")
[out]
def f():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: str
    r6 :: object
    r7 :: object[1]
    r8 :: object_ptr
    r9, r10, r11 :: object
    r12 :: bit
    r13 :: str
    r14 :: object
    r15 :: str
    r16 :: object
    r17 :: object[1]
    r18 :: object_ptr
    r19, r20, r21 :: object
    r22 :: bit
    r23 :: str
    r24 :: object
    r25 :: str
    r26 :: object
    r27 :: object[1]
    r28 :: object_ptr
    r29, r30 :: object
L0:
    r0 = object 123
    r1 = box(bool, 1)
    r2 = r0 == r1
    if r2 goto L1 else goto L2 :: bool
L1:
    r3 = 'value is True'
    r4 = builtins :: module
    r5 = 'print'
    r6 = CPyObject_GetAttr(r4, r5)
    r7 = [r3]
    r8 = load_address r7
    r9 = _PyObject_Vectorcall(r6, r8, 1, 0)
    keep_alive r3
    goto L7
L2:
    r10 = object 123
    r11 = box(bool, 0)
    r12 = r10 == r11
    if r12 goto L3 else goto L4 :: bool
L3:
    r13 = 'value is False'
    r14 = builtins :: module
    r15 = 'print'
    r16 = CPyObject_GetAttr(r14, r15)
    r17 = [r13]
    r18 = load_address r17
    r19 = _PyObject_Vectorcall(r16, r18, 1, 0)
    keep_alive r13
    goto L7
L4:
    r20 = load_address _Py_NoneStruct
    r21 = object 123
    r22 = r21 == r20
    if r22 goto L5 else goto L6 :: bool
L5:
    r23 = 'value is None'
    r24 = builtins :: module
    r25 = 'print'
    r26 = CPyObject_GetAttr(r24, r25)
    r27 = [r23]
    r28 = load_address r27
    r29 = _PyObject_Vectorcall(r26, r28, 1, 0)
    keep_alive r23
    goto L7
L6:
L7:
    r30 = box(None, 1)
    return r30
[case testMatchRecursiveOrPattern_python3_10]
def f():
    match 1:
        case 1 | int():
            print("matched")
[out]
def f():
    r0 :: bit
    r1, r2 :: object
    r3 :: int32
    r4 :: bit
    r5 :: bool
    r6 :: str
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: object[1]
    r11 :: object_ptr
    r12, r13 :: object
L0:
    r0 = 2 == 2
    if r0 goto L3 else goto L1 :: bool
L1:
    r1 = load_address PyLong_Type
    r2 = object 1
    r3 = PyObject_IsInstance(r2, r1)
    r4 = r3 >= 0 :: signed
    r5 = truncate r3: int32 to builtins.bool
    if r5 goto L3 else goto L2 :: bool
L2:
    goto L4
L3:
    r6 = 'matched'
    r7 = builtins :: module
    r8 = 'print'
    r9 = CPyObject_GetAttr(r7, r8)
    r10 = [r6]
    r11 = load_address r10
    r12 = _PyObject_Vectorcall(r9, r11, 1, 0)
    keep_alive r6
    goto L5
L4:
L5:
    r13 = box(None, 1)
    return r13
[case testMatchAsPattern_python3_10]
def f():
    match 123:
        case 123 as x:
            print(x)
[out]
def f():
    r0 :: bit
    r1, x, r2 :: object
    r3 :: str
    r4 :: object
    r5 :: object[1]
    r6 :: object_ptr
    r7, r8 :: object
L0:
    r0 = 246 == 246
    r1 = object 123
    x = r1
    if r0 goto L1 else goto L2 :: bool
L1:
    r2 = builtins :: module
    r3 = 'print'
    r4 = CPyObject_GetAttr(r2, r3)
    r5 = [x]
    r6 = load_address r5
    r7 = _PyObject_Vectorcall(r4, r6, 1, 0)
    keep_alive x
    goto L3
L2:
L3:
    r8 = box(None, 1)
    return r8
[case testMatchAsPatternOnOrPattern_python3_10]
def f():
    match 1:
        case (1 | 2) as x:
            print(x)
[out]
def f():
    r0 :: bit
    r1, x :: object
    r2 :: bit
    r3, r4 :: object
    r5 :: str
    r6 :: object
    r7 :: object[1]
    r8 :: object_ptr
    r9, r10 :: object
L0:
    r0 = 2 == 2
    r1 = object 1
    x = r1
    if r0 goto L3 else goto L1 :: bool
L1:
    r2 = 2 == 4
    r3 = object 2
    x = r3
    if r2 goto L3 else goto L2 :: bool
L2:
    goto L4
L3:
    r4 = builtins :: module
    r5 = 'print'
    r6 = CPyObject_GetAttr(r4, r5)
    r7 = [x]
    r8 = load_address r7
    r9 = _PyObject_Vectorcall(r6, r8, 1, 0)
    keep_alive x
    goto L5
L4:
L5:
    r10 = box(None, 1)
    return r10
[case testMatchAsPatternOnClassPattern_python3_10]
def f():
    match 123:
        case int() as i:
            print(i)
[out]
def f():
    r0, r1 :: object
    r2 :: int32
    r3 :: bit
    r4 :: bool
    i :: int
    r5 :: object
    r6 :: str
    r7, r8 :: object
    r9 :: object[1]
    r10 :: object_ptr
    r11, r12 :: object
L0:
    r0 = load_address PyLong_Type
    r1 = object 123
    r2 = PyObject_IsInstance(r1, r0)
    r3 = r2 >= 0 :: signed
    r4 = truncate r2: int32 to builtins.bool
    if r4 goto L1 else goto L3 :: bool
L1:
    i = 246
L2:
    r5 = builtins :: module
    r6 = 'print'
    r7 = CPyObject_GetAttr(r5, r6)
    r8 = box(int, i)
    r9 = [r8]
    r10 = load_address r9
    r11 = _PyObject_Vectorcall(r7, r10, 1, 0)
    keep_alive r8
    goto L4
L3:
L4:
    r12 = box(None, 1)
    return r12
[case testMatchClassPatternWithPositionalArgs_python3_10]
class Position:
    __match_args__ = ("x", "y", "z")

    x: int
    y: int
    z: int

def f(x):
    match x:
        case Position(1, 2, 3):
            print("matched")
[out]
def Position.__mypyc_defaults_setup(__mypyc_self__):
    __mypyc_self__ :: __main__.Position
    r0, r1, r2 :: str
    r3 :: tuple[str, str, str]
L0:
    r0 = 'x'
    r1 = 'y'
    r2 = 'z'
    r3 = (r0, r1, r2)
    __mypyc_self__.__match_args__ = r3
    return 1
def f(x):
    x, r0 :: object
    r1 :: int32
    r2 :: bit
    r3 :: bool
    r4 :: str
    r5, r6, r7 :: object
    r8 :: int32
    r9 :: bit
    r10 :: bool
    r11 :: str
    r12, r13, r14 :: object
    r15 :: int32
    r16 :: bit
    r17 :: bool
    r18 :: str
    r19, r20, r21 :: object
    r22 :: int32
    r23 :: bit
    r24 :: bool
    r25 :: str
    r26 :: object
    r27 :: str
    r28 :: object
    r29 :: object[1]
    r30 :: object_ptr
    r31, r32 :: object
L0:
    r0 = __main__.Position :: type
    r1 = PyObject_IsInstance(x, r0)
    r2 = r1 >= 0 :: signed
    r3 = truncate r1: int32 to builtins.bool
    if r3 goto L1 else goto L5 :: bool
L1:
    r4 = 'x'
    r5 = CPyObject_GetAttr(x, r4)
    r6 = object 1
    r7 = PyObject_RichCompare(r5, r6, 2)
    r8 = PyObject_IsTrue(r7)
    r9 = r8 >= 0 :: signed
    r10 = truncate r8: int32 to builtins.bool
    if r10 goto L2 else goto L5 :: bool
L2:
    r11 = 'y'
    r12 = CPyObject_GetAttr(x, r11)
    r13 = object 2
    r14 = PyObject_RichCompare(r12, r13, 2)
    r15 = PyObject_IsTrue(r14)
    r16 = r15 >= 0 :: signed
    r17 = truncate r15: int32 to builtins.bool
    if r17 goto L3 else goto L5 :: bool
L3:
    r18 = 'z'
    r19 = CPyObject_GetAttr(x, r18)
    r20 = object 3
    r21 = PyObject_RichCompare(r19, r20, 2)
    r22 = PyObject_IsTrue(r21)
    r23 = r22 >= 0 :: signed
    r24 = truncate r22: int32 to builtins.bool
    if r24 goto L4 else goto L5 :: bool
L4:
    r25 = 'matched'
    r26 = builtins :: module
    r27 = 'print'
    r28 = CPyObject_GetAttr(r26, r27)
    r29 = [r25]
    r30 = load_address r29
    r31 = _PyObject_Vectorcall(r28, r30, 1, 0)
    keep_alive r25
    goto L6
L5:
L6:
    r32 = box(None, 1)
    return r32
[case testMatchClassPatternWithKeywordPatterns_python3_10]
class Position:
    x: int
    y: int
    z: int

def f(x):
    match x:
        case Position(z=1, y=2, x=3):
            print("matched")
[out]
def f(x):
    x, r0 :: object
    r1 :: int32
    r2 :: bit
    r3 :: bool
    r4 :: str
    r5, r6, r7 :: object
    r8 :: int32
    r9 :: bit
    r10 :: bool
    r11 :: str
    r12, r13, r14 :: object
    r15 :: int32
    r16 :: bit
    r17 :: bool
    r18 :: str
    r19, r20, r21 :: object
    r22 :: int32
    r23 :: bit
    r24 :: bool
    r25 :: str
    r26 :: object
    r27 :: str
    r28 :: object
    r29 :: object[1]
    r30 :: object_ptr
    r31, r32 :: object
L0:
    r0 = __main__.Position :: type
    r1 = PyObject_IsInstance(x, r0)
    r2 = r1 >= 0 :: signed
    r3 = truncate r1: int32 to builtins.bool
    if r3 goto L1 else goto L5 :: bool
L1:
    r4 = 'z'
    r5 = CPyObject_GetAttr(x, r4)
    r6 = object 1
    r7 = PyObject_RichCompare(r5, r6, 2)
    r8 = PyObject_IsTrue(r7)
    r9 = r8 >= 0 :: signed
    r10 = truncate r8: int32 to builtins.bool
    if r10 goto L2 else goto L5 :: bool
L2:
    r11 = 'y'
    r12 = CPyObject_GetAttr(x, r11)
    r13 = object 2
    r14 = PyObject_RichCompare(r12, r13, 2)
    r15 = PyObject_IsTrue(r14)
    r16 = r15 >= 0 :: signed
    r17 = truncate r15: int32 to builtins.bool
    if r17 goto L3 else goto L5 :: bool
L3:
    r18 = 'x'
    r19 = CPyObject_GetAttr(x, r18)
    r20 = object 3
    r21 = PyObject_RichCompare(r19, r20, 2)
    r22 = PyObject_IsTrue(r21)
    r23 = r22 >= 0 :: signed
    r24 = truncate r22: int32 to builtins.bool
    if r24 goto L4 else goto L5 :: bool
L4:
    r25 = 'matched'
    r26 = builtins :: module
    r27 = 'print'
    r28 = CPyObject_GetAttr(r26, r27)
    r29 = [r25]
    r30 = load_address r29
    r31 = _PyObject_Vectorcall(r28, r30, 1, 0)
    keep_alive r25
    goto L6
L5:
L6:
    r32 = box(None, 1)
    return r32
[case testMatchClassPatternWithNestedPattern_python3_10]
class C:
    num: int

def f(x):
    match x:
        case C(num=1 | 2):
            print("matched")
[out]
def f(x):
    x, r0 :: object
    r1 :: int32
    r2 :: bit
    r3 :: bool
    r4 :: str
    r5, r6, r7 :: object
    r8 :: int32
    r9 :: bit
    r10 :: bool
    r11, r12 :: object
    r13 :: int32
    r14 :: bit
    r15 :: bool
    r16 :: str
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: object[1]
    r21 :: object_ptr
    r22, r23 :: object
L0:
    r0 = __main__.C :: type
    r1 = PyObject_IsInstance(x, r0)
    r2 = r1 >= 0 :: signed
    r3 = truncate r1: int32 to builtins.bool
    if r3 goto L1 else goto L5 :: bool
L1:
    r4 = 'num'
    r5 = CPyObject_GetAttr(x, r4)
    r6 = object 1
    r7 = PyObject_RichCompare(r5, r6, 2)
    r8 = PyObject_IsTrue(r7)
    r9 = r8 >= 0 :: signed
    r10 = truncate r8: int32 to builtins.bool
    if r10 goto L4 else goto L2 :: bool
L2:
    r11 = object 2
    r12 = PyObject_RichCompare(r5, r11, 2)
    r13 = PyObject_IsTrue(r12)
    r14 = r13 >= 0 :: signed
    r15 = truncate r13: int32 to builtins.bool
    if r15 goto L4 else goto L3 :: bool
L3:
    goto L5
L4:
    r16 = 'matched'
    r17 = builtins :: module
    r18 = 'print'
    r19 = CPyObject_GetAttr(r17, r18)
    r20 = [r16]
    r21 = load_address r20
    r22 = _PyObject_Vectorcall(r19, r21, 1, 0)
    keep_alive r16
    goto L6
L5:
L6:
    r23 = box(None, 1)
    return r23
[case testAsPatternDoesntBleedIntoSubPatterns_python3_10]
class C:
    __match_args__ = ("a", "b")
    a: int
    b: int

def f(x):
    match x:
        case C(1, 2) as y:
            print("matched")
[out]
def C.__mypyc_defaults_setup(__mypyc_self__):
    __mypyc_self__ :: __main__.C
    r0, r1 :: str
    r2 :: tuple[str, str]
L0:
    r0 = 'a'
    r1 = 'b'
    r2 = (r0, r1)
    __mypyc_self__.__match_args__ = r2
    return 1
def f(x):
    x, r0 :: object
    r1 :: int32
    r2 :: bit
    r3 :: bool
    r4, y :: __main__.C
    r5 :: str
    r6, r7, r8 :: object
    r9 :: int32
    r10 :: bit
    r11 :: bool
    r12 :: str
    r13, r14, r15 :: object
    r16 :: int32
    r17 :: bit
    r18 :: bool
    r19 :: str
    r20 :: object
    r21 :: str
    r22 :: object
    r23 :: object[1]
    r24 :: object_ptr
    r25, r26 :: object
L0:
    r0 = __main__.C :: type
    r1 = PyObject_IsInstance(x, r0)
    r2 = r1 >= 0 :: signed
    r3 = truncate r1: int32 to builtins.bool
    if r3 goto L1 else goto L5 :: bool
L1:
    r4 = cast(__main__.C, x)
    y = r4
L2:
    r5 = 'a'
    r6 = CPyObject_GetAttr(x, r5)
    r7 = object 1
    r8 = PyObject_RichCompare(r6, r7, 2)
    r9 = PyObject_IsTrue(r8)
    r10 = r9 >= 0 :: signed
    r11 = truncate r9: int32 to builtins.bool
    if r11 goto L3 else goto L5 :: bool
L3:
    r12 = 'b'
    r13 = CPyObject_GetAttr(x, r12)
    r14 = object 2
    r15 = PyObject_RichCompare(r13, r14, 2)
    r16 = PyObject_IsTrue(r15)
    r17 = r16 >= 0 :: signed
    r18 = truncate r16: int32 to builtins.bool
    if r18 goto L4 else goto L5 :: bool
L4:
    r19 = 'matched'
    r20 = builtins :: module
    r21 = 'print'
    r22 = CPyObject_GetAttr(r20, r21)
    r23 = [r19]
    r24 = load_address r23
    r25 = _PyObject_Vectorcall(r22, r24, 1, 0)
    keep_alive r19
    goto L6
L5:
L6:
    r26 = box(None, 1)
    return r26
[case testMatchClassPatternPositionalCapture_python3_10]
class C:
    __match_args__ = ("x",)

    x: int

def f(x):
    match x:
        case C(num):
            print("matched")
[out]
def C.__mypyc_defaults_setup(__mypyc_self__):
    __mypyc_self__ :: __main__.C
    r0 :: str
    r1 :: tuple[str]
L0:
    r0 = 'x'
    r1 = (r0)
    __mypyc_self__.__match_args__ = r1
    return 1
def f(x):
    x, r0 :: object
    r1 :: int32
    r2 :: bit
    r3 :: bool
    r4 :: str
    r5 :: object
    r6, num :: int
    r7 :: str
    r8 :: object
    r9 :: str
    r10 :: object
    r11 :: object[1]
    r12 :: object_ptr
    r13, r14 :: object
L0:
    r0 = __main__.C :: type
    r1 = PyObject_IsInstance(x, r0)
    r2 = r1 >= 0 :: signed
    r3 = truncate r1: int32 to builtins.bool
    if r3 goto L1 else goto L3 :: bool
L1:
    r4 = 'x'
    r5 = CPyObject_GetAttr(x, r4)
    r6 = unbox(int, r5)
    num = r6
L2:
    r7 = 'matched'
    r8 = builtins :: module
    r9 = 'print'
    r10 = CPyObject_GetAttr(r8, r9)
    r11 = [r7]
    r12 = load_address r11
    r13 = _PyObject_Vectorcall(r10, r12, 1, 0)
    keep_alive r7
    goto L4
L3:
L4:
    r14 = box(None, 1)
    return r14
[case testMatchMappingEmpty_python3_10]
def f(x):
    match x:
        case {}:
            print("matched")
[out]
def f(x):
    x :: object
    r0 :: int32
    r1 :: bit
    r2 :: str
    r3 :: object
    r4 :: str
    r5 :: object
    r6 :: object[1]
    r7 :: object_ptr
    r8, r9 :: object
L0:
    r0 = PyDict_Check(x)
    r1 = r0 != 0
    if r1 goto L1 else goto L2 :: bool
L1:
    r2 = 'matched'
    r3 = builtins :: module
    r4 = 'print'
    r5 = CPyObject_GetAttr(r3, r4)
    r6 = [r2]
    r7 = load_address r6
    r8 = _PyObject_Vectorcall(r5, r7, 1, 0)
    keep_alive r2
    goto L3
L2:
L3:
    r9 = box(None, 1)
    return r9
[case testMatchMappingPatternWithKeys_python3_10]
def f(x):
    match x:
        case {"key": "value"}:
            print("matched")
[out]
def f(x):
    x :: object
    r0 :: int32
    r1 :: bit
    r2 :: str
    r3 :: int32
    r4 :: bit
    r5 :: bool
    r6 :: dict
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: int32
    r11 :: bit
    r12 :: bool
    r13 :: str
    r14 :: object
    r15 :: str
    r16 :: object
    r17 :: object[1]
    r18 :: object_ptr
    r19, r20 :: object
L0:
    r0 = PyDict_Check(x)
    r1 = r0 != 0
    if r1 goto L1 else goto L4 :: bool
L1:
    r2 = 'key'
    r3 = PySequence_Contains(x, r2)
    r4 = r3 >= 0 :: signed
    r5 = truncate r3: int32 to builtins.bool
    if r5 goto L2 else goto L4 :: bool
L2:
    r6 = cast(dict, x)
    r7 = CPyDict_GetItem(r6, r2)
    r8 = 'value'
    r9 = PyObject_RichCompare(r7, r8, 2)
    r10 = PyObject_IsTrue(r9)
    r11 = r10 >= 0 :: signed
    r12 = truncate r10: int32 to builtins.bool
    if r12 goto L3 else goto L4 :: bool
L3:
    r13 = 'matched'
    r14 = builtins :: module
    r15 = 'print'
    r16 = CPyObject_GetAttr(r14, r15)
    r17 = [r13]
    r18 = load_address r17
    r19 = _PyObject_Vectorcall(r16, r18, 1, 0)
    keep_alive r13
    goto L5
L4:
L5:
    r20 = box(None, 1)
    return r20
[case testMatchMappingPatternWithRest_python3_10]
def f(x):
    match x:
        case {**rest}:
            print("matched")
[out]
def f(x):
    x :: object
    r0 :: int32
    r1 :: bit
    r2, rest :: dict
    r3 :: str
    r4 :: object
    r5 :: str
    r6 :: object
    r7 :: object[1]
    r8 :: object_ptr
    r9, r10 :: object
L0:
    r0 = PyDict_Check(x)
    r1 = r0 != 0
    if r1 goto L1 else goto L3 :: bool
L1:
    r2 = CPyDict_FromAny(x)
    rest = r2
L2:
    r3 = 'matched'
    r4 = builtins :: module
    r5 = 'print'
    r6 = CPyObject_GetAttr(r4, r5)
    r7 = [r3]
    r8 = load_address r7
    r9 = _PyObject_Vectorcall(r6, r8, 1, 0)
    keep_alive r3
    goto L4
L3:
L4:
    r10 = box(None, 1)
    return r10
[case testMatchMappingPatternWithRestPopKeys_python3_10]
def f(x):
    match x:
        case {"key": "value", **rest}:
            print("matched")
[out]
def f(x):
    x :: object
    r0 :: int32
    r1 :: bit
    r2 :: str
    r3 :: int32
    r4 :: bit
    r5 :: bool
    r6 :: dict
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: int32
    r11 :: bit
    r12 :: bool
    r13, rest :: dict
    r14 :: int32
    r15 :: bit
    r16 :: str
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: object[1]
    r21 :: object_ptr
    r22, r23 :: object
L0:
    r0 = PyDict_Check(x)
    r1 = r0 != 0
    if r1 goto L1 else goto L5 :: bool
L1:
    r2 = 'key'
    r3 = PySequence_Contains(x, r2)
    r4 = r3 >= 0 :: signed
    r5 = truncate r3: int32 to builtins.bool
    if r5 goto L2 else goto L5 :: bool
L2:
    r6 = cast(dict, x)
    r7 = CPyDict_GetItem(r6, r2)
    r8 = 'value'
    r9 = PyObject_RichCompare(r7, r8, 2)
    r10 = PyObject_IsTrue(r9)
    r11 = r10 >= 0 :: signed
    r12 = truncate r10: int32 to builtins.bool
    if r12 goto L3 else goto L5 :: bool
L3:
    r13 = CPyDict_FromAny(x)
    rest = r13
    r14 = PyDict_DelItem(r13, r2)
    r15 = r14 >= 0 :: signed
L4:
    r16 = 'matched'
    r17 = builtins :: module
    r18 = 'print'
    r19 = CPyObject_GetAttr(r17, r18)
    r20 = [r16]
    r21 = load_address r20
    r22 = _PyObject_Vectorcall(r19, r21, 1, 0)
    keep_alive r16
    goto L6
L5:
L6:
    r23 = box(None, 1)
    return r23
[case testMatchEmptySequencePattern_python3_10]
def f(x):
    match x:
        case []:
            print("matched")
[out]
def f(x):
    x :: object
    r0 :: int32
    r1 :: bit
    r2 :: str
    r3 :: object
    r4 :: str
    r5 :: object
    r6 :: object[1]
    r7 :: object_ptr
    r8, r9 :: object
L0:
    r0 = PyList_Check(x)
    r1 = r0 != 0
    if r1 goto L1 else goto L2 :: bool
L1:
    r2 = 'matched'
    r3 = builtins :: module
    r4 = 'print'
    r5 = CPyObject_GetAttr(r3, r4)
    r6 = [r2]
    r7 = load_address r6
    r8 = _PyObject_Vectorcall(r5, r7, 1, 0)
    keep_alive r2
    goto L3
L2:
L3:
    r9 = box(None, 1)
    return r9
[case testMatchFixedLengthSequencePattern_python3_10]
def f(x):
    match x:
        case [1, 2]:
            print("matched")
[out]
def f(x):
    x :: object
    r0 :: int32
    r1 :: bit
    r2 :: native_int
    r3, r4 :: bit
    r5 :: list
    r6, r7, r8 :: object
    r9 :: int32
    r10 :: bit
    r11 :: bool
    r12 :: list
    r13, r14, r15 :: object
    r16 :: int32
    r17 :: bit
    r18 :: bool
    r19 :: str
    r20 :: object
    r21 :: str
    r22 :: object
    r23 :: object[1]
    r24 :: object_ptr
    r25, r26 :: object
L0:
    r0 = PyList_Check(x)
    r1 = r0 != 0
    if r1 goto L1 else goto L5 :: bool
L1:
    r2 = PyObject_Size(x)
    r3 = r2 >= 0 :: signed
    r4 = r2 == 2
    if r4 goto L2 else goto L5 :: bool
L2:
    r5 = cast(list, x)
    r6 = CPyList_GetItem(r5, 0)
    r7 = object 1
    r8 = PyObject_RichCompare(r6, r7, 2)
    r9 = PyObject_IsTrue(r8)
    r10 = r9 >= 0 :: signed
    r11 = truncate r9: int32 to builtins.bool
    if r11 goto L3 else goto L5 :: bool
L3:
    r12 = cast(list, x)
    r13 = CPyList_GetItem(r12, 2)
    r14 = object 2
    r15 = PyObject_RichCompare(r13, r14, 2)
    r16 = PyObject_IsTrue(r15)
    r17 = r16 >= 0 :: signed
    r18 = truncate r16: int32 to builtins.bool
    if r18 goto L4 else goto L5 :: bool
L4:
    r19 = 'matched'
    r20 = builtins :: module
    r21 = 'print'
    r22 = CPyObject_GetAttr(r20, r21)
    r23 = [r19]
    r24 = load_address r23
    r25 = _PyObject_Vectorcall(r22, r24, 1, 0)
    keep_alive r19
    goto L6
L5:
L6:
    r26 = box(None, 1)
    return r26
[case testMatchSequencePatternWithTrailingUnboundStar_python3_10]
def f(x):
    match x:
        case [1, 2, *_]:
            print("matched")
[out]
def f(x):
    x :: object
    r0 :: int32
    r1 :: bit
    r2 :: native_int
    r3, r4 :: bit
    r5 :: list
    r6, r7, r8 :: object
    r9 :: int32
    r10 :: bit
    r11 :: bool
    r12 :: list
    r13, r14, r15 :: object
    r16 :: int32
    r17 :: bit
    r18 :: bool
    r19 :: str
    r20 :: object
    r21 :: str
    r22 :: object
    r23 :: object[1]
    r24 :: object_ptr
    r25, r26 :: object
L0:
    r0 = PyList_Check(x)
    r1 = r0 != 0
    if r1 goto L1 else goto L5 :: bool
L1:
    r2 = PyObject_Size(x)
    r3 = r2 >= 0 :: signed
    r4 = r2 >= 2 :: signed
    if r4 goto L2 else goto L5 :: bool
L2:
    r5 = cast(list, x)
    r6 = CPyList_GetItem(r5, 0)
    r7 = object 1
    r8 = PyObject_RichCompare(r6, r7, 2)
    r9 = PyObject_IsTrue(r8)
    r10 = r9 >= 0 :: signed
    r11 = truncate r9: int32 to builtins.bool
    if r11 goto L3 else goto L5 :: bool
L3:
    r12 = cast(list, x)
    r13 = CPyList_GetItem(r12, 2)
    r14 = object 2
    r15 = PyObject_RichCompare(r13, r14, 2)
    r16 = PyObject_IsTrue(r15)
    r17 = r16 >= 0 :: signed
    r18 = truncate r16: int32 to builtins.bool
    if r18 goto L4 else goto L5 :: bool
L4:
    r19 = 'matched'
    r20 = builtins :: module
    r21 = 'print'
    r22 = CPyObject_GetAttr(r20, r21)
    r23 = [r19]
    r24 = load_address r23
    r25 = _PyObject_Vectorcall(r22, r24, 1, 0)
    keep_alive r19
    goto L6
L5:
L6:
    r26 = box(None, 1)
    return r26
[case testMatchSequencePatternWithTrailingBoundStar_python3_10]
def f(x):
    match x:
        case [1, 2, *rest]:
            print("matched")
[out]
def f(x):
    x :: object
    r0 :: int32
    r1 :: bit
    r2 :: native_int
    r3, r4 :: bit
    r5 :: list
    r6, r7, r8 :: object
    r9 :: int32
    r10 :: bit
    r11 :: bool
    r12 :: list
    r13, r14, r15 :: object
    r16 :: int32
    r17 :: bit
    r18 :: bool
    r19 :: native_int
    r20 :: list
    r21, r22 :: bit
    r23, r24, r25 :: int
    r26, rest :: object
    r27 :: str
    r28 :: object
    r29 :: str
    r30 :: object
    r31 :: object[1]
    r32 :: object_ptr
    r33, r34 :: object
L0:
    r0 = PyList_Check(x)
    r1 = r0 != 0
    if r1 goto L1 else goto L10 :: bool
L1:
    r2 = PyObject_Size(x)
    r3 = r2 >= 0 :: signed
    r4 = r2 >= 2 :: signed
    if r4 goto L2 else goto L10 :: bool
L2:
    r5 = cast(list, x)
    r6 = CPyList_GetItem(r5, 0)
    r7 = object 1
    r8 = PyObject_RichCompare(r6, r7, 2)
    r9 = PyObject_IsTrue(r8)
    r10 = r9 >= 0 :: signed
    r11 = truncate r9: int32 to builtins.bool
    if r11 goto L3 else goto L10 :: bool
L3:
    r12 = cast(list, x)
    r13 = CPyList_GetItem(r12, 2)
    r14 = object 2
    r15 = PyObject_RichCompare(r13, r14, 2)
    r16 = PyObject_IsTrue(r15)
    r17 = r16 >= 0 :: signed
    r18 = truncate r16: int32 to builtins.bool
    if r18 goto L4 else goto L10 :: bool
L4:
    r19 = r2 - 0
    r20 = cast(list, x)
    r21 = r19 <= 4611686018427387903 :: signed
    if r21 goto L5 else goto L6 :: bool
L5:
    r22 = r19 >= -4611686018427387904 :: signed
    if r22 goto L7 else goto L6 :: bool
L6:
    r23 = CPyTagged_FromInt64(r19)
    r24 = r23
    goto L8
L7:
    r25 = r19 << 1
    r24 = r25
L8:
    r26 = CPyList_GetSlice(r20, 4, r24)
    rest = r26
L9:
    r27 = 'matched'
    r28 = builtins :: module
    r29 = 'print'
    r30 = CPyObject_GetAttr(r28, r29)
    r31 = [r27]
    r32 = load_address r31
    r33 = _PyObject_Vectorcall(r30, r32, 1, 0)
    keep_alive r27
    goto L11
L10:
L11:
    r34 = box(None, 1)
    return r34
[case testMatchSequenceWithStarPatternInTheMiddle_python3_10]
def f(x):
    match x:
        case ["start", *rest, "end"]:
            print("matched")
[out]
def f(x):
    x :: object
    r0 :: int32
    r1 :: bit
    r2 :: native_int
    r3, r4 :: bit
    r5 :: list
    r6 :: object
    r7 :: str
    r8 :: object
    r9 :: int32
    r10 :: bit
    r11 :: bool
    r12 :: native_int
    r13 :: list
    r14, r15 :: bit
    r16, r17, r18 :: int
    r19 :: object
    r20 :: str
    r21 :: object
    r22 :: int32
    r23 :: bit
    r24 :: bool
    r25 :: native_int
    r26 :: list
    r27, r28 :: bit
    r29, r30, r31 :: int
    r32, rest :: object
    r33 :: str
    r34 :: object
    r35 :: str
    r36 :: object
    r37 :: object[1]
    r38 :: object_ptr
    r39, r40 :: object
L0:
    r0 = PyList_Check(x)
    r1 = r0 != 0
    if r1 goto L1 else goto L14 :: bool
L1:
    r2 = PyObject_Size(x)
    r3 = r2 >= 0 :: signed
    r4 = r2 >= 2 :: signed
    if r4 goto L2 else goto L14 :: bool
L2:
    r5 = cast(list, x)
    r6 = CPyList_GetItem(r5, 0)
    r7 = 'start'
    r8 = PyObject_RichCompare(r6, r7, 2)
    r9 = PyObject_IsTrue(r8)
    r10 = r9 >= 0 :: signed
    r11 = truncate r9: int32 to builtins.bool
    if r11 goto L3 else goto L14 :: bool
L3:
    r12 = r2 - 1
    r13 = cast(list, x)
    r14 = r12 <= 4611686018427387903 :: signed
    if r14 goto L4 else goto L5 :: bool
L4:
    r15 = r12 >= -4611686018427387904 :: signed
    if r15 goto L6 else goto L5 :: bool
L5:
    r16 = CPyTagged_FromInt64(r12)
    r17 = r16
    goto L7
L6:
    r18 = r12 << 1
    r17 = r18
L7:
    r19 = CPyList_GetItem(r13, r17)
    r20 = 'end'
    r21 = PyObject_RichCompare(r19, r20, 2)
    r22 = PyObject_IsTrue(r21)
    r23 = r22 >= 0 :: signed
    r24 = truncate r22: int32 to builtins.bool
    if r24 goto L8 else goto L14 :: bool
L8:
    r25 = r2 - 1
    r26 = cast(list, x)
    r27 = r25 <= 4611686018427387903 :: signed
    if r27 goto L9 else goto L10 :: bool
L9:
    r28 = r25 >= -4611686018427387904 :: signed
    if r28 goto L11 else goto L10 :: bool
L10:
    r29 = CPyTagged_FromInt64(r25)
    r30 = r29
    goto L12
L11:
    r31 = r25 << 1
    r30 = r31
L12:
    r32 = CPyList_GetSlice(r26, 2, r30)
    rest = r32
L13:
    r33 = 'matched'
    r34 = builtins :: module
    r35 = 'print'
    r36 = CPyObject_GetAttr(r34, r35)
    r37 = [r33]
    r38 = load_address r37
    r39 = _PyObject_Vectorcall(r36, r38, 1, 0)
    keep_alive r33
    goto L15
L14:
L15:
    r40 = box(None, 1)
    return r40
[case testMatchSequenceWithStarPatternAtTheStart_python3_10]
def f(x):
    match x:
        case [*rest, 1, 2]:
            print("matched")
[out]
def f(x):
    x :: object
    r0 :: int32
    r1 :: bit
    r2 :: native_int
    r3, r4 :: bit
    r5 :: native_int
    r6 :: list
    r7, r8 :: bit
    r9, r10, r11 :: int
    r12, r13, r14 :: object
    r15 :: int32
    r16 :: bit
    r17 :: bool
    r18 :: native_int
    r19 :: list
    r20, r21 :: bit
    r22, r23, r24 :: int
    r25, r26, r27 :: object
    r28 :: int32
    r29 :: bit
    r30 :: bool
    r31 :: native_int
    r32 :: list
    r33, r34 :: bit
    r35, r36, r37 :: int
    r38, rest :: object
    r39 :: str
    r40 :: object
    r41 :: str
    r42 :: object
    r43 :: object[1]
    r44 :: object_ptr
    r45, r46 :: object
L0:
    r0 = PyList_Check(x)
    r1 = r0 != 0
    if r1 goto L1 else goto L18 :: bool
L1:
    r2 = PyObject_Size(x)
    r3 = r2 >= 0 :: signed
    r4 = r2 >= 2 :: signed
    if r4 goto L2 else goto L18 :: bool
L2:
    r5 = r2 - 2
    r6 = cast(list, x)
    r7 = r5 <= 4611686018427387903 :: signed
    if r7 goto L3 else goto L4 :: bool
L3:
    r8 = r5 >= -4611686018427387904 :: signed
    if r8 goto L5 else goto L4 :: bool
L4:
    r9 = CPyTagged_FromInt64(r5)
    r10 = r9
    goto L6
L5:
    r11 = r5 << 1
    r10 = r11
L6:
    r12 = CPyList_GetItem(r6, r10)
    r13 = object 1
    r14 = PyObject_RichCompare(r12, r13, 2)
    r15 = PyObject_IsTrue(r14)
    r16 = r15 >= 0 :: signed
    r17 = truncate r15: int32 to builtins.bool
    if r17 goto L7 else goto L18 :: bool
L7:
    r18 = r2 - 1
    r19 = cast(list, x)
    r20 = r18 <= 4611686018427387903 :: signed
    if r20 goto L8 else goto L9 :: bool
L8:
    r21 = r18 >= -4611686018427387904 :: signed
    if r21 goto L10 else goto L9 :: bool
L9:
    r22 = CPyTagged_FromInt64(r18)
    r23 = r22
    goto L11
L10:
    r24 = r18 << 1
    r23 = r24
L11:
    r25 = CPyList_GetItem(r19, r23)
    r26 = object 2
    r27 = PyObject_RichCompare(r25, r26, 2)
    r28 = PyObject_IsTrue(r27)
    r29 = r28 >= 0 :: signed
    r30 = truncate r28: int32 to builtins.bool
    if r30 goto L12 else goto L18 :: bool
L12:
    r31 = r2 - 2
    r32 = cast(list, x)
    r33 = r31 <= 4611686018427387903 :: signed
    if r33 goto L13 else goto L14 :: bool
L13:
    r34 = r31 >= -4611686018427387904 :: signed
    if r34 goto L15 else goto L14 :: bool
L14:
    r35 = CPyTagged_FromInt64(r31)
    r36 = r35
    goto L16
L15:
    r37 = r31 << 1
    r36 = r37
L16:
    r38 = CPyList_GetSlice(r32, 0, r36)
    rest = r38
L17:
    r39 = 'matched'
    r40 = builtins :: module
    r41 = 'print'
    r42 = CPyObject_GetAttr(r40, r41)
    r43 = [r39]
    r44 = load_address r43
    r45 = _PyObject_Vectorcall(r42, r44, 1, 0)
    keep_alive r39
    goto L19
L18:
L19:
    r46 = box(None, 1)
    return r46
[case testMatchBuiltinClassPattern_python3_10]
def f(x):
    match x:
        case int(y):
            print("matched")
[out]
def f(x):
    x, r0 :: object
    r1 :: int32
    r2 :: bit
    r3 :: bool
    r4, y :: int
    r5 :: str
    r6 :: object
    r7 :: str
    r8 :: object
    r9 :: object[1]
    r10 :: object_ptr
    r11, r12 :: object
L0:
    r0 = load_address PyLong_Type
    r1 = PyObject_IsInstance(x, r0)
    r2 = r1 >= 0 :: signed
    r3 = truncate r1: int32 to builtins.bool
    if r3 goto L1 else goto L3 :: bool
L1:
    r4 = unbox(int, x)
    y = r4
L2:
    r5 = 'matched'
    r6 = builtins :: module
    r7 = 'print'
    r8 = CPyObject_GetAttr(r6, r7)
    r9 = [r5]
    r10 = load_address r9
    r11 = _PyObject_Vectorcall(r8, r10, 1, 0)
    keep_alive r5
    goto L4
L3:
L4:
    r12 = box(None, 1)
    return r12
