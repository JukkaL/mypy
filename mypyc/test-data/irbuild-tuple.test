[case testTupleGet]
from typing import Tuple

def f(x: Tuple[Tuple[int, bool], bool]) -> int:
    return x[0][0]
[out]
def f(x):
    x :: tuple[tuple[int, bool], bool]
    r0 :: tuple[int, bool]
    r1 :: int
L0:
    r0 = x[0]
    r1 = r0[0]
    return r1

[case testTupleNew]
from typing import Tuple

def f() -> int:
    t = (True, 1)
    return t[1]
[out]
def f():
    r0, t :: tuple[bool, int]
    r1 :: int
L0:
    r0 = (1, 2)
    t = r0
    r1 = t[1]
    return r1

[case testTupleLen]
from typing import Tuple
def f(x: Tuple[bool, bool, int]) -> int:
    return len(x)
[out]
def f(x):
    x :: tuple[bool, bool, int]
L0:
    return 6

[case testSequenceTuple]
from typing import List
def f(x: List[bool]) -> bool:
    return tuple(x)[1]
[out]
def f(x):
    x :: list
    r0 :: tuple
    r1 :: object
    r2 :: bool
L0:
    r0 = PyList_AsTuple(x)
    r1 = CPySequenceTuple_GetItem(r0, 2)
    r2 = unbox(bool, r1)
    return r2

[case testSequenceTupleLen]
from typing import Tuple
def f(x: Tuple[int, ...]) -> int:
  return len(x)
[out]
def f(x):
    x :: tuple
    r0 :: ptr
    r1 :: native_int
    r2 :: short_int
L0:
    r0 = get_element_ptr x ob_size :: PyVarObject
    r1 = load_mem r0 :: native_int*
    keep_alive x
    r2 = r1 << 1
    return r2

[case testSequenceTupleForced]
from typing import Tuple
def f() -> int:
    t = (1, 2) # type: Tuple[int, ...]
    return t[1]
[out]
def f():
    r0 :: tuple[int, int]
    r1 :: object
    t :: tuple
    r2 :: object
    r3 :: int
L0:
    r0 = (2, 4)
    r1 = box(tuple[int, int], r0)
    t = r1
    r2 = CPySequenceTuple_GetItem(t, 2)
    r3 = unbox(int, r2)
    return r3

[case testTupleDisplay]
from typing import Sequence, Tuple
def f(x: Sequence[int], y: Sequence[int]) -> Tuple[int, ...]:
    return (1, 2, *x, *y, 3)
[out]
def f(x, y):
    x, y :: object
    r0 :: list
    r1, r2 :: object
    r3, r4, r5 :: ptr
    r6, r7, r8 :: object
    r9 :: int32
    r10 :: bit
    r11 :: tuple
L0:
    r0 = PyList_New(2)
    r1 = box(short_int, 2)
    r2 = box(short_int, 4)
    r3 = get_element_ptr r0 ob_item :: PyListObject
    r4 = load_mem r3 :: ptr*
    set_mem r4, r1 :: builtins.object*
    r5 = r4 + WORD_SIZE*1
    set_mem r5, r2 :: builtins.object*
    keep_alive r0
    r6 = CPyList_Extend(r0, x)
    r7 = CPyList_Extend(r0, y)
    r8 = box(short_int, 6)
    r9 = PyList_Append(r0, r8)
    r10 = r9 >= 0 :: signed
    r11 = PyList_AsTuple(r0)
    return r11

[case testTupleFor]
from typing import Tuple, List
def f(xs: Tuple[str, ...]) -> None:
    for x in xs:
        pass
[out]
def f(xs):
    xs :: tuple
    r0 :: short_int
    r1 :: ptr
    r2 :: native_int
    r3 :: short_int
    r4 :: bit
    r5 :: object
    r6, x :: str
    r7 :: short_int
L0:
    r0 = 0
L1:
    r1 = get_element_ptr xs ob_size :: PyVarObject
    r2 = load_mem r1 :: native_int*
    keep_alive xs
    r3 = r2 << 1
    r4 = r0 < r3 :: signed
    if r4 goto L2 else goto L4 :: bool
L2:
    r5 = CPySequenceTuple_GetItem(xs, r0)
    r6 = cast(str, r5)
    x = r6
L3:
    r7 = r0 + 2
    r0 = r7
    goto L1
L4:
    return 1

[case testNamedTupleAttribute]
from typing import NamedTuple

NT = NamedTuple('NT', [('x', int), ('y', int)])

def f(nt: NT, b: bool) -> int:
    if b:
        return nt.x
    return nt.y
[out]
def f(nt, b):
    nt :: tuple
    b :: bool
    r0 :: object
    r1 :: int
    r2 :: object
    r3 :: int
L0:
    if b goto L1 else goto L2 :: bool
L1:
    r0 = CPySequenceTuple_GetItem(nt, 0)
    r1 = unbox(int, r0)
    return r1
L2:
    r2 = CPySequenceTuple_GetItem(nt, 2)
    r3 = unbox(int, r2)
    return r3


[case testTupleOperatorIn]
def f(i: int) -> bool:
    return i in [1, 2, 3]
[out]
def f(i):
    i :: int
    r0, r1 :: object
    r2 :: bit
    r3 :: object
    r4 :: int32
    r5 :: bit
    r6, r7, r8 :: bool
    r9 :: native_int
    r10, r11 :: bit
    r12 :: bool
    r13 :: bit
    r14 :: object
    r15, r16 :: bool
    r17, r18 :: object
    r19 :: bit
    r20 :: object
    r21 :: int32
    r22 :: bit
    r23, r24, r25 :: bool
    r26 :: native_int
    r27, r28 :: bit
    r29 :: bool
    r30 :: bit
    r31 :: object
    r32, r33 :: bool
    r34, r35 :: object
    r36 :: bit
    r37 :: object
    r38 :: int32
    r39 :: bit
    r40, r41, r42 :: bool
    r43 :: native_int
    r44, r45 :: bit
    r46 :: bool
    r47 :: bit
    r48 :: object
    r49 :: bool
L0:
    r0 = box(int, i)
    r1 = box(short_int, 2)
    r2 = r0 == r1
    r3 = box(bit, r2)
    r4 = PyObject_IsTrue(r3)
    r5 = r4 >= 0 :: signed
    r6 = truncate r4: int32 to builtins.bool
    if r6 goto L1 else goto L2 :: bool
L1:
    r7 = unbox(bool, r3)
    r8 = r7
    goto L6
L2:
    r9 = i & 1
    r10 = r9 == 0
    if r10 goto L3 else goto L4 :: bool
L3:
    r11 = i == 2
    r12 = r11
    goto L5
L4:
    r13 = CPyTagged_IsEq_(i, 2)
    r12 = r13
L5:
    r14 = box(bool, r12)
    r15 = unbox(bool, r14)
    r8 = r15
L6:
    if r8 goto L7 else goto L8 :: bool
L7:
    r16 = r8
    goto L15
L8:
    r17 = box(int, i)
    r18 = box(short_int, 4)
    r19 = r17 == r18
    r20 = box(bit, r19)
    r21 = PyObject_IsTrue(r20)
    r22 = r21 >= 0 :: signed
    r23 = truncate r21: int32 to builtins.bool
    if r23 goto L9 else goto L10 :: bool
L9:
    r24 = unbox(bool, r20)
    r25 = r24
    goto L14
L10:
    r26 = i & 1
    r27 = r26 == 0
    if r27 goto L11 else goto L12 :: bool
L11:
    r28 = i == 4
    r29 = r28
    goto L13
L12:
    r30 = CPyTagged_IsEq_(i, 4)
    r29 = r30
L13:
    r31 = box(bool, r29)
    r32 = unbox(bool, r31)
    r25 = r32
L14:
    r16 = r25
L15:
    if r16 goto L16 else goto L17 :: bool
L16:
    r33 = r16
    goto L24
L17:
    r34 = box(int, i)
    r35 = box(short_int, 6)
    r36 = r34 == r35
    r37 = box(bit, r36)
    r38 = PyObject_IsTrue(r37)
    r39 = r38 >= 0 :: signed
    r40 = truncate r38: int32 to builtins.bool
    if r40 goto L18 else goto L19 :: bool
L18:
    r41 = unbox(bool, r37)
    r42 = r41
    goto L23
L19:
    r43 = i & 1
    r44 = r43 == 0
    if r44 goto L20 else goto L21 :: bool
L20:
    r45 = i == 6
    r46 = r45
    goto L22
L21:
    r47 = CPyTagged_IsEq_(i, 6)
    r46 = r47
L22:
    r48 = box(bool, r46)
    r49 = unbox(bool, r48)
    r42 = r49
L23:
    r33 = r42
L24:
    return r33

[case testTupleBuiltFromList]
def f(val: int) -> bool:
    return val % 2 == 0

def test() -> None:
    source = [1, 2, 3]
    a = tuple(f(x) for x in source)
[out]
def f(val):
    val, r0 :: int
    r1 :: native_int
    r2, r3 :: bit
    r4 :: bool
    r5 :: bit
L0:
    r0 = CPyTagged_Remainder(val, 4)
    r1 = r0 & 1
    r2 = r1 == 0
    if r2 goto L1 else goto L2 :: bool
L1:
    r3 = r0 == 0
    r4 = r3
    goto L3
L2:
    r5 = CPyTagged_IsEq_(r0, 0)
    r4 = r5
L3:
    return r4
def test():
    r0 :: list
    r1, r2, r3 :: object
    r4, r5, r6, r7 :: ptr
    source :: list
    r8 :: ptr
    r9 :: native_int
    r10 :: tuple
    r11 :: short_int
    r12 :: ptr
    r13 :: native_int
    r14 :: short_int
    r15 :: bit
    r16 :: object
    r17, x :: int
    r18 :: bool
    r19 :: object
    r20 :: bit
    r21 :: short_int
    a :: tuple
L0:
    r0 = PyList_New(3)
    r1 = box(short_int, 2)
    r2 = box(short_int, 4)
    r3 = box(short_int, 6)
    r4 = get_element_ptr r0 ob_item :: PyListObject
    r5 = load_mem r4 :: ptr*
    set_mem r5, r1 :: builtins.object*
    r6 = r5 + WORD_SIZE*1
    set_mem r6, r2 :: builtins.object*
    r7 = r5 + WORD_SIZE*2
    set_mem r7, r3 :: builtins.object*
    keep_alive r0
    source = r0
    r8 = get_element_ptr source ob_size :: PyVarObject
    r9 = load_mem r8 :: native_int*
    keep_alive source
    r10 = PyTuple_New(r9)
    r11 = 0
L1:
    r12 = get_element_ptr source ob_size :: PyVarObject
    r13 = load_mem r12 :: native_int*
    keep_alive source
    r14 = r13 << 1
    r15 = r11 < r14 :: signed
    if r15 goto L2 else goto L4 :: bool
L2:
    r16 = CPyList_GetItemUnsafe(source, r11)
    r17 = unbox(int, r16)
    x = r17
    r18 = f(x)
    r19 = box(bool, r18)
    r20 = CPySequenceTuple_SetItemUnsafe(r10, r11, r19)
L3:
    r21 = r11 + 2
    r11 = r21
    goto L1
L4:
    a = r10
    return 1


[case testTupleBuiltFromList2]
def f2(val: str) -> str:
    return val + "f2"

def test() -> None:
    source = ["a", "b", "c"]
    a = tuple(f2(x) for x in source)
    print(a)
[out]
def f2(val):
    val, r0, r1 :: str
L0:
    r0 = 'f2'
    r1 = PyUnicode_Concat(val, r0)
    return r1
def test():
    r0, r1, r2 :: str
    r3 :: list
    r4, r5, r6, r7 :: ptr
    source :: list
    r8 :: ptr
    r9 :: native_int
    r10 :: tuple
    r11 :: short_int
    r12 :: ptr
    r13 :: native_int
    r14 :: short_int
    r15 :: bit
    r16 :: object
    r17, x, r18 :: str
    r19 :: bit
    r20 :: short_int
    a :: tuple
    r21 :: object
    r22 :: str
    r23, r24 :: object
L0:
    r0 = 'a'
    r1 = 'b'
    r2 = 'c'
    r3 = PyList_New(3)
    r4 = get_element_ptr r3 ob_item :: PyListObject
    r5 = load_mem r4 :: ptr*
    set_mem r5, r0 :: builtins.object*
    r6 = r5 + WORD_SIZE*1
    set_mem r6, r1 :: builtins.object*
    r7 = r5 + WORD_SIZE*2
    set_mem r7, r2 :: builtins.object*
    keep_alive r3
    source = r3
    r8 = get_element_ptr source ob_size :: PyVarObject
    r9 = load_mem r8 :: native_int*
    keep_alive source
    r10 = PyTuple_New(r9)
    r11 = 0
L1:
    r12 = get_element_ptr source ob_size :: PyVarObject
    r13 = load_mem r12 :: native_int*
    keep_alive source
    r14 = r13 << 1
    r15 = r11 < r14 :: signed
    if r15 goto L2 else goto L4 :: bool
L2:
    r16 = CPyList_GetItemUnsafe(source, r11)
    r17 = cast(str, r16)
    x = r17
    r18 = f2(x)
    r19 = CPySequenceTuple_SetItemUnsafe(r10, r11, r18)
L3:
    r20 = r11 + 2
    r11 = r20
    goto L1
L4:
    a = r10
    r21 = builtins :: module
    r22 = 'print'
    r23 = CPyObject_GetAttr(r21, r22)
    r24 = PyObject_CallFunctionObjArgs(r23, a, 0)
    return 1


[case testTupleBuiltFromVariableLengthTuple]
from typing import Tuple

def f(val: bool) -> bool:
    return not val

def test(source: Tuple[bool, ...]) -> None:
    a = tuple(f(x) for x in source)
[out]
def f(val):
    val, r0 :: bool
L0:
    r0 = val ^ 1
    return r0
def test(source):
    source :: tuple
    r0 :: ptr
    r1 :: native_int
    r2 :: tuple
    r3 :: short_int
    r4 :: ptr
    r5 :: native_int
    r6 :: short_int
    r7 :: bit
    r8 :: object
    r9, x, r10 :: bool
    r11 :: object
    r12 :: bit
    r13 :: short_int
    a :: tuple
L0:
    r0 = get_element_ptr source ob_size :: PyVarObject
    r1 = load_mem r0 :: native_int*
    keep_alive source
    r2 = PyTuple_New(r1)
    r3 = 0
L1:
    r4 = get_element_ptr source ob_size :: PyVarObject
    r5 = load_mem r4 :: native_int*
    keep_alive source
    r6 = r5 << 1
    r7 = r3 < r6 :: signed
    if r7 goto L2 else goto L4 :: bool
L2:
    r8 = CPySequenceTuple_GetItem(source, r3)
    r9 = unbox(bool, r8)
    x = r9
    r10 = f(x)
    r11 = box(bool, r10)
    r12 = CPySequenceTuple_SetItemUnsafe(r2, r3, r11)
L3:
    r13 = r3 + 2
    r3 = r13
    goto L1
L4:
    a = r2
    return 1
