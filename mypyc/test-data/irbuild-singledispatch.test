[case testNativeCallsUsedInDispatchFunction]
from functools import singledispatch
@singledispatch
def f(arg) -> bool:
    return False

@f.register
def g(arg: int) -> bool:
    return True
[out]
def __mypyc_singledispatch_main_function_f__(arg):
    arg :: object
L0:
    return 0
def f_obj.__init__(__mypyc_self__):
    __mypyc_self__ :: __main__.f_obj
    r0 :: dict
    r1 :: bool
    r2 :: dict
    r3 :: str
    r4 :: int32
    r5 :: bit
L0:
    r0 = PyDict_New()
    __mypyc_self__.registry = r0; r1 = is_error
    r2 = PyDict_New()
    r3 = 'dispatch_cache'
    r4 = PyObject_SetAttr(__mypyc_self__, r3, r2)
    r5 = r4 >= 0 :: signed
    return 1
def f_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    return r2
def f_obj.register(__mypyc_self__, cls, func):
    __mypyc_self__ :: __main__.f_obj
    cls, func, r0 :: object
L0:
    r0 = CPySingledispatch_RegisterFunction(__mypyc_self__, cls, func)
    return r0
def f_obj.__call__(__mypyc_self__, arg):
    __mypyc_self__ :: __main__.f_obj
    arg :: object
    r0 :: dict
    r1 :: str
    r2 :: object
    r3 :: str
    r4 :: object
    r5 :: ptr
    r6 :: object
    r7 :: str
    r8 :: object
    r9 :: int32
    r10 :: bit
    r11 :: bool
    r12 :: dict
    r13, r14, r15 :: object
    r16 :: str
    r17, r18 :: object
    r19 :: dict
    r20 :: int32
    r21 :: bit
    r22 :: object
    r23 :: ptr
    r24 :: object
    r25 :: bit
    r26 :: int
    r27 :: bit
    r28 :: int
    r29 :: bool
    r30 :: object
    r31 :: bool
L0:
    r0 = __main__.globals :: static
    r1 = 'f'
    r2 = CPyDict_GetItem(r0, r1)
    r3 = 'registry'
    r4 = CPyObject_GetAttr(r2, r3)
    r5 = get_element_ptr arg ob_type :: PyObject
    r6 = load_mem r5 :: builtins.object*
    keep_alive arg
    r7 = 'dispatch_cache'
    r8 = CPyObject_GetAttr(r2, r7)
    r9 = PySequence_Contains(r8, r6)
    r10 = r9 >= 0 :: signed
    r11 = truncate r9: int32 to builtins.bool
    if r11 goto L1 else goto L2 :: bool
L1:
    r12 = cast(dict, r8)
    r13 = CPyDict_GetItem(r12, r6)
    r14 = r13
    goto L3
L2:
    r15 = functools :: module
    r16 = '_find_impl'
    r17 = CPyObject_GetAttr(r15, r16)
    r18 = PyObject_CallFunctionObjArgs(r17, r6, r4, 0)
    r19 = cast(dict, r8)
    r20 = CPyDict_SetItem(r19, r6, r18)
    r21 = r20 >= 0 :: signed
    r14 = r18
L3:
    r22 = load_address PyLong_Type
    r23 = get_element_ptr r14 ob_type :: PyObject
    r24 = load_mem r23 :: builtins.object*
    keep_alive r14
    r25 = r24 == r22
    if r25 goto L4 else goto L7 :: bool
L4:
    r26 = unbox(int, r14)
    r27 = r26 == 0
    if r27 goto L5 else goto L6 :: bool
L5:
    r28 = unbox(int, arg)
    r29 = g(r28)
    return r29
L6:
    unreachable
L7:
    r30 = PyObject_CallFunctionObjArgs(r14, arg, 0)
    r31 = unbox(bool, r30)
    return r31
def g(arg):
    arg :: int
L0:
    return 1

