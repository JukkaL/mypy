--
-- Check to see how we handle raw types, error handling, and other
-- semantic analysis shenanigans
--

[case testLiteralInvalidString1]
from typing_extensions import Literal
def f(x: 'A[') -> None: pass  # E: Invalid type. Try using Literal['A['] instead?
def g(x: Literal['A[']) -> None: pass
reveal_type(g)  # E: Revealed type is 'def (x: Literal['A['])'
[out]

[case testLiteralInvalidString2]
from typing_extensions import Literal
def f(x: 'A B') -> None: pass  # E: Invalid type. Try using Literal['A B'] instead?
def g(x: Literal['A B']) -> None: pass
reveal_type(g)  # E: Revealed type is 'def (x: Literal['A B'])'
[out]

[case testLiteralInvalidTypeComment]
from typing_extensions import Literal
def f(x):  # E: syntax error in type comment
    # type: (A[) -> None
    pass

[case testLiteralInvalidTypeComment2]
from typing_extensions import Literal
def f(x):  # E: Invalid type. Try using Literal['A['] instead?
    # type: ("A[") -> None
    pass

def g(x):
    # type: (Literal["A["]) -> None
    pass
[out]

[case testLiteralParsingPython2]
# flags: --python-version 2.7
from typing import Optional
from typing_extensions import Literal

def f(x):  # E: Invalid type. Try using Literal['A['] instead?
    # type: ("A[") -> None
    pass

def g(x):
    # type: (Literal["A["]) -> None
    pass

x = None  # type: Optional[1]   # E: Invalid type. Try using Literal[1] instead?
y = None  # type: Optional[Literal[1]]
[out]

[case testLiteralInsideOtherTypes]
from typing import Tuple
from typing_extensions import Literal

x: Tuple[1]                         # E: Invalid type. Try using Literal[1] instead?
def foo(x: Tuple[1]) -> None: ...   # E: Invalid type. Try using Literal[1] instead?

y: Tuple[Literal[2]]
def bar(x: Tuple[Literal[2]]) -> None: ...
reveal_type(y)                      # E: Revealed type is 'Tuple[Literal[2]]'
reveal_type(bar)                    # E: Revealed type is 'def (x: Tuple[Literal[2]])'
[out]

[case testLiteralInsideOtherTypesPython2]
# flags: --python-version 2.7
from typing import Tuple, Optional
from typing_extensions import Literal

x = None  # type: Optional[Tuple[1]]  # E: Invalid type. Try using Literal[1] instead?
def foo(x):                           # E: Invalid type. Try using Literal[1] instead?
    # type: (Tuple[1]) -> None
    pass

y = None  # type: Optional[Tuple[Literal[2]]]
def bar(x):
    # type: (Tuple[Literal[2]]) -> None
    pass
reveal_type(y)                      # E: Revealed type is 'Union[Tuple[Literal[2]], None]'
reveal_type(bar)                    # E: Revealed type is 'def (x: Tuple[Literal[2]])'
[out]

[case testLiteralInsideOtherTypesTypeCommentsPython3]
# flags: --python-version 3.7
from typing import Tuple, Optional
from typing_extensions import Literal

x = None  # type: Optional[Tuple[1]]  # E: Invalid type. Try using Literal[1] instead?
def foo(x):                           # E: Invalid type. Try using Literal[1] instead?
    # type: (Tuple[1]) -> None
    pass

y = None  # type: Optional[Tuple[Literal[2]]]
def bar(x):
    # type: (Tuple[Literal[2]]) -> None
    pass
reveal_type(y)                      # E: Revealed type is 'Union[Tuple[Literal[2]], None]'
reveal_type(bar)                    # E: Revealed type is 'def (x: Tuple[Literal[2]])'
[out]


--
-- Check to make sure we can construct the correct range of literal
-- types (and correctly reject invalid literal types)
--
-- Note: the assignment tests exercise the logic in 'fastparse.py';
-- the type alias tests exercise the logic in 'exprtotype.py'.
--

[case testLiteralBasicIntUsage]
from typing_extensions import Literal

a: Literal[4]
b: Literal[0x2a]
c: Literal[-300]

reveal_type(a)  # E: Revealed type is 'Literal[4]'
reveal_type(b)  # E: Revealed type is 'Literal[42]'
reveal_type(c)  # E: Revealed type is 'Literal[-300]'
[out]

[case testLiteralBasicIntUsageTypeAlias]
from typing_extensions import Literal

at = Literal[4]
bt = Literal[0x2a]
ct = Literal[-300]
a: at
b: bt
c: ct

reveal_type(a)  # E: Revealed type is 'Literal[4]'
reveal_type(b)  # E: Revealed type is 'Literal[42]'
reveal_type(c)  # E: Revealed type is 'Literal[-300]'
[out]

[case testLiteralBasicBoolUsage]
from typing_extensions import Literal

a: Literal[True]
b: Literal[False]

reveal_type(a)  # E: Revealed type is 'Literal[True]'
reveal_type(b)  # E: Revealed type is 'Literal[False]'
[builtins fixtures/bool.pyi]
[out]

[case testLiteralBasicBoolUsageTypeAlias]
from typing_extensions import Literal

at = Literal[True]
bt = Literal[False]
a: at
b: bt

reveal_type(a)  # E: Revealed type is 'Literal[True]'
reveal_type(b)  # E: Revealed type is 'Literal[False]'
[builtins fixtures/bool.pyi]
[out]

[case testLiteralBasicStrUsage]
from typing_extensions import Literal

a: Literal[""]
b: Literal[r"foo\nbar"]
c: Literal["foo\nbar"]
d: Literal["  foo bar  "]
e: Literal['  foo bar  ']

reveal_type(a)  # E: Revealed type is 'Literal['']'
reveal_type(b)  # E: Revealed type is 'Literal['foo\\nbar']'
reveal_type(c)  # E: Revealed type is 'Literal['foo\nbar']'
reveal_type(d)  # E: Revealed type is 'Literal['  foo bar  ']'
reveal_type(e)  # E: Revealed type is 'Literal['  foo bar  ']'
[out]

[case testLiteralBasicNoneUsage]
from typing_extensions import Literal
a: Literal[None]
reveal_type(a)   # E: Revealed type is 'None'
# Note: Literal[None] and None are equivalent
[out]

[case testLiteralDisallowAny]
from typing import Any
from typing_extensions import Literal
from missing_module import BadAlias     # E: Cannot find module named 'missing_module' \
                                        # N: (Perhaps setting MYPYPATH or using the "--ignore-missing-imports" flag would help)

a: Literal[Any]                         # E: Parameter 1 of Literal[...] is of type Any
b: Literal[BadAlias]                    # E: Parameter 1 of Literal[...] is of type Any
[out]

[case testLiteralDisallowFloats]
from typing_extensions import Literal
a: Literal[3.14]  # E: invalid type comment or annotation
b: 3.14           # E: invalid type comment or annotation
[out]

[case testLiteralDisallowFloatsTypeAlias]
from typing_extensions import Literal
at = Literal[3.14]  # E: Invalid type alias \
                    # E: The type "Type[Literal]" is not generic and not indexable
bt = 3.14

a: at               # E: Invalid type "__main__.at"
b: bt               # E: Invalid type "__main__.bt"
[out]

[case testLiteralDisallowComplexNumbers]
from typing_extensions import Literal
a: Literal[3j]       # E: invalid type comment or annotation
b: Literal[3j + 2]   # E: invalid type comment or annotation
c: 3j                # E: invalid type comment or annotation
d: 3j + 2            # E: invalid type comment or annotation
[out]

[case testLiteralDisallowComplexNumbersTypeAlias]
from typing_extensions import Literal
at = Literal[3j]        # E: Invalid type alias \
                        # E: The type "Type[Literal]" is not generic and not indexable
a: at                   # E: Invalid type "__main__.at"
[builtins fixtures/complex.pyi]
[out]

[case testLiteralDisallowComplexExpressions]
from typing_extensions import Literal
a: Literal[3 + 4]               # E: invalid type comment or annotation
b: Literal["  foo  ".trim()]    # E: invalid type comment or annotation
c: Literal[+42]                 # E: invalid type comment or annotation
d: Literal[~12]                 # E: invalid type comment or annotation
[out]

[case testLiteralDisallowCollections]
from typing_extensions import Literal
a: Literal[{"a": 1, "b": 2}]    # E: invalid type comment or annotation
b: literal[{1, 2, 3}]           # E: invalid type comment or annotation
c: {"a": 1, "b": 2}             # E: invalid type comment or annotation
d: {1, 2, 3}                    # E: invalid type comment or annotation
[out]

[case testLiteralDisallowCollections2]
from typing_extensions import Literal
a: (1, 2, 3)                    # E: Syntax error in type annotation \
                                # N: Suggestion: Use Tuple[T1, ..., Tn] instead of (T1, ..., Tn)
b: Literal[[1, 2, 3]]           # E: Parameter 1 of Literal[...] is invalid
c: [1, 2, 3]                    # E: Invalid type
[out]

[case testLiteralDisallowCollectionsTypeAlias]
from typing_extensions import Literal
at = Literal[{"a": 1, "b": 2}]  # E: Invalid type alias \
                                # E: The type "Type[Literal]" is not generic and not indexable
bt = {"a": 1, "b": 2}
a: at                           # E: Invalid type "__main__.at"
b: bt                           # E: Invalid type "__main__.bt"
[builtins fixtures/dict.pyi]
[out]

[case testLiteralDisallowCollectionsTypeAlias2]
from typing_extensions import Literal
at = Literal[{1, 2, 3}]         # E: Invalid type alias \
                                # E: The type "Type[Literal]" is not generic and not indexable
bt = {1, 2, 3}
a: at                           # E: Invalid type "__main__.at"
b: bt                           # E: Invalid type "__main__.bt"
[builtins fixtures/set.pyi]
[out]


--
-- Test mixing and matching literals with other types
--

[case testLiteralMultipleValues]
# flags: --strict-optional
from typing_extensions import Literal
a: Literal[1, 2, 3]
b: Literal["a", "b", "c"]
c: Literal[1, "b", True, None]
d: Literal[1, 1, 1]
e: Literal[None, None, None]
reveal_type(a)   # E: Revealed type is 'Union[Literal[1], Literal[2], Literal[3]]'
reveal_type(b)   # E: Revealed type is 'Union[Literal['a'], Literal['b'], Literal['c']]'
reveal_type(c)   # E: Revealed type is 'Union[Literal[1], Literal['b'], Literal[True], None]'
reveal_type(d)   # E: Revealed type is 'Literal[1]'
reveal_type(e)   # E: Revealed type is 'None'
[builtins fixtures/bool.pyi]
[out]

[case testLiteralMultipleValuesExplicitTuple]
from typing_extensions import Literal
# Unfortunately, it seems like typed_ast is unable to distinguish this from
# Literal[1, 2, 3]. So we treat the two as being equivalent for now.
a: Literal[1, 2, 3]
b: Literal[(1, 2, 3)]
reveal_type(a)  # E: Revealed type is 'Union[Literal[1], Literal[2], Literal[3]]'
reveal_type(b)  # E: Revealed type is 'Union[Literal[1], Literal[2], Literal[3]]'
[out]

[case testLiteralNestedUsage]
# flags: --strict-optional

# Note: the initial plan was to keep this kind of behavior provisional
# and decide whether we want to include this in the PEP at a later date.
# However, implementing this ended up being easier then expected (it required
# only a few trivial tweaks to typeanal.py), so maybe we should just go ahead
# and make it non-provisional now?
#
# TODO: make a decision here

from typing_extensions import Literal
a: Literal[Literal[3], 4, Literal["foo"]]
reveal_type(a)  # E: Revealed type is 'Union[Literal[3], Literal[4], Literal['foo']]'

alias_for_literal = Literal[5]
b: Literal[alias_for_literal]
reveal_type(b)  # E: Revealed type is 'Literal[5]'

another_alias = Literal[1, None]
c: Literal[alias_for_literal, another_alias, "r"]
reveal_type(c)  # E: Revealed type is 'Union[Literal[5], Literal[1], None, Literal['r']]'

basic_mode = Literal["r", "w", "a"]
basic_with_plus = Literal["r+", "w+", "a+"]
combined: Literal[basic_mode, basic_with_plus]
reveal_type(combined)  # E: Revealed type is 'Union[Literal['r'], Literal['w'], Literal['a'], Literal['r+'], Literal['w+'], Literal['a+']]'
[out]

[case testLiteralBiasTowardsAssumingForwardReference]
from typing_extensions import Literal

a: "Foo"
reveal_type(a)      # E: Revealed type is '__main__.Foo'

b: Literal["Foo"]
reveal_type(b)      # E: Revealed type is 'Literal['Foo']'

c: "Literal[Foo]"   # E: Parameter 1 of Literal[...] is invalid

d: "Literal['Foo']"
reveal_type(d)      # E: Revealed type is 'Literal['Foo']'

class Foo: pass
[out]

[case testLiteralBiasTowardsAssumingForwardReferenceForTypeAliases-skip]
from typing_extensions import Literal
# TODO: Currently, this test case causes a crash. Fix the crash then re-enable.
# (We currently aren't handling forward references + type aliases very gracefully,
# if at all.)

a: "Foo"
reveal_type(a)      # E: Revealed type is 'Literal[5]'

b: Literal["Foo"]
reveal_type(b)      # E: Revealed type is 'Literal['Foo']'

c: "Literal[Foo]"
reveal_type(c)      # E: Revealed type is 'Literal[5]'

d: "Literal['Foo']"
reveal_type(d)      # E: Revealed type is 'Literal['Foo']'

e: Literal[Foo, 'Foo']
reveal_type(e)      # E: Revealed type is 'Union[Literal[5], Literal['Foo']]'

Foo = Literal[5]
[out]

[case testLiteralBiasTowardsAssumingForwardReferencesForTypeComments]
from typing_extensions import Literal

a = None  # type: Foo
reveal_type(a)      # E: Revealed type is '__main__.Foo'

b = None  # type: "Foo"
reveal_type(b)      # E: Revealed type is '__main__.Foo'

c = None  # type: Literal["Foo"]
reveal_type(c)      # E: Revealed type is 'Literal['Foo']'

d = None  # type: Literal[Foo]   # E: Parameter 1 of Literal[...] is invalid

class Foo: pass
[out]


--
-- Check how we handle very basic subtyping and other useful things
--

[case testLiteralCallingFunction]
from typing_extensions import Literal
def foo(x: Literal[3]) -> None: pass

a: Literal[1]
b: Literal[2]
c: int

foo(a)  # E: Argument 1 to "foo" has incompatible type "Literal[1]"; expected "Literal[3]"
foo(b)  # E: Argument 1 to "foo" has incompatible type "Literal[2]"; expected "Literal[3]"
foo(c)  # E: Argument 1 to "foo" has incompatible type "int"; expected "Literal[3]"
[out]

[case testLiteralCallingFunctionWithUnionLiteral]
from typing_extensions import Literal
def foo(x: Literal[1, 2, 3]) -> None: pass

a: Literal[1]
b: Literal[2, 3]
c: Literal[4, 5]
d: int

foo(a)
foo(b)
foo(c)  # E: Argument 1 to "foo" has incompatible type "Union[Literal[4], Literal[5]]"; expected "Union[Literal[1], Literal[2], Literal[3]]"
foo(d)  # E: Argument 1 to "foo" has incompatible type "int"; expected "Union[Literal[1], Literal[2], Literal[3]]"
[out]

[case testLiteralCallingFunctionWithStandardBase]
from typing_extensions import Literal
def foo(x: int) -> None: pass

a: Literal[1]
b: Literal[1, -4]
c: Literal[4, 'foo']

foo(a)
foo(b)
foo(c)  # E: Argument 1 to "foo" has incompatible type "Union[Literal[4], Literal['foo']]"; expected "int"
[out]

[case testLiteralCallingOverloadedFunction]
from typing import overload, Generic, TypeVar, Any
from typing_extensions import Literal

T = TypeVar('T')
class IOLike(Generic[T]): pass

@overload
def foo(x: Literal[1]) -> IOLike[int]: ...
@overload
def foo(x: Literal[2]) -> IOLike[str]: ...
@overload
def foo(x: int) -> IOLike[Any]: ...
def foo(x: int) -> IOLike[Any]:
    if x == 1:
        return IOLike[int]()
    elif x == 2:
        return IOLike[str]()
    else:
        return IOLike()

a: Literal[1]
b: Literal[2]
c: int
d: Literal[3]

reveal_type(foo(a))  # E: Revealed type is '__main__.IOLike[builtins.int]'
reveal_type(foo(b))  # E: Revealed type is '__main__.IOLike[builtins.str]'
reveal_type(foo(c))  # E: Revealed type is '__main__.IOLike[Any]'
foo(d)
[builtins fixtures/ops.pyi]
[out]


--
-- Here are a few misc tests that deliberately do not work.
-- I'm including these as skipped tests partly because I wanted to
-- clarify the scope of what this diff did and did not do, and
-- partly because I already wrote these and would like to avoid having
-- to rewrite them in the future.
--

[case testLiteralInheritedMethodsInteractCorrectly-skip]
# TODO: fix this test. The method calls are not using the fallbacks.
from typing_extensions import Literal

a: Literal[3]
b: int
c: Literal['foo']

reveal_type(a + a)  # E: Revealed type is 'builtins.int'
reveal_type(a + b)  # E: Revealed type is 'builtins.int'
reveal_type(b + a)  # E: Revealed type is 'builtins.int'
reveal_type(c.strip())  # E: Revealed type is 'builtins.str'
[out]

[case testLiteralActualAssignment-skip]
# TODO: fix this test. The 1 is currently always given a type of 'int'
from typing_extensions import Literal

a: Literal[1] = 1
[out]
