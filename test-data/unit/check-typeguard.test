[case testTypeGuardBasic]
from typing_extensions import TypeGuard
class Point: pass
def is_point(a: object) -> TypeGuard[Point]: pass
def main(a: object) -> None:
    if is_point(a):
        reveal_type(a)  # N: Revealed type is '__main__.Point'
    else:
        reveal_type(a)  # N: Revealed type is 'builtins.object'
[builtins fixtures/tuple.pyi]

[case testTypeGuardTypeArgsNone]
from typing_extensions import TypeGuard
def foo(a: object) -> TypeGuard:  # E: TypeGuard must have exactly one type argument
    pass
[builtins fixtures/tuple.pyi]

[case testTypeGuardTypeArgsTooMany]
from typing_extensions import TypeGuard
def foo(a: object) -> TypeGuard[int, int]:  # E: TypeGuard must have exactly one type argument
    pass
[builtins fixtures/tuple.pyi]

[case testTypeGuardTypeArgType]
from typing_extensions import TypeGuard
def foo(a: object) -> TypeGuard[42]:  # E: Invalid type: try using Literal[42] instead?
    pass
[builtins fixtures/tuple.pyi]

[case testTypeGuardRepr]
from typing_extensions import TypeGuard
def foo(a: object) -> TypeGuard[int]:
    pass
reveal_type(foo)  # N: Revealed type is 'def (a: builtins.object) -> TypeGuard[builtins.int]'
[builtins fixtures/tuple.pyi]

[case testTypeGuardCallArgsNone]
from typing_extensions import TypeGuard
class Point: pass
# TODO: error on the 'def' line (insufficient args for type guard)
def is_point() -> TypeGuard[Point]: pass
def main(a: object) -> None:
    if is_point():
        reveal_type(a)  # N: Revealed type is 'builtins.object'
[builtins fixtures/tuple.pyi]

[case testTypeGuardCallArgsMultiple]
from typing_extensions import TypeGuard
class Point: pass
def is_point(a: object, b: object) -> TypeGuard[Point]: pass
def main(a: object, b: object) -> None:
    if is_point(a, b):
        reveal_type(a)  # N: Revealed type is '__main__.Point'
        reveal_type(b)  # N: Revealed type is 'builtins.object'
[builtins fixtures/tuple.pyi]

[case testTypeGuardIsBool]
from typing_extensions import TypeGuard
def f(a: TypeGuard[int]) -> None: pass
reveal_type(f)  # N: Revealed type is 'def (a: builtins.bool)'
a: TypeGuard[int]
reveal_type(a)  # N: Revealed type is 'builtins.bool'
class C:
    a: TypeGuard[int]
reveal_type(C().a)  # N: Revealed type is 'builtins.bool'
[builtins fixtures/tuple.pyi]

[case testTypeGuardWithTypeVar]
from typing import TypeVar, Tuple
from typing_extensions import TypeGuard
T = TypeVar('T')
def is_two_element_tuple(a: Tuple[T, ...]) -> TypeGuard[Tuple[T, T]]: pass
def main(a: Tuple[T, ...]):
    if is_two_element_tuple(a):
        reveal_type(a)  # N: Revealed type is 'Tuple[T`-1, T`-1]'
[builtins fixtures/tuple.pyi]

[case testTypeGuardNonOverlapping]
from typing import List
from typing_extensions import TypeGuard
def is_str_list(a: List[object]) -> TypeGuard[List[str]]: pass
def main(a: List[object]):
    if is_str_list(a):
        reveal_type(a)  # N: Revealed type is 'builtins.list[builtins.str]'
[builtins fixtures/tuple.pyi]

[case testTypeGuardUnionIn]
from typing import Union
from typing_extensions import TypeGuard
def is_foo(a: Union[int, str]) -> TypeGuard[str]: pass
def main(a: Union[str, int]) -> None:
    if is_foo(a):
        reveal_type(a)  # N: Revealed type is 'builtins.str'
[builtins fixtures/tuple.pyi]

[case testTypeGuardUnionOut]
from typing import Union
from typing_extensions import TypeGuard
def is_foo(a: object) -> TypeGuard[Union[int, str]]: pass
def main(a: object) -> None:
    if is_foo(a):
        reveal_type(a)  # N: Revealed type is 'Union[builtins.int, builtins.str]'
[builtins fixtures/tuple.pyi]

[case testTypeGuardNonzeroFloat]
from typing_extensions import TypeGuard
def is_nonzero(a: object) -> TypeGuard[float]: pass
def main(a: int):
    if is_nonzero(a):
        reveal_type(a)  # N: Revealed type is 'builtins.float'
[builtins fixtures/tuple.pyi]

[case testTypeGuardHigherOrder]
from typing import Callable, TypeVar, Iterable, List
from typing_extensions import TypeGuard
T = TypeVar('T')
R = TypeVar('R')
def filter(f: Callable[[T], TypeGuard[R]], it: Iterable[T]) -> Iterable[R]: pass
def is_float(a: object) -> TypeGuard[float]: pass
a: List[object] = ["a", 0, 0.0]
b = filter(is_float, a)
reveal_type(b)  # N: Revealed type is 'typing.Iterable[builtins.float*]'
[builtins fixtures/tuple.pyi]

[case testTypeGuardMethod]
from typing_extensions import TypeGuard
class C:
    def main(self, a: object) -> None:
        if self.is_float(a):
            reveal_type(self)  # N: Revealed type is '__main__.C'
            reveal_type(a)  # N: Revealed type is 'builtins.float'
    def is_float(self, a: object) -> TypeGuard[float]: pass
[builtins fixtures/tuple.pyi]

[case testTypeGuardCrossModule]
import guard
from points import Point
def main(a: object) -> None:
    if guard.is_point(a):
        reveal_type(a)  # N: Revealed type is 'points.Point'
[file guard.py]
from typing_extensions import TypeGuard
import points
def is_point(a: object) -> TypeGuard[points.Point]: pass
[file points.py]
class Point: pass
[builtins fixtures/tuple.pyi]
