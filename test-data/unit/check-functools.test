[case testTotalOrderingEqLt]
from functools import total_ordering

@total_ordering
class Ord:
    def __eq__(self, other: object) -> bool:
        return False

    def __lt__(self, other: "Ord") -> bool:
        return False

reveal_type(Ord() < Ord())  # N: Revealed type is "builtins.bool"
reveal_type(Ord() <= Ord())  # N: Revealed type is "builtins.bool"
reveal_type(Ord() == Ord())  # N: Revealed type is "builtins.bool"
reveal_type(Ord() > Ord())  # N: Revealed type is "builtins.bool"
reveal_type(Ord() >= Ord())  # N: Revealed type is "builtins.bool"

Ord() < 1  # E: Unsupported operand types for < ("Ord" and "int")
Ord() <= 1  # E: Unsupported operand types for <= ("Ord" and "int")
Ord() == 1
Ord() > 1  # E: Unsupported operand types for > ("Ord" and "int")
Ord() >= 1  # E: Unsupported operand types for >= ("Ord" and "int")
[builtins fixtures/dict.pyi]

[case testTotalOrderingLambda]
from functools import total_ordering
from typing import Any, Callable, ClassVar

@total_ordering
class Ord:
    __eq__: Callable[[Any, object], bool] = lambda self, other: False
    __lt__: Callable[[Any, "Ord"], bool] = lambda self, other: False

reveal_type(Ord() < Ord())  # N: Revealed type is "builtins.bool"
reveal_type(Ord() <= Ord())  # N: Revealed type is "builtins.bool"
reveal_type(Ord() == Ord())  # N: Revealed type is "builtins.bool"
reveal_type(Ord() > Ord())  # N: Revealed type is "builtins.bool"
reveal_type(Ord() >= Ord())  # N: Revealed type is "builtins.bool"

Ord() < 1  # E: Argument 1 has incompatible type "int"; expected "Ord"
Ord() <= 1  # E: Unsupported operand types for <= ("Ord" and "int")
Ord() == 1
Ord() > 1  # E: Unsupported operand types for > ("Ord" and "int")
Ord() >= 1  # E: Unsupported operand types for >= ("Ord" and "int")
[builtins fixtures/dict.pyi]

[case testTotalOrderingNonCallable]
from functools import total_ordering

@total_ordering
class Ord(object):
    def __eq__(self, other: object) -> bool:
        return False

    __lt__ = 5

Ord() <= Ord()  # E: Unsupported left operand type for <= ("Ord")
Ord() > Ord()  # E: "int" not callable
Ord() >= Ord()  # E: Unsupported left operand type for >= ("Ord")
[builtins fixtures/dict.pyi]

[case testTotalOrderingReturnNotBool]
from functools import total_ordering

@total_ordering
class Ord:
    def __eq__(self, other: object) -> bool:
        return False

    def __lt__(self, other: "Ord") -> str:
        return "blah"

reveal_type(Ord() < Ord())  # N: Revealed type is "builtins.str"
reveal_type(Ord() <= Ord())  # N: Revealed type is "Any"
reveal_type(Ord() == Ord())  # N: Revealed type is "builtins.bool"
reveal_type(Ord() > Ord())  # N: Revealed type is "Any"
reveal_type(Ord() >= Ord())  # N: Revealed type is "Any"
[builtins fixtures/dict.pyi]

[case testTotalOrderingAllowsAny]
from functools import total_ordering

@total_ordering
class Ord:
    def __eq__(self, other):
        return False

    def __gt__(self, other):
        return False

reveal_type(Ord() < Ord())  # N: Revealed type is "Any"
Ord() <= Ord()  # E: Unsupported left operand type for <= ("Ord")
reveal_type(Ord() == Ord())  # N: Revealed type is "Any"
reveal_type(Ord() > Ord())  # N: Revealed type is "Any"
Ord() >= Ord()  # E: Unsupported left operand type for >= ("Ord")

Ord() < 1  # E: Unsupported left operand type for < ("Ord")
Ord() <= 1  # E: Unsupported left operand type for <= ("Ord")
Ord() == 1
Ord() > 1
Ord() >= 1  # E: Unsupported left operand type for >= ("Ord")
[builtins fixtures/dict.pyi]

[case testCachedProperty]
from functools import cached_property
class Parent:
    @property
    def f(self) -> str: pass
class Child(Parent):
    @cached_property
    def f(self) -> str: pass
    @cached_property
    def g(self) -> int: pass
    @cached_property  # E: Too many arguments for property
    def h(self, arg) -> int: pass
reveal_type(Parent().f)  # N: Revealed type is "builtins.str"
reveal_type(Child().f)  # N: Revealed type is "builtins.str"
reveal_type(Child().g)  # N: Revealed type is "builtins.int"
Child().f = "Hello World"
Child().g = "invalid"  # E: Incompatible types in assignment (expression has type "str", variable has type "int")
[file functools.pyi]
import sys
from typing import TypeVar, Generic
_T = TypeVar('_T')
class cached_property(Generic[_T]): ...
[builtins fixtures/property.pyi]

[case testTotalOrderingWithForwardReference]
from typing import Generic, Any, TypeVar
import functools

T = TypeVar("T", bound="C")

@functools.total_ordering
class D(Generic[T]):
    def __lt__(self, other: Any) -> bool:
        ...

class C:
    pass

def f(d: D[C]) -> None:
    reveal_type(d.__gt__)  # N: Revealed type is "def (other: Any) -> builtins.bool"

d: D[int]  # E: Type argument "int" of "D" must be a subtype of "C"
[builtins fixtures/dict.pyi]

[case testFunctoolsPartialBasic]
from typing import Callable
import functools

def foo(a: int, b: str, c: int = 5) -> int: ...  # N: "foo" defined here

p1 = functools.partial(foo)
p1(1, "a", 3)  # OK
p1(1, "a", c=3)  # OK
p1(1, b="a", c=3)  # OK

def takes_callable_int(f: Callable[..., int]) -> None: ...
def takes_callable_str(f: Callable[..., str]) -> None: ...
takes_callable_int(p1)
takes_callable_str(p1)  # E: Argument 1 to "takes_callable_str" has incompatible type "partial[int]"; expected "Callable[..., str]" \
                        # N: "partial[int].__call__" has type "Callable[[VarArg(Any), KwArg(Any)], int]"

p2 = functools.partial(foo, 1)
p2("a")  # OK
p2("a", 3)  # OK
p2("a", c=3)  # OK
p2(1, 3)  # E: Argument 1 to "foo" has incompatible type "int"; expected "str"
p2(1, "a", 3)  # E: Too many arguments for "foo" \
               # E: Argument 1 to "foo" has incompatible type "int"; expected "str" \
               # E: Argument 2 to "foo" has incompatible type "str"; expected "int"
p2(a=1, b="a", c=3)  # E: Unexpected keyword argument "a" for "foo"

p3 = functools.partial(foo, b="a")
p3(1)  # OK
p3(1, c=3)  # OK
p3(a=1)  # OK
p3(1, b="a", c=3)  # OK, keywords can be clobbered
p3(1, 3)  # E: Too many positional arguments for "foo" \
          # E: Argument 2 to "foo" has incompatible type "int"; expected "str"

functools.partial(foo, "a")  # E: Argument 1 to "foo" has incompatible type "str"; expected "int"
functools.partial(foo, b=1)  # E: Argument 1 to "foo" has incompatible type "int"; expected "str"
functools.partial(foo, a=1, b=2, c=3)  # E: Argument 2 to "foo" has incompatible type "int"; expected "str"
functools.partial(1)  # E: Argument 1 to "partial" has incompatible type "int"; expected "Callable[..., Never]"
[builtins fixtures/dict.pyi]

[case testFunctoolsPartialStar]
import functools

def foo(a: int, b: str, *args: int, d: str, **kwargs: int) -> int: ...

p1 = functools.partial(foo, 1, d="a", x=9)
p1("a", 2, 3, 4)  # OK
p1("a", 2, 3, 4, d="a")  # OK
p1("a", 2, 3, 4, "a")  # E: Argument 5 to "foo" has incompatible type "str"; expected "int"
p1("a", 2, 3, 4, x="a")  # E: Argument "x" to "foo" has incompatible type "str"; expected "int"

p2 = functools.partial(foo, 1, "a")
p2(2, 3, 4, d="a")  # OK
p2("a")  # E: Missing named argument "d" for "foo" \
         # E: Argument 1 to "foo" has incompatible type "str"; expected "int"
p2(2, 3, 4)  # E: Missing named argument "d" for "foo"

functools.partial(foo, 1, "a", "b", "c", d="a")  # E: Argument 3 to "foo" has incompatible type "str"; expected "int" \
                                                 # E: Argument 4 to "foo" has incompatible type "str"; expected "int"

[builtins fixtures/dict.pyi]

[case testFunctoolsPartialGeneric]
from typing import TypeVar
import functools

T = TypeVar("T")
U = TypeVar("U")

def foo(a: T, b: T) -> T: ...

p1 = functools.partial(foo, 1)
reveal_type(p1(2))  # N: Revealed type is "builtins.int"
p1("a")  # E: Argument 1 to "foo" has incompatible type "str"; expected "int"

p2 = functools.partial(foo, "a")
p2(1)  # E: Argument 1 to "foo" has incompatible type "int"; expected "str"
reveal_type(p2("a"))  # N: Revealed type is "builtins.str"

def bar(a: T, b: U) -> U: ...

p3 = functools.partial(bar, 1)
reveal_type(p3(2))  # N: Revealed type is "builtins.int"
reveal_type(p3("a"))  # N: Revealed type is "builtins.str"
[builtins fixtures/dict.pyi]

[case testFunctoolsPartialTypeVarTuple]
import functools
import typing
Ts = typing.TypeVarTuple("Ts")
def foo(fn: typing.Callable[[typing.Unpack[Ts]], None], /, *arg: typing.Unpack[Ts], kwarg: str) -> None: ...
# just test that this doesn't crash
functools.partial(foo, kwarg="asdf")
[builtins fixtures/dict.pyi]
