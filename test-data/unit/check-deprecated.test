-- Type checker test cases for reporting deprecations.

[case testDeprecatedFunction]

from typing_extensions import deprecated

@deprecated("use f2 instead")
def f() -> None: ...

f  # E: __main__.f is deprecated - use f2 instead
f(1)  # E: __main__.f is deprecated - use f2 instead \
      # E: Too many arguments for "f"
f[1]  # E: __main__.f is deprecated - use f2 instead \
      # E: Value of type "Callable[[], None]" is not indexable
g = f  # E: __main__.f is deprecated - use f2 instead
g()  # E: __main__.f is deprecated - use f2 instead
t = (f, f, g)  # E: __main__.f is deprecated - use f2 instead

[builtins fixtures/tuple.pyi]


[case testDeprecatedFunctionDifferentModule]

import m
import p.s
import m as n
import p.s as ps
from m import f  # E: m.f is deprecated - use f2 instead
from p.s import g  # E: p.s.g is deprecated - use g2 instead
from k import *

m.f()  # E: m.f is deprecated - use f2 instead
p.s.g()  # E: p.s.g is deprecated - use g2 instead
n.f()  # E: m.f is deprecated - use f2 instead
ps.g()  # E: p.s.g is deprecated - use g2 instead
f()
g()
h()  # E: k.h is deprecated - use h2 instead

[file m.py]
from typing_extensions import deprecated

@deprecated("use f2 instead")
def f() -> None: ...

[file p/s.py]
from typing_extensions import deprecated

@deprecated("use g2 instead")
def g() -> None: ...

[file k.py]
from typing_extensions import deprecated

@deprecated("use h2 instead")
def h() -> None: ...

[builtins fixtures/tuple.pyi]


[case testDeprecatedClass]

from typing_extensions import deprecated

@deprecated("use C2 instead")
class C: ...

c: C  # E: __main__.C is deprecated - use C2 instead
C()  # E: __main__.C is deprecated - use C2 instead
C.missing()  # E: __main__.C is deprecated - use C2 instead \
             # E: "Type[C]" has no attribute "missing"
C.__init__(c)  # E: __main__.C is deprecated - use C2 instead
C(1)  # E: __main__.C is deprecated - use C2 instead \
      # E: Too many arguments for "C"
D = C  # E: __main__.C is deprecated - use C2 instead
D()
t = (C, C, D)  # E: __main__.C is deprecated - use C2 instead

[builtins fixtures/tuple.pyi]


[case testDeprecatedClassDifferentModule]

import m
import p.s
import m as n
import p.s as ps
from m import C  # E: m.C is deprecated - use C2 instead
from p.s import D  # E: p.s.D is deprecated - use D2 instead
from k import *

m.C()  # E: m.C is deprecated - use C2 instead
p.s.D()  # E: p.s.D is deprecated - use D2 instead
n.C()  # E: m.C is deprecated - use C2 instead
ps.D()  # E: p.s.D is deprecated - use D2 instead
C()
D()
E()  # E: k.E is deprecated - use E2 instead

[file m.py]
from typing_extensions import deprecated

@deprecated("use C2 instead")
class C: ...

[file p/s.py]
from typing_extensions import deprecated

@deprecated("use D2 instead")
class D: ...

[file k.py]
from typing_extensions import deprecated

@deprecated("use E2 instead")
class E: ...

[builtins fixtures/tuple.pyi]


[case testDeprecatedClassInitMethod]

from typing_extensions import deprecated

@deprecated("use C2 instead")
class C:
    def __init__(self) -> None: ...

c: C  # E: __main__.C is deprecated - use C2 instead
C()  # E: __main__.C is deprecated - use C2 instead
C.__init__(c)  # E: __main__.C is deprecated - use C2 instead

[builtins fixtures/tuple.pyi]


[case testDeprecatedSpecialMethods]

from typing import Iterator
from typing_extensions import deprecated

class A:
    @deprecated("no A + int")
    def __add__(self, v: int) -> None: ...

    @deprecated("no int + A")
    def __radd__(self, v: int) -> None: ...

    @deprecated("no A = A + int")
    def __iadd__(self, v: int) -> A: ...

    @deprecated("no iteration")
    def __iter__(self) -> Iterator[int]: ...

    @deprecated("no in")
    def __contains__(self, v: int) -> int: ...

    @deprecated("no integer")
    def __int__(self) -> int: ...

    @deprecated("no inversion")
    def __invert__(self) -> A: ...

class B:
    @deprecated("no in")
    def __contains__(self, v: int) -> int: ...

a = A()
b = B()
a + 1  # E: __main__.A.__add__ is deprecated - no A + int
1 + a  # E: __main__.A.__radd__ is deprecated - no int + A
a += 1  # E: __main__.A.__iadd__ is deprecated - no A = A + int
for i in a:  # E: __main__.A.__iter__ is deprecated - no iteration
    reveal_type(i)  # N: Revealed type is "builtins.int"
1 in a  # E: __main__.A.__iter__ is deprecated - no iteration
1 in b  # E: __main__.B.__contains__ is deprecated - no in
~a  # E: __main__.A.__invert__ is deprecated - no inversion

[builtins fixtures/tuple.pyi]


[case testDeprecatedOverloadedSpecialMethods]

from typing import Iterator, Union
from typing_extensions import deprecated, overload

class A:
    @overload
    @deprecated("no A + int")
    def __add__(self, v: int) -> None: ...
    @overload
    def __add__(self, v: str) -> None: ...
    def __add__(self, v: Union[int, str]) -> None: ...

    @overload
    def __radd__(self, v: int) -> None: ...
    @overload
    @deprecated("no str + A")
    def __radd__(self, v: str) -> None: ...
    def __radd__(self, v: Union[int, str]) -> None: ...

    @overload
    def __iadd__(self, v: int) -> A: ...
    @overload
    def __iadd__(self, v: str) -> A: ...
    @deprecated("no A += Any")
    def __iadd__(self, v: Union[int, str]) -> A: ...

a = A()
a + 1  # E: __main__.A.__add__ is deprecated - no A + int
a + "x"
1 + a
"x" + a  # E: __main__.A.__radd__ is deprecated - no str + A
a += 1  # E: __main__.A.__iadd__ is deprecated - no A += Any
a += "x"  # E: __main__.A.__iadd__ is deprecated - no A += Any

[builtins fixtures/tuple.pyi]


[case testDeprecatedMethod]

from typing_extensions import deprecated

class C:
    @deprecated("use g instead")
    def f(self) -> None: ...

    def g(self) -> None: ...

    @staticmethod
    @deprecated("use g instead")
    def h() -> None: ...

    @deprecated("use g instead")
    @staticmethod
    def k() -> None: ...

C.f  # E: __main__.C.f is deprecated - use g instead
C().f  # E: __main__.C.f is deprecated - use g instead
C().f()  # E: __main__.C.f is deprecated - use g instead
C().f(1)  # E: __main__.C.f is deprecated - use g instead \
          # E: Too many arguments for "f" of "C"
f = C().f  # E: __main__.C.f is deprecated - use g instead
f()  # E: __main__.C.f is deprecated - use g instead
t = (C.f, C.f, C.g)  # E: __main__.C.f is deprecated - use g instead

C().g()
C().h()  # E: __main__.C.h is deprecated - use g instead
C().k()  # E: __main__.C.k is deprecated - use g instead

[builtins fixtures/callable.pyi]


[case testDeprecatedClassWithDeprecatedMethod]

from typing_extensions import deprecated

@deprecated("use D instead")
class C:
    @deprecated("use g instead")
    def f(self) -> None: ...
    def g(self) -> None: ...

C().f()  # E: __main__.C is deprecated - use D instead \
         # E: __main__.C.f is deprecated - use g instead
C().g()  # E: __main__.C is deprecated - use D instead

[builtins fixtures/callable.pyi]


[case testDeprecatedProperty]

from typing_extensions import deprecated

class C:
    @property
    @deprecated("use f2 instead")
    def f(self) -> int: ...

    @property
    def g(self) -> int: ...
    @g.setter
    @deprecated("use g2 instead")
    def g(self, v: int) -> None: ...


C.f  # E: __main__.C.f is deprecated - use f2 instead
C().f  # E: __main__.C.f is deprecated - use f2 instead
C().f()  # E: __main__.C.f is deprecated - use f2 instead \
         # E: "int" not callable
C().f = 1  # E: Property "f" defined in "C" is read-only \
           # E: __main__.C.f is deprecated - use f2 instead

C.g
C().g
C().g = 1  # E: __main__.C.g is deprecated - use g2 instead
C().g = "x"  # E: __main__.C.g is deprecated - use g2 instead \
             # E: Incompatible types in assignment (expression has type "str", variable has type "int")

[builtins fixtures/property.pyi]


[case testDeprecatedOverloadedFunction]

from typing import Union
from typing_extensions import deprecated, overload

@overload
def f(x: int) -> int: ...
@overload
def f(x: str) -> str: ...
@deprecated("use f2 instead")
def f(x: Union[int, str]) -> Union[int, str]: ...

f  # E: __main__.f is deprecated - use f2 instead
f(1)  # E: __main__.f is deprecated - use f2 instead
f("x")  # E: __main__.f is deprecated - use f2 instead
f(1.0)  # E: __main__.f is deprecated - use f2 instead \
        # E: No overload variant of "f" matches argument type "float" \
        # N: Possible overload variants: \
        # N:     def f(x: int) -> int \
        # N:     def f(x: str) -> str

@overload
@deprecated("work with str instead")
def g(x: int) -> int: ...
@overload
def g(x: str) -> str: ...
def g(x: Union[int, str]) -> Union[int, str]: ...

g
g(1)  # E: __main__.g is deprecated - work with str instead
g("x")
g(1.0)  # E: No overload variant of "g" matches argument type "float" \
        # N: Possible overload variants: \
        # N:     def g(x: int) -> int \
        # N:     def g(x: str) -> str

@overload
def h(x: int) -> int: ...
@overload
@deprecated("work with int instead")
def h(x: str) -> str: ...
def h(x: Union[int, str]) -> Union[int, str]: ...

h
h(1)
h("x")  # E: __main__.h is deprecated - work with int instead
h(1.0)  # E: No overload variant of "h" matches argument type "float" \
        # N: Possible overload variants: \
        # N:     def h(x: int) -> int \
        # N:     def h(x: str) -> str

[builtins fixtures/tuple.pyi]
