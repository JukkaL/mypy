-- Test cases for fine-grained incremental checking
--
-- Test cases may define multiple versions of a file
-- (e.g. m.py, m.py.2). There is always an initial batch
-- pass that processes all files present initially, followed
-- by one or more fine-grained incremental passes that use
-- alternative versions of files, if available. If a file
-- just has a single .py version, it is used for all passes.

-- TODO: what if version for some passes but not all

-- Output is laid out like this:
--
--   [out]
--   <optional output from batch pass>
--   ==
--   <optional output from first incremental pass>
--
--
-- Modules that are expected to be detected as changed by dmypy_server
-- can be checked with [stale ...]
-- Generally this should mean added, deleted, or changed files, though there
-- are important edge cases related to the cache: deleted files won't be detected
-- as changed in the initial run with the cache while modules that depended on them
-- should be.
--
-- Modules that are require a full-module reprocessing by update can be checked with
-- [rechecked ...]. This should include any files detected as having changed as well
-- as any files that contain targets that need to be reprocessed but which haven't
-- been loaded yet. If there is no [rechecked...] directive, it inherits the value of
-- [stale ...].
--
-- Specifications for later runs can be given with [stale2 ...], [stale3 ...], etc.
--
-- Test runner can parse options from pyproject.toml file. Updating this file in
-- between incremental runs is not yet supported.
--
-- Each test case run without caching and with caching (if the initial run passes),
-- unless it has one a -only_when_cache or -only_when_nocache arguments. We sometimes
-- skip caching test cases to speed up tests, if the caching variant is not useful.
-- The caching test case variants get an implicit _cached suffix.

[case testPerFileStrictOptionalModulePyprojectTOML]
import a
[file pyproject.toml]
\[tool.mypy]
strict_optional = false
\[tool.'mypy-a.*']
strict_optional = true
[file a.py]
from typing import Optional
import b
x: int
y: int = x
[file b.py]
from typing import Optional
x: int
y: int = x
[file b.py.2]
from typing import Optional
x: Optional[int]
y: int = x
[file a.py.3]
from typing import Optional
import b
x: Optional[int]
y: int = x
[out]
==
==
a.py:4: error: Incompatible types in assignment (expression has type "Optional[int]", variable has type "int")

[case testPerFileStrictOptionalModuleOnlyPyprojectTOML]
import a
[file pyproject.toml]
\[tool.mypy]
strict_optional = false
\[tool.'mypy-a.*']
strict_optional = true
[file a.py]
from typing import Optional
import b
y: int = b.x
class Dummy:
    def f(self) -> None:
        pass
[file b.py]
from typing import Optional
import c
x: int
y: int = c.x
class Dummy:
    def f(self) -> None:
        pass
[file c.py]
from typing import Optional
x: int
[file c.py.2]
from typing import Optional
x: Optional[int]
[file b.py.3]
from typing import Optional
import c
x: Optional[int]
y: int = c.x
[file a.py.4]
from typing import Optional
import b
y: Optional[int] = b.x
class Dummy:
    def f(self) -> None:
        pass
[out]
==
==
a.py:3: error: Incompatible types in assignment (expression has type "Optional[int]", variable has type "int")
==

[case testPerFileStrictOptionalFunctionPyprojectTOML]
import a
[file pyproject.toml]
\[tool.mypy]
strict_optional = false
\[tool.'mypy-b.*']
strict_optional = true
[file a.py]
from typing import Optional
import b
def f() -> None:
    x: int
    x = b.g(x)
[file b.py]
from typing import Optional
import c
def g(x: Optional[int]) -> Optional[int]:
    return c.h(x)
[file c.py]
from typing import Optional
def h(x: Optional[int]) -> int:
    pass
[file c.py.2]
from typing import Optional
def h(x: int) -> int:
    pass
[file b.py.3]
from typing import Optional
import c
def g(x: int) -> Optional[int]:
    return c.h(x)
[out]
==
b.py:4: error: Argument 1 to "h" has incompatible type "Optional[int]"; expected "int"
==

[case testPerFileStrictOptionalMethodPyprojectTOML]
import a
[file pyproject.toml]
\[tool.mypy]
strict_optional = false
\[tool.'mypy-b.*']
strict_optional = true
[file a.py]
from typing import Optional
import b
class A:
    def f(self) -> None:
        x: int
        x = b.B().g(x)
[file b.py]
from typing import Optional
import c
class B:
    def g(self, x: Optional[int]) -> Optional[int]:
        return c.C().h(x)
[file c.py]
from typing import Optional
class C:
    def h(self, x: Optional[int]) -> int:
        pass
[file c.py.2]
from typing import Optional
class C:
    def h(self, x: int) -> int:
        pass
[file b.py.3]
from typing import Optional
import c
class B:
    def g(self, x: int) -> Optional[int]:
        return c.C().h(x)
[out]
==
b.py:5: error: Argument 1 to "h" of "C" has incompatible type "Optional[int]"; expected "int"
==

[case testRefreshIgnoreErrors1PyprojectTOML]
[file pyproject.toml]
\[tool.mypy]
\[tool.mypy-b]
ignore_errors = true
[file a.py]
y = '1'
[file a.py.2]
y = 1
[file b.py]
from a import y
def fu() -> None:
    1+'lurr'
    y
[out]
==

[case testRefreshIgnoreErrors2PyprojectTOML]
[file pyproject.toml]
\[tool.mypy]
\[tool.mypy-b]
ignore_errors = true
[file b.py]
def fu() -> int:
    1+'lurr'
    return 1
[file b.py.2]
def fu() -> int:
    1+'lurr'
    return 2
[out]
==

[case testRefreshOptionsPyprojectTOML]
[file pyproject.toml]
\[tool.mypy]
disallow_any_generics = true
\[tool.mypy-b]
disallow_any_generics = false
[file a.py]
y = '1'
[file a.py.2]
y = 1
[file b.py]
from typing import List
from a import y
x = []  # type: List
[builtins fixtures/list.pyi]
[out]
==
