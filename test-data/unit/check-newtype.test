-- Checks NewType(...)

[case testNewTypePEP484Example1]
from typing import NewType

UserId = NewType('UserId', int)

def name_by_id(user_id: UserId) -> str:
    return "foo"

UserId('user')  # E: Argument 1 to "UserId" has incompatible type "str"; expected "int"
name_by_id(42)  # E: Argument 1 to "name_by_id" has incompatible type "int"; expected "UserId"
name_by_id(UserId(42))

id = UserId(5)
num = id + 1

reveal_type(id)  # E: Revealed type is '__main__.UserId'
reveal_type(num)  # E: Revealed type is 'builtins.int'
[out]

[case testNewTypePEP484Example2]
from typing import NewType

class PacketId:
    def __init__(self, major: int, minor: int) -> None:
        self._major = major
        self._minor = minor

TcpPacketId = NewType('TcpPacketId', PacketId)

packet = PacketId(100, 100)
tcp_packet = TcpPacketId(packet)
tcp_packet = TcpPacketId(127, 0)

[out]
main:12: error: Too many arguments for "TcpPacketId"
main:12: error: Argument 1 to "TcpPacketId" has incompatible type "int"; expected "PacketId"

[case testNewTypeBadInitialization]
from typing import NewType

a = NewType('b', int)
b = NewType('b', 3)
c = NewType(2, int)
foo = "d"
d = NewType(foo, int)
e = NewType(name='e', tp=int)
f = NewType('f', tp=int)
[out]
main:3: error: Argument 1 to NewType(...) does not match variable name
main:4: error: Argument 2 to NewType(...) must be a valid type
main:5: error: Argument 1 to NewType(...) must be a string literal
main:7: error: Argument 1 to NewType(...) must be a string literal
main:8: error: Argument 1 to NewType(...) must be a positional string literal
main:8: error: Argument 2 to NewType(...) must be a positional type
main:9: error: Argument 2 to NewType(...) must be a positional type

[case testNewTypeWithCasts]
from typing import NewType, cast
UserId = NewType('UserId', int)
foo = UserId(3)
foo = cast(UserId, 3)
foo = cast(UserId, "foo")
foo = cast(UserId, UserId(4))
[out]

[case testNewTypeWithCompositeTypes]
from typing import NewType, Tuple, List
TwoTuple = NewType('TwoTuple', Tuple[int, str])
a = TwoTuple((3, "a"))
b = TwoTuple(("a", 3))  # E: Argument 1 to "TwoTuple" has incompatible type "Tuple[str, int]"; expected "Tuple[int, str]"

reveal_type(a[0])  # E: Revealed type is 'builtins.int'
reveal_type(a[1])  # E: Revealed type is 'builtins.str'

UserId = NewType('UserId', int)
IdList = NewType('IdList', List[UserId])

bad1 = IdList([1])  # E: List item 0 has incompatible type "int"

foo = IdList([])
foo.append(3)  # E: Argument 1 to "append" of "list" has incompatible type "int"; expected "UserId"
foo.append(UserId(3))
foo.extend([UserId(1), UserId(2), UserId(3)])
foo.extend(IdList([UserId(1), UserId(2), UserId(3)]))
bar = IdList([UserId(2)])

baz = foo + bar
reveal_type(foo)  # E: Revealed type is '__main__.IdList'
reveal_type(bar)  # E: Revealed type is '__main__.IdList'
reveal_type(baz)  # E: Revealed type is 'builtins.list[__main__.UserId*]'

[builtins fixtures/tuple.py]
[out]

[case testNewTypeWithUnions]
from typing import NewType, Union
Foo = NewType('Foo', Union[int, float])  # E: Argument 2 to NewType(...) must be subclassable (got Union[builtins.int, builtins.float])
[out]

[case testNewTypeWithGenerics]
from typing import TypeVar, Generic, NewType, Any

T = TypeVar('T')

class Base(Generic[T]):
    def __init__(self, item: T) -> None:
        self.item = item

    def getter(self) -> T:
        return self.item

Derived1 = NewType('Derived1', Base[str])
Derived2 = NewType('Derived2', Base)       # Implicit 'Any'
Derived3 = NewType('Derived3', Base[Any])  # Explicit 'Any'

Derived1(Base(1))  # E: Argument 1 to "Base" has incompatible type "int"; expected "str"
Derived1(Base('a'))
Derived2(Base(1))
Derived2(Base('a'))
Derived3(Base(1))
Derived3(Base('a'))

reveal_type(Derived1(Base('a')).getter())  # E: Revealed type is 'builtins.str*'
reveal_type(Derived3(Base('a')).getter())  # E: Revealed type is 'Any'
[out]

[case testNewTypeInMultipleFiles]
import a
import b
list1 = [a.UserId(1), a.UserId(2)]
list1.append(b.UserId(3))  # E: Argument 1 to "append" of "list" has incompatible type "b.UserId"; expected "a.UserId"

[file a.py]
from typing import NewType
UserId = NewType('UserId', int)

[file b.py]
from typing import NewType
UserId = NewType('UserId', int)

[builtins fixtures/list.py]
[out]

[case testNewTypeWithTypeAliases]
from typing import NewType
Foo = int
Bar = NewType('Bar', Foo)

def func1(x: Foo) -> Bar:
    return Bar(x)

def func2(x: int) -> Bar:
    return Bar(x)

[out]

[case testNewTypeWithTypeType]
from typing import NewType, Type
Foo = NewType('Foo', Type[int])  # E: Argument 2 to NewType(...) must be subclassable (got Type[builtins.int])
a = Foo(type(3))
[builtins fixtures/args.py]
[out]

[case testNewTypeWithTypeVars]
from typing import NewType, TypeVar, List
T = TypeVar('T')
A = NewType('A', T)
B = NewType('B', List[T])
[builtins fixtures/list.py]
[out]
main:3: error: Invalid type "__main__.T"
main:3: error: Argument 2 to NewType(...) must be subclassable (got T?)
main:4: error: Invalid type "__main__.T"

[case testNewTypeRedefiningVariables]
from typing import NewType

a = 3
a = NewType('a', int)

b = NewType('b', int)
b = NewType('b', float)

c = NewType('c', str)   # type: str
[out]
main:4: error: Cannot redefine 'a' as a NewType
main:7: error: Invalid assignment target
main:7: error: Cannot redefine 'b' as a NewType
main:9: error: Cannot declare the type of a NewType declaration

[case testNewTypeInLocalScope]
from typing import NewType
A = NewType('A', int)
a = A(3)

def func() -> None:
    A = NewType('A', str)
    B = NewType('B', str)

    a = A(3)
    a = A('xyz')
    b = B('xyz')

class MyClass:
    C = NewType('C', float)
    
    def foo(self) -> 'MyClass.C':
        return MyClass.C(3.2)

b = A(3)
c = MyClass.C(3.5)
[out]
main: note: In function "func":
main:9: error: Argument 1 to "A" has incompatible type "int"; expected "str"

