-- Checks for incremental mode (see testcheck.py).
-- Each test is run at least twice, once with a cold cache, once with a warm cache.
-- Before the tests are run again, in step N any *.py.N files are copied to
-- *.py.  There are at least two runs; more as long as there are *.py.N files.
--
-- You can add an empty section like `[delete mod.py.2]` to delete `mod.py`
-- before the second run.
--
-- Errors expected in the first run should be in the `[out1]` section, and
-- errors expected in the second run should be in the `[out2]` section, and so on.
-- If a section is omitted, it is expected there are no errors on that run.
-- The number of runs is determined by the highest N in all [outN] sections, but
-- there are always at least two runs. (Note that [out] is equivalent to [out1].)
--
-- The list of modules to be checked can be specified using
-- # cmd: mypy -m mod1 mod2 mod3
-- To check a different list on the second run, use
-- # cmd2: mypy -m mod1 mod3
-- (and cmd3 for the third run, and so on).
--
-- Extra command line flags may be specified using
-- # flags: --some-flag
-- If the second run requires different flags, those can be specified using
-- # flags2: --another-flag
-- (and flags3 for the third run, and so on).
--
-- Incremental tests involving plugins that get updated are also supported.
-- All plugin files that are updated *must* end in '_plugin', so they will
-- be unloaded from 'sys.modules' between incremental steps.
--
-- Any files that we expect to be rechecked should be annotated in the [rechecked]
-- annotation, and any files expect to be stale (aka have a modified interface)
-- should be annotated in the [stale] annotation. Note that a file that ends up
-- producing an error has its caches deleted and is marked stale automatically.
-- Such files do not need to be included in [stale ...] list.
--
-- The test suite will automatically assume that __main__ is stale and rechecked in
-- all cases so we can avoid constantly having to annotate it. The list of
-- rechecked/stale files can be in any arbitrary order, or can be left empty
-- if no files should be rechecked/stale.
--
-- There are additional incremental mode test cases in check-serialize.test.

[case testIncrementalFollowImportsVariablePyprojectTOML]
# flags: --config-file tmp/pyproject.toml
import a
reveal_type(a.x)
[file a.py]
x = 0
[file pyproject.toml]
\[tool.mypy]
follow_imports = "normal"
[file pyproject.toml.2]
\[tool.mypy]
follow_imports = "skip"
[out1]
main:3: note: Revealed type is "builtins.int"
[out2]
main:3: note: Revealed type is "Any"

[case testIncrementalPerFileFlagsPyprojectTOML]
# flags: --config-file tmp/pyproject.toml
import a
[file a.py]
pass
[file pyproject.toml]
\[tool.mypy]
warn_no_return = false
\[[tool.mypy.overrides]]
module = "a"
warn_no_return = true
[rechecked]

[case testRegularUsesFgCachePyprojectTOML]
# flags: --config-file tmp/pyproject.toml
import a
[file a.py]
x = 0
[file pyproject.toml]
\[tool.mypy]
cache_fine_grained = true
[file pyproject.toml.2]
\[tool.mypy]
cache_fine_grained = false
-- Nothing should get rechecked
[rechecked]
[stale]

[case testFgCacheNeedsFgCachePyprojectTOML]
# flags: --config-file tmp/pyproject.toml
import a
[file a.py]
x = 0
[file pyproject.toml]
\[tool.mypy]
cache_fine_grained = false
[file pyproject.toml.2]
\[tool.mypy]
cache_fine_grained = true
[rechecked a, builtins, typing]
[stale a, builtins, typing]
[builtins fixtures/tuple.pyi]

[case testFollowImportSkipNotInvalidatedOnAddedStubOnFollowForStubsPyprojectTOML]
# flags: --follow-imports=skip --ignore-missing-imports --config-file=tmp/pyproject.toml
# cmd: mypy -m main
[file main.py]
import other
[file other.pyi.2]
x = 1
[file pyproject.toml]
\[tool.mypy]
follow_imports_for_stubs = true
[stale]
[rechecked]

[case testChangedPluginsInvalidateCachePyprojectTOML]
# flags: --config-file tmp/pyproject.toml
import a
[file a.py]
from b import x
y: int = x

[file a.py.2]
from b import x
y: int = x
touch = 1

[file b.py]
class C: ...
def f() -> C: ...
x = f()

[file basic_plugin.py]
from mypy.plugin import Plugin

class MyPlugin(Plugin):
    def get_function_hook(self, fullname):
        if fullname.endswith('.f'):
            return my_hook
        assert fullname is not None
        return None

def my_hook(ctx):
    return ctx.api.named_generic_type('builtins.int', [])

def plugin(version):
    return MyPlugin

[file basic_plugin.py.2]
from mypy.plugin import Plugin

class MyPlugin(Plugin):
    def get_function_hook(self, fullname):
        if fullname.endswith('.f'):
            return my_hook
        assert fullname is not None
        return None

def my_hook(ctx):
    return ctx.api.named_generic_type('builtins.str', [])

def plugin(version):
    return MyPlugin
[file pyproject.toml]
\[tool.mypy]
plugins = "basic_plugin.py"
[out]
[out2]
tmp/a.py:2: error: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testChangedPluginsInvalidateCache2PyprojectTOML]
# flags: --config-file tmp/pyproject.toml
import a
[file a.py]
from b import x
y: int = x

[file a.py.2]
from b import x
y: int = x
touch = 1

[file b.py]
class C: ...
def f() -> C: ...
x = f()

[file basic_plugin.py]
from mypy.plugin import Plugin
from version_plugin import __version__, choice

class MyPlugin(Plugin):
    def get_function_hook(self, fullname):
        if fullname.endswith('.f'):
            return my_hook
        assert fullname is not None
        return None

def my_hook(ctx):
    if choice:
        return ctx.api.named_generic_type('builtins.int', [])
    else:
        return ctx.api.named_generic_type('builtins.str', [])

def plugin(version):
    return MyPlugin

[file version_plugin.py]
__version__ = 0.1
choice = True

[file version_plugin.py.2]
__version__ = 0.2
choice = False
[file pyproject.toml]
\[tool.mypy]
plugins = "basic_plugin.py"
[out]
[out2]
tmp/a.py:2: error: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testAddedPluginsInvalidateCachePyprojectTOML]
# flags: --config-file tmp/pyproject.toml
import a
[file a.py]
from b import x
y: int = x

[file a.py.2]
from b import x
y: int = x
touch = 1

[file b.py]
def f() -> int: ...
x = f()

[file basic_plugin.py]
from mypy.plugin import Plugin

class MyPlugin(Plugin):
    def get_function_hook(self, fullname):
        if fullname.endswith('.f'):
            return my_hook
        assert fullname is not None
        return None

def my_hook(ctx):
    return ctx.api.named_generic_type('builtins.str', [])

def plugin(version):
    return MyPlugin

[file pyproject.toml]
\[tool.mypy]
python_version = 3.6
[file pyproject.toml.2]
\[tool.mypy]
python_version = 3.6
plugins = "basic_plugin.py"
[out]
[out2]
tmp/a.py:2: error: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testRemovedPluginsInvalidateCachePyprojectTOML]
# flags: --config-file tmp/pyproject.toml
import a
[file a.py]
from b import x
y: str = x

[file a.py.2]
from b import x
y: str = x
touch = 1

[file b.py]
def f() -> int: ...
x = f()

[file basic_plugin.py]
from mypy.plugin import Plugin

class MyPlugin(Plugin):
    def get_function_hook(self, fullname):
        if fullname.endswith('.f'):
            return my_hook
        assert fullname is not None
        return None

def my_hook(ctx):
    return ctx.api.named_generic_type('builtins.str', [])

def plugin(version):
    return MyPlugin

[file pyproject.toml]
\[tool.mypy]
python_version = 3.6
plugins = "basic_plugin.py"
[file pyproject.toml.2]
\[tool.mypy]
python_version = 3.6
[out]
[out2]
tmp/a.py:2: error: Incompatible types in assignment (expression has type "int", variable has type "str")
