-- Check that builtins.type can be used instead of typing.Type in
-- annotations of first method arguments, as prescribed by PEP 585.
-- Ref. https://github.com/python/mypy/issues/15296
-- ----------------------------------------------------------------

-- Variants of tests in check-abstract.test
-- ----------------------------------------

[case testInstantiationAbstractsInTypeForClassMethods_pep585]
# flags: --python-version 3.9
from abc import abstractmethod

class Logger:
    @staticmethod
    def log(a: type[C]):
        pass
class C:
    @classmethod
    def action(cls) -> None:
        cls() #OK for classmethods
        Logger.log(cls)  #OK for classmethods
    @abstractmethod
    def m(self) -> None:
        pass
[builtins fixtures/classmethod.pyi]
[out]

-- Variants of tests in check-classes.test
-- ---------------------------------------

[case testMetaclassSelfType_pep585]
# flags: --python-version 3.9
from typing import TypeVar

class M(type): pass
T = TypeVar('T')

class M1(M):
    def foo(cls: type[T]) -> T: ...

class A(metaclass=M1): pass
reveal_type(A.foo())  # N: Revealed type is "__main__.A"

[case testMetaclassStrictSupertypeOfTypeWithClassmethods_pep585]
# flags: --python-version 3.9
from typing import TypeVar
TA = TypeVar('TA', bound='A')
TTA = TypeVar('TTA', bound='type[A]')
TM = TypeVar('TM', bound='M')

class M(type):
    def g1(cls: 'type[A]') -> A: pass #  E: The erased type of self "Type[__main__.A]" is not a supertype of its class "__main__.M"
    def g2(cls: type[TA]) -> TA: pass #  E: The erased type of self "Type[__main__.A]" is not a supertype of its class "__main__.M"
    def g3(cls: TTA) -> TTA: pass #  E: The erased type of self "Type[__main__.A]" is not a supertype of its class "__main__.M"
    def g4(cls: TM) -> TM: pass
m: M

class A(metaclass=M):
    def foo(self): pass

reveal_type(A.g1)  # N: Revealed type is "def () -> __main__.A"
reveal_type(A.g2)  # N: Revealed type is "def () -> __main__.A"
reveal_type(A.g3)  # N: Revealed type is "def () -> def () -> __main__.A"
reveal_type(A.g4)  # N: Revealed type is "def () -> def () -> __main__.A"

class B(metaclass=M):
    def foo(self): pass

B.g1  # E: Invalid self argument "Type[B]" to attribute function "g1" with type "Callable[[Type[A]], A]"
B.g2  # E: Invalid self argument "Type[B]" to attribute function "g2" with type "Callable[[Type[TA]], TA]"
B.g3  # E: Invalid self argument "Type[B]" to attribute function "g3" with type "Callable[[TTA], TTA]"
reveal_type(B.g4)  # N: Revealed type is "def () -> def () -> __main__.B"

# 4 examples of unsoundness - instantiation, classmethod, staticmethod and ClassVar:

ta: type[A] = m  # E: Incompatible types in assignment (expression has type "M", variable has type "Type[A]")
a: A = ta()
reveal_type(ta.g1)  # N: Revealed type is "def () -> __main__.A"
reveal_type(ta.g2)  # N: Revealed type is "def () -> __main__.A"
reveal_type(ta.g3)  # N: Revealed type is "def () -> Type[__main__.A]"
reveal_type(ta.g4)  # N: Revealed type is "def () -> Type[__main__.A]"

x: M = ta
x.g1  # E: Invalid self argument "M" to attribute function "g1" with type "Callable[[Type[A]], A]"
x.g2  # E: Invalid self argument "M" to attribute function "g2" with type "Callable[[Type[TA]], TA]"
x.g3  # E: Invalid self argument "M" to attribute function "g3" with type "Callable[[TTA], TTA]"
reveal_type(x.g4)  # N: Revealed type is "def () -> __main__.M"

def r(ta: type[TA], tta: TTA) -> None:
    x: M = ta
    y: M = tta

class Class(metaclass=M):
    @classmethod
    def f1(cls: type[Class]) -> None: pass
    @classmethod
    def f2(cls: M) -> None: pass
cl: type[Class] = m  # E: Incompatible types in assignment (expression has type "M", variable has type "Type[Class]")
reveal_type(cl.f1)  # N: Revealed type is "def ()"
reveal_type(cl.f2)  # N: Revealed type is "def ()"
x1: M = cl

class Static(metaclass=M):
    @staticmethod
    def f() -> None: pass
s: type[Static] = m  # E: Incompatible types in assignment (expression has type "M", variable has type "Type[Static]")
reveal_type(s.f)  # N: Revealed type is "def ()"
x2: M = s

from typing import ClassVar
class Cvar(metaclass=M):
    x = 1  # type: ClassVar[int]
cv: type[Cvar] = m  # E: Incompatible types in assignment (expression has type "M", variable has type "Type[Cvar]")
cv.x
x3: M = cv

[builtins fixtures/classmethod.pyi]

[case testNewReturnType4_pep585]
# flags: --python-version 3.9
from typing import TypeVar

# Check for __new__ using type vars

TX = TypeVar('TX', bound='X')
class X:
    def __new__(lol: type[TX], x: int) -> TX:
        pass
class Y(X): pass

reveal_type(X(20))  # N: Revealed type is "__main__.X"
reveal_type(Y(20))  # N: Revealed type is "__main__.Y"

[case testOverrideGenericSelfClassMethod_pep585]
# flags: --python-version 3.9
from typing import Generic, TypeVar, List

T = TypeVar('T', bound='A')

class A:
    @classmethod
    def meth(cls: type[T]) -> List[T]: ...

class B(A):
    @classmethod
    def meth(cls: type[T]) -> List[T]: ...

[builtins fixtures/isinstancelist.pyi]

-- Variants of tests in check-dataclasses.test
-- -------------------------------------------

[case testDataclassFactory_pep585]
# flags: --python-version 3.9
from typing import TypeVar
from dataclasses import dataclass

T = TypeVar('T', bound='A')

@dataclass
class A:
    @classmethod
    def make(cls: type[T]) -> T:
        reveal_type(cls)  # N: Revealed type is "Type[T`-1]"
        reveal_type(cls())  # N: Revealed type is "T`-1"
        return cls()
[builtins fixtures/dataclasses.pyi]

-- Variants of tests in check-generics.test
-- ----------------------------------------

[case testGenericClassAlternativeConstructorPrecise_pep585]
# flags: --python-version 3.9
from typing import Generic, TypeVar, Tuple

T = TypeVar('T')

class Base(Generic[T]):
    Q = TypeVar('Q', bound=Base[T])

    def __init__(self, item: T) -> None: ...

    @classmethod
    def make_pair(cls: type[Q], item: T) -> Tuple[Q, Q]:
        if bool():
            return cls(0), cls(0)  # E: Argument 1 to "Base" has incompatible type "int"; expected "T"
        return cls(item), cls(item)
[builtins fixtures/classmethod.pyi]

[case testGenericClassAlternativeConstructorPreciseOverloaded_pep585]
# flags: --python-version 3.9
from typing import Generic, TypeVar, Tuple, overload, Union

T = TypeVar('T')

class Base(Generic[T]):
    Q = TypeVar('Q', bound=Base[T])

    def __init__(self, item: T) -> None: ...

    @overload
    @classmethod
    def make_some(cls: type[Q], item: T) -> Q: ...

    @overload
    @classmethod
    def make_some(cls: type[Q], item: T, n: int) -> Tuple[Q, ...]: ...

    @classmethod
    def make_some(cls: type[Q], item: T, n: int = 0) -> Union[Q, Tuple[Q, ...]]:
        if n:
            return (cls(item),)
        return cls(item)

reveal_type(Base.make_some)  # N: Revealed type is "Overload(def [T] (item: T`1) -> __main__.Base[T`1], def [T] (item: T`1, n: builtins.int) -> builtins.tuple[__main__.Base[T`1], ...])"
reveal_type(Base.make_some(1))  # N: Revealed type is "__main__.Base[builtins.int]"
reveal_type(Base.make_some(1, 1))  # N: Revealed type is "builtins.tuple[__main__.Base[builtins.int], ...]"

class Sub(Base[str]): ...
Sub.make_some(1)  # E: No overload variant of "make_some" of "Base" matches argument type "int" \
                  # N: Possible overload variants: \
                  # N:     def make_some(cls, item: str) -> Sub \
                  # N:     def make_some(cls, item: str, n: int) -> Tuple[Sub, ...]
[builtins fixtures/classmethod.pyi]

[case testGenericClassMethodUnboundOnClassNonMatchingIdNonGeneric_pep585]
# flags: --python-version 3.9
from typing import Generic, TypeVar, Any, Tuple

T = TypeVar('T')
S = TypeVar('S')
Q = TypeVar('Q', bound='A[Any]')

class A(Generic[T]):
    @classmethod
    def foo(cls: type[Q]) -> Tuple[T, Q]: ...

class B(A[T], Generic[T, S]):
    def meth(self) -> None:
        reveal_type(A[T].foo)  # N: Revealed type is "def () -> Tuple[T`1, __main__.A[T`1]]"
    @classmethod
    def other(cls) -> None:
        reveal_type(cls.foo)  # N: Revealed type is "def () -> Tuple[T`1, __main__.B[T`1, S`2]]"
reveal_type(B.foo)  # N: Revealed type is "def [T, S] () -> Tuple[T`1, __main__.B[T`1, S`2]]"
[builtins fixtures/classmethod.pyi]

[case testGenericClassAlternativeConstructorPrecise2_pep585]
# flags: --python-version 3.9
from typing import Generic, TypeVar, Tuple, Any

T = TypeVar('T')
Q = TypeVar('Q')

class Base(Generic[T]):
    def __init__(self, item: T) -> None: ...
    @classmethod
    def make_pair(cls: type[Q], item: T) -> Tuple[Q, Q]: ...
class Sub(Base[T]):
    ...

reveal_type(Sub.make_pair('yes'))  # N: Revealed type is "Tuple[__main__.Sub[builtins.str], __main__.Sub[builtins.str]]"
Sub[int].make_pair('no')  # E: Argument 1 to "make_pair" of "Base" has incompatible type "str"; expected "int"
[builtins fixtures/classmethod.pyi]

[case testSubclassingGenericSelfClassMethod_pep585]
# flags: --python-version 3.9
from typing import TypeVar

AT = TypeVar('AT', bound='A')

class A:
    @classmethod
    def from_config(cls: type[AT]) -> AT:
        ...

class B(A):
    @classmethod
    def from_config(cls: type[B]) -> B:
        return B()
[builtins fixtures/classmethod.pyi]

[case testSubclassingGenericSelfClassMethodOptional_pep585]
# flags: --strict-optional --python-version 3.9
from typing import TypeVar, Optional

AT = TypeVar('AT', bound='A')

class A:
    @classmethod
    def from_config(cls: type[AT]) -> Optional[AT]:
        return None

class B(A):
    @classmethod
    def from_config(cls: type[B]) -> Optional[B]:
        return B()
[builtins fixtures/classmethod.pyi]

[case testSubclassingGenericSelfClassMethodNonAnnotated_pep585]
# flags: --python-version 3.9
from typing import TypeVar

AT = TypeVar('AT', bound='A')

class A:
    @classmethod
    def from_config(cls: type[AT]) -> AT:
        ...

class B(A):
    @classmethod
    def from_config(cls) -> B:
        return B()
[builtins fixtures/classmethod.pyi]

-- Variants of tests in check-inference.test
-- -----------------------------------------

[case testInferringLvarTypesUnpackedFromIterableClassObjectWithGenericIter_pep585]
# flags: --python-version 3.9
from typing import Iterator, TypeVar

T = TypeVar("T")
class Meta(type):
    def __iter__(self: type[T]) -> Iterator[T]: ...
class Foo(metaclass=Meta): ...

A, B, C = Foo
reveal_type(A)  # N: Revealed type is "__main__.Foo"
reveal_type(B)  # N: Revealed type is "__main__.Foo"
reveal_type(C)  # N: Revealed type is "__main__.Foo"
[builtins fixtures/type.pyi]
[out]

-- Variants of tests in check-namedtuple.test
-- ------------------------------------------

[case testNamedTupleClassMethodWithGenericReturnValue_pep585]
# flags: --python-version 3.9
from typing import TypeVar, NamedTuple

T = TypeVar('T', bound='Parent')

class Parent(NamedTuple):
    x: str

    @classmethod
    def class_method(cls: type[T]) -> T:
        return cls(x='text')

class Child(Parent):
    pass

reveal_type(Child.class_method())  # N: Revealed type is "Tuple[builtins.str, fallback=__main__.Child]"
[builtins fixtures/classmethod.pyi]

-- Variants of tests in check-newsemanal.test
-- ------------------------------------------

[case testNewAnalyzerTypeVarBoundInCycle_pep585]
# flags: --python-version 3.9
import factory, box

[file factory.py]
from typing import Generic

from box import BoxT

class Factory(Generic[BoxT]):
    value: int

    def create(self, boxClass: type[BoxT]) -> BoxT:
        reveal_type(boxClass.create(self))  # N: Revealed type is "BoxT`1"
        return boxClass.create(self)

[file box.py]
from typing import TYPE_CHECKING, TypeVar

if TYPE_CHECKING:
    from factory import Factory

BoxT = TypeVar('BoxT', bound='Box')

class Box:
    @classmethod
    def create(cls: type[BoxT], f: Factory) -> BoxT:
        return cls(f.value)

    def __init__(self, value: int) -> None: ...
[builtins fixtures/classmethod.pyi]
[typing fixtures/typing-medium.pyi]

-- Variants of tests in check-overloading.test
-- -------------------------------------------

[case testOverloadAndClassTypes_pep585]
# flags: --python-version 3.9
from typing import overload, Union, TypeVar

T = TypeVar('T', bound='Parent')
class Parent:
    @overload
    @classmethod
    def foo(cls: type[T], x: int) -> type[T]: pass

    @overload
    @classmethod
    def foo(cls, x: str) -> str: pass

    @classmethod
    def foo(cls: type[T], x: Union[int, str]) -> Union[type[T], str]:
        reveal_type(cls.bar())    # N: Revealed type is "builtins.str"
        return cls

    @classmethod
    def bar(cls) -> str: pass

class Child(Parent):
    def child_only(self) -> int: pass

x: Union[int, str]
reveal_type(Parent.foo(3))                  # N: Revealed type is "Type[__main__.Parent]"
reveal_type(Child.foo(3))                   # N: Revealed type is "Type[__main__.Child]"
reveal_type(Child.foo("..."))               # N: Revealed type is "builtins.str"
reveal_type(Child.foo(x))                   # N: Revealed type is "Union[Type[__main__.Child], builtins.str]"
reveal_type(Child.foo(3)().child_only())    # N: Revealed type is "builtins.int"
[builtins fixtures/classmethod.pyi]

-- Variants of tests in check-protocols.test
-- -----------------------------------------

[case testInstantiationProtocolInTypeForClassMethods_pep585]
# flags: --python-version 3.9
from typing import Protocol

class Logger:
    @staticmethod
    def log(a: type[C]):
        pass
class C(Protocol):
    @classmethod
    def action(cls) -> None:
        cls() #OK for classmethods
        Logger.log(cls)  #OK for classmethods
[builtins fixtures/classmethod.pyi]

[case testIterableProtocolOnMetaclass_pep585]
# flags: --python-version 3.9
from typing import TypeVar, Iterator
T = TypeVar('T')

class EMeta(type):
    def __iter__(self: type[T]) -> Iterator[T]: pass

class E(metaclass=EMeta):
    pass

class C(E):
    pass

reveal_type(list(c for c in C))  # N: Revealed type is "builtins.list[__main__.C]"
reveal_type(list(C))  # N: Revealed type is "builtins.list[__main__.C]"
[builtins fixtures/list.pyi]

[case testProtocolClassObjectSelfTypeClassMethod_pep585]
# flags: --python-version 3.9
from typing import Protocol, TypeVar

T = TypeVar("T")
class P(Protocol):
    def foo(self) -> B: ...

class B:
    @classmethod
    def foo(cls: type[T]) -> T: ...
class C:
    @classmethod
    def foo(cls: type[T]) -> T: ...

def test(arg: P) -> None: ...
test(B)  # OK
test(C)  # E: Argument 1 to "test" has incompatible type "Type[C]"; expected "P" \
         # N: Following member(s) of "C" have conflicts: \
         # N:     Expected: \
         # N:         def foo() -> B \
         # N:     Got: \
         # N:         def foo() -> C
[builtins fixtures/classmethod.pyi]

[case testInferenceViaTypeTypeMetaclass_pep585]
# flags: --python-version 3.9
from typing import Iterator, Iterable, TypeVar

M = TypeVar("M")

class Meta(type):
    def __iter__(self: type[M]) -> Iterator[M]: ...
class Foo(metaclass=Meta): ...

T = TypeVar("T")
def test(x: Iterable[T]) -> T: ...

reveal_type(test(Foo))  # N: Revealed type is "__main__.Foo"
t_foo: type[Foo]
reveal_type(test(t_foo))  # N: Revealed type is "__main__.Foo"

TF = TypeVar("TF", bound=Foo)
def outer(cls: type[TF]) -> TF:
    reveal_type(test(cls))  # N: Revealed type is "TF`-1"
    return cls()

-- Variants of tests in check-selftype.test
-- ----------------------------------------

[case testSelfTypeClass_pep585]
# flags: --python-version 3.9
from typing import TypeVar

T = TypeVar('T', bound='A')

class A:
    @classmethod
    def new(cls: type[T]) -> T:
        return reveal_type(cls())  # N: Revealed type is "T`-1"

class B(A):
    pass

Q = TypeVar('Q', bound='C', covariant=True)
class C:
    def __init__(self, a: int) -> None: pass

    @classmethod
    def new(cls: type[Q]) -> Q:
        if cls:
            return cls(1)
        else:
            return cls()  # E: Missing positional argument "a" in call to "C"


reveal_type(A.new)  # N: Revealed type is "def () -> __main__.A"
reveal_type(B.new)  # N: Revealed type is "def () -> __main__.B"
reveal_type(A.new())  # N: Revealed type is "__main__.A"
reveal_type(B.new())  # N: Revealed type is "__main__.B"

[builtins fixtures/classmethod.pyi]

[case testSelfTypeRecursiveBinding_pep585]
# flags: --python-version 3.9
from typing import TypeVar, Callable

T = TypeVar('T', bound='A', covariant=True)
class A:
    # TODO: This is potentially unsafe, as we use T in an argument type
    def copy(self: T, factory: Callable[[T], T]) -> T:
        return factory(self)

    @classmethod
    def new(cls: type[T], factory: Callable[[T], T]) -> T:
        reveal_type(cls)   # N: Revealed type is "Type[T`-1]"
        reveal_type(cls())   # N: Revealed type is "T`-1"
        cls(2)  # E: Too many arguments for "A"
        return cls()

class B(A):
    pass

reveal_type(A().copy)  # N: Revealed type is "def (factory: def (__main__.A) -> __main__.A) -> __main__.A"
reveal_type(B().copy)  # N: Revealed type is "def (factory: def (__main__.B) -> __main__.B) -> __main__.B"
reveal_type(A.new)  # N: Revealed type is "def (factory: def (__main__.A) -> __main__.A) -> __main__.A"
reveal_type(B.new)  # N: Revealed type is "def (factory: def (__main__.B) -> __main__.B) -> __main__.B"

[builtins fixtures/classmethod.pyi]

[case testSelfTypeClone_pep585]
# flags: --python-version 3.9
from typing import TypeVar
T = TypeVar('T', bound='C')

class C:
    def copy(self: T) -> T:
        return self

    @classmethod
    def new(cls: type[T]) -> T:
        return cls()

class D(C): pass

reveal_type(D.new)  # N: Revealed type is "def () -> __main__.D"
reveal_type(D().new)  # N: Revealed type is "def () -> __main__.D"
reveal_type(D.new())  # N: Revealed type is "__main__.D"
reveal_type(D().new())  # N: Revealed type is "__main__.D"

Q = TypeVar('Q', bound=C)

def clone(arg: Q) -> Q:
    reveal_type(arg.copy)  # N: Revealed type is "def () -> Q`-1"
    reveal_type(arg.copy())  # N: Revealed type is "Q`-1"
    reveal_type(arg.new)  # N: Revealed type is "def () -> Q`-1"
    reveal_type(arg.new())  # N: Revealed type is "Q`-1"
    return arg.copy()

def make(cls: type[Q]) -> Q:
    reveal_type(cls.new)  # N: Revealed type is "def () -> Q`-1"
    reveal_type(cls().new)  # N: Revealed type is "def () -> Q`-1"
    reveal_type(cls().new())  # N: Revealed type is "Q`-1"
    return cls.new()

[builtins fixtures/classmethod.pyi]

[case testSelfTypeNonsensical_pep585]
# flags: --python-version 3.9
from typing import TypeVar

T = TypeVar('T', bound=str)
class A:
    def foo(self: T) -> T:   # E: The erased type of self "builtins.str" is not a supertype of its class "__main__.A"
        return self

    @classmethod
    def cfoo(cls: type[T]) -> T:  # E: The erased type of self "Type[builtins.str]" is not a supertype of its class "Type[__main__.A]"
        return cls()

Q = TypeVar('Q', bound='B')
class B:
    def foo(self: Q) -> Q:
        return self

    @classmethod
    def cfoo(cls: type[Q]) -> Q:
        return cls()

class C:
    def foo(self: C) -> C: return self

    @classmethod
    def cfoo(cls: type[C]) -> C:
        return cls()

class D:
    def foo(self: Q) -> Q:  # E: The erased type of self "__main__.B" is not a supertype of its class "__main__.D"
        return self

    @staticmethod
    def bar(self: str) -> str:
        return self

    @classmethod
    def cfoo(cls: type[Q]) -> Q:  # E: The erased type of self "Type[__main__.B]" is not a supertype of its class "Type[__main__.D]"
        return cls()

[builtins fixtures/classmethod.pyi]

[case testSelfTypeNew_pep585]
# flags: --python-version 3.9
from typing import TypeVar

T = TypeVar('T', bound='A')
class A:
    def __new__(cls: type[T]) -> T:
        return cls()

    def __init_subclass__(cls: type[T]) -> None:
        pass

class B:
    def __new__(cls: type[T]) -> T:  # E: The erased type of self "Type[__main__.A]" is not a supertype of its class "Type[__main__.B]"
        return cls()

    def __init_subclass__(cls: type[T]) -> None:  # E: The erased type of self "Type[__main__.A]" is not a supertype of its class "Type[__main__.B]"
        pass

class C:
    def __new__(cls: type[C]) -> C:
        return cls()

    def __init_subclass__(cls: type[C]) -> None:
        pass

class D:
    def __new__(cls: D) -> D:  # E: The erased type of self "__main__.D" is not a supertype of its class "Type[__main__.D]"
        return cls

    def __init_subclass__(cls: D) -> None:  # E: The erased type of self "__main__.D" is not a supertype of its class "Type[__main__.D]"
        pass

class E:
    def __new__(cls) -> E:
        reveal_type(cls)  # N: Revealed type is "Type[__main__.E]"
        return cls()

    def __init_subclass__(cls) -> None:
        reveal_type(cls)  # N: Revealed type is "Type[__main__.E]"

[case testSelfTypeRestrictedClassMethod_pep585]
# flags: --python-version 3.9
from typing import TypeVar, Generic

T = TypeVar('T')
class C(Generic[T]):
    @classmethod
    def from_item(cls: type[C[str]]) -> None: ...

class DI(C[int]): ...
class DS(C[str]): ...

DI().from_item()  # E: Invalid self argument "Type[DI]" to class attribute function "from_item" with type "Callable[[Type[C[str]]], None]"
DS().from_item()
DI.from_item()  # E: Invalid self argument "Type[DI]" to attribute function "from_item" with type "Callable[[Type[C[str]]], None]"
DS.from_item()
[builtins fixtures/classmethod.pyi]

[case testSelfTypeProtocolMetaclassMatch_pep585]
# flags: --python-version 3.9
from typing import TypeVar, Protocol

class HasX(Protocol):
    x: int

T = TypeVar('T', bound=HasX)

class Meta(type):
    def do_x(cls: type[T]) -> T:
        cls.x
        return cls()

class Good(metaclass=Meta):
    x: int
class Bad(metaclass=Meta):
    pass

Good.do_x()
Bad.do_x()  # E: Invalid self argument "Type[Bad]" to attribute function "do_x" with type "Callable[[Type[T]], T]"

[case testSelfTypeProtocolClassmethodMatch_pep585]
# flags: --python-version 3.9
from typing import TypeVar, Protocol

T = TypeVar('T')

class HasDoX(Protocol):
    @classmethod
    def do_x(cls: type[T]) -> T:
        ...

class Good:
    @classmethod
    def do_x(cls) -> 'Good':
        ...

class Bad:
    @classmethod
    def do_x(cls) -> Good:
        ...

good: HasDoX = Good()
bad: HasDoX = Bad()
[builtins fixtures/classmethod.pyi]
[out]
main:22: error: Incompatible types in assignment (expression has type "Bad", variable has type "HasDoX")
main:22: note: Following member(s) of "Bad" have conflicts:
main:22: note:     Expected:
main:22: note:         def do_x(cls) -> Bad
main:22: note:     Got:
main:22: note:         def do_x(cls) -> Good

[case testSelfTypeOnUnionClassMethod_pep585]
# flags: --python-version 3.9
from typing import TypeVar, Union

T = TypeVar('T')

class A:
    same: int

class C:
    @classmethod
    def same(cls: type[T]) -> T: ...

x: Union[A, C]
reveal_type(x.same)  # N: Revealed type is "Union[builtins.int, def () -> __main__.C]"
[builtins fixtures/classmethod.pyi]

[case SelfTypeOverloadedClassMethod_pep585]
# flags: --python-version 3.9
from lib import Base
from typing import overload, Tuple

class Sub(Base):
    @overload
    @classmethod
    def make(cls) -> Sub: ...
    @overload
    @classmethod
    def make(cls, num: int) -> Tuple[Sub, ...]: ...
    @classmethod
    def make(cls, num=1):
        ...

class Other(Base): ...
class Double(Sub): ...

reveal_type(Other.make())  # N: Revealed type is "__main__.Other"
reveal_type(Other.make(3))  # N: Revealed type is "builtins.tuple[__main__.Other, ...]"
reveal_type(Double.make())  # N: Revealed type is "__main__.Sub"
reveal_type(Double.make(3))  # N: Revealed type is "builtins.tuple[__main__.Sub, ...]"
[file lib.pyi]
from typing import overload, TypeVar, Tuple

T = TypeVar('T', bound=Base)

class Base:
    @overload
    @classmethod
    def make(cls: type[T]) -> T: ...
    @overload
    @classmethod
    def make(cls: type[T], num: int) -> Tuple[T, ...]: ...
[builtins fixtures/classmethod.pyi]

[case testSelfTypeClassMethodOnUnion_pep585]
# flags: --python-version 3.9
from typing import Union, TypeVar

T = TypeVar('T')

class A:
    @classmethod
    def meth(cls: type[T]) -> T: ...
class B(A): ...
class C(A): ...

t: type[Union[B, C]]
reveal_type(t.meth)  # N: Revealed type is "Union[def () -> __main__.B, def () -> __main__.C]"
x = t.meth()
reveal_type(x)  # N: Revealed type is "Union[__main__.B, __main__.C]"
[builtins fixtures/classmethod.pyi]

[case testSelfTypeClassMethodOnUnionGeneric_pep585]
# flags: --python-version 3.9
from typing import Union, TypeVar, Generic

T = TypeVar('T')
S = TypeVar('S')

class A(Generic[T]):
    @classmethod
    def meth(cls: type[S]) -> S: ...

t: type[Union[A[int], A[str]]]
x = t.meth()
reveal_type(x)  # N: Revealed type is "Union[__main__.A[builtins.int], __main__.A[builtins.str]]"
[builtins fixtures/classmethod.pyi]

[case testSelfTypeClassMethodOnUnionList_pep585]
# flags: --python-version 3.9
from typing import Union, TypeVar, List

T = TypeVar('T')

class A:
    @classmethod
    def meth(cls: type[T]) -> List[T]: ...
class B(A): ...
class C(A): ...

t: type[Union[B, C]]
x = t.meth()[0]
reveal_type(x)  # N: Revealed type is "Union[__main__.B, __main__.C]"
[builtins fixtures/isinstancelist.pyi]

[case testSelfTypeClassMethodOverloadedOnInstance_pep585]
# flags: --python-version 3.9 --no-strict-optional
from typing import Optional, TypeVar, overload, Union

Id = int

A = TypeVar("A", bound='AClass')

class AClass:
    @overload
    @classmethod
    def delete(cls: type[A], id: Id, id2: Id) -> Optional[int]: ...

    @overload
    @classmethod
    def delete(cls: type[A], id: A, id2: None = None) -> Optional[int]: ...

    @classmethod
    def delete(cls: type[A], id: Union[A, Id], id2: Optional[Id] = None) -> Optional[int]:
        ...

def foo(x: type[AClass]) -> None:
    reveal_type(x.delete)  # N: Revealed type is "Overload(def (id: builtins.int, id2: builtins.int) -> builtins.int, def (id: __main__.AClass, id2: None =) -> builtins.int)"
    y = x()
    reveal_type(y.delete)  # N: Revealed type is "Overload(def (id: builtins.int, id2: builtins.int) -> builtins.int, def (id: __main__.AClass, id2: None =) -> builtins.int)"
    y.delete(10, 20)
    y.delete(y)

def bar(x: AClass) -> None:
    reveal_type(x.delete)  # N: Revealed type is "Overload(def (id: builtins.int, id2: builtins.int) -> builtins.int, def (id: __main__.AClass, id2: None =) -> builtins.int)"
    x.delete(10, 20)
[builtins fixtures/classmethod.pyi]

[case testSelfTypeGenericClassNoClashClassMethod_pep585]
# flags: --python-version 3.9
from typing import TypeVar, Generic

M = TypeVar("M")
T = TypeVar("T")
S = TypeVar("S")

class Descriptor(Generic[M]): ...

class BaseWrapper(Generic[M]):
    @classmethod
    def create_wrapper(cls: type[T], metric_descriptor: Descriptor[M]) -> T: ...
class SubWrapper(BaseWrapper[M]): ...

def build_wrapper(descriptor: Descriptor[M]) -> BaseWrapper[M]:
    wrapper_cls: type[BaseWrapper[M]]
    return wrapper_cls.create_wrapper(descriptor)

def build_sub_wrapper(descriptor: Descriptor[S]) -> SubWrapper[S]:
    wrapper_cls: type[SubWrapper[S]]
    x = wrapper_cls.create_wrapper(descriptor)
    reveal_type(x)  # N: Revealed type is "__main__.SubWrapper[S`-1]"
    return x
[builtins fixtures/classmethod.pyi]

[case testSelfTypeGenericClassNoClashClassMethodClassObject_pep585]
# flags: --python-version 3.9
from typing import TypeVar, Generic

M = TypeVar("M")
T = TypeVar("T")

class Descriptor(Generic[M]): ...

class BaseWrapper(Generic[M]):
    @classmethod
    def create_wrapper(cls: type[T], metric_descriptor: Descriptor[M]) -> T: ...
class SubWrapper(BaseWrapper[M]): ...

def build_wrapper(descriptor: Descriptor[M]) -> BaseWrapper[M]:
    return BaseWrapper.create_wrapper(descriptor)

def build_sub_wrapper(descriptor: Descriptor[M]) -> SubWrapper[M]:
    x = SubWrapper.create_wrapper(descriptor)
    reveal_type(x)  # N: Revealed type is "__main__.SubWrapper[M`-1]"
    return x

def build_wrapper_non_gen(descriptor: Descriptor[int]) -> BaseWrapper[str]:
    return BaseWrapper.create_wrapper(descriptor)  # E: Argument 1 to "create_wrapper" of "BaseWrapper" has incompatible type "Descriptor[int]"; expected "Descriptor[str]"

def build_sub_wrapper_non_gen(descriptor: Descriptor[int]) -> SubWrapper[str]:
    return SubWrapper.create_wrapper(descriptor)  # E: Argument 1 to "create_wrapper" of "BaseWrapper" has incompatible type "Descriptor[int]"; expected "Descriptor[str]"
[builtins fixtures/classmethod.pyi]

[case testTypingSelfRedundantAllowed_pep585]
# flags: --python-version 3.9
from typing import Self

class C:
    def f(self: Self) -> Self:
        d: Defer
        class Defer: ...
        return self

    @classmethod
    def g(cls: type[Self]) -> Self:
        d: DeferAgain
        class DeferAgain: ...
        return cls()
[builtins fixtures/classmethod.pyi]

[case testTypingSelfRedundantWarning_pep585]
# flags: --python-version 3.9
# mypy: enable-error-code="redundant-self"

from typing import Self

class C:
    def copy(self: Self) -> Self:  # E: Redundant "Self" annotation for the first method argument
        d: Defer
        class Defer: ...
        return self

    @classmethod
    def g(cls: type[Self]) -> Self:  # E: Redundant "Self" annotation for the first method argument
        d: DeferAgain
        class DeferAgain: ...
        return cls()
[builtins fixtures/classmethod.pyi]

-- Variants of tests in check-super.test
-- -------------------------------------

[case testSuperClassGetItem_pep585]
# flags: --python-version 3.9
from typing import TypeVar, Any

T = TypeVar("T", bound="B")

class A:
    def __class_getitem__(cls, item) -> None: pass

class B(A):
    def __class_getitem__(cls: type[T], item: Any) -> None:
        super(B, cls).__class_getitem__(item)

[case testSuperSelfTypeClassMethod_pep585]
# flags: --python-version 3.9
from typing import TypeVar

T = TypeVar("T", bound="A")

class A:
    @classmethod
    def foo(cls: type[T]) -> T: ...

class B(A):
    @classmethod
    def foo(cls: type[T]) -> T:
        reveal_type(super().foo())  # N: Revealed type is "T`-1"
        return super().foo()
[builtins fixtures/classmethod.pyi]

-- Variants of tests in check-type-aliases.test
-- --------------------------------------------

[case testAliasToClassMethod_pep585]
# flags: --python-version 3.9
from typing import TypeVar, Generic, Union

T = TypeVar('T', bound='C')

MYPY = False
if MYPY:
    test = classmethod

class C:
    @test
    def meth(cls: type[T], arg: int) -> Union[T, int]: ...

class D(C): ...

reveal_type(D.meth(1))  # N: Revealed type is "Union[__main__.D, builtins.int]"
reveal_type(D().meth(1))  # N: Revealed type is "Union[__main__.D, builtins.int]"
[builtins fixtures/classmethod.pyi]
[out]

-- Variants of tests in check-typevar-values.test
-- ----------------------------------------------

[case testSelfTypeVarIndexExpr_pep585]
# flags: --python-version 3.9
from typing import TypeVar, Union
from typing_extensions import TypedDict

T = TypeVar("T", bound="Indexable")

class Indexable:
    def __init__(self, index: str) -> None:
        self.index = index

    def __getitem__(self: T, index: str) -> T:
        return self._new_instance(index)

    @classmethod
    def _new_instance(cls: type[T], index: str) -> T:
        return cls("foo")

    def m(self: T) -> T:
        return self["foo"]
[builtins fixtures/classmethod.pyi]
