[case testSelfTypeInstance]
from typing import TypeVar

T = TypeVar('T')

class A:
    def copy(self: T) -> T: ...

class B(A):
    pass

reveal_type(A().copy)  # E: Revealed type is 'def () -> __main__.A'
reveal_type(B().copy)  # E: Revealed type is 'def () -> __main__.B'
reveal_type(A().copy())  # E: Revealed type is '__main__.A'
reveal_type(B().copy())  # E: Revealed type is '__main__.B'
# FIX: Why partial type?
#reveal_type(A.copy(A()))  E: Revealed type is '__main__.A'
#reveal_type(B.copy(B()))  E: Revealed type is '__main__.B'


[case testSelfTypeReturn]
# flags: --hide-error-context
from typing import TypeVar, Type

T = TypeVar('T')

def _type(self: T) -> Type[T]: ...

class A:
    def copy(self: T) -> T:
        if B():
            return A()  # E: Incompatible return value type (got "A", expected "T")
        elif A():
            return B()  # E: Incompatible return value type (got "B", expected "T")
        return _type(self)()

class B(A):
    pass

class C:
    def __init__(self, a: int) -> None: pass

    def copy(self: T) -> T:
        if self:
            return _type(self)(1)
        else:
            return _type(self)()  # E: Too few arguments for "C"



[case testSelfTypeClass]
# flags: --hide-error-context
from typing import TypeVar, Type

T = TypeVar('T')

class A:
    @classmethod
    def new(cls: Type[T]) -> T:
        return cls()

class B(A):
    pass

class C:
    def __init__(self, a: int) -> None: pass

    @classmethod
    def new(cls: Type[T]) -> T:
        if cls:
            return cls(1)
        else:
            return cls()  # E: Too few arguments for "C"


reveal_type(A.new)  # E: Revealed type is 'def () -> __main__.A'
reveal_type(B.new)  # E: Revealed type is 'def () -> __main__.B'
reveal_type(A.new())  # E: Revealed type is '__main__.A'
reveal_type(B.new())  # E: Revealed type is '__main__.B'

[builtins fixtures/classmethod.pyi]

[case testSelfTypeOverride]
from typing import TypeVar, cast
 
T = TypeVar('T')
 
class A:
    def copy(self: T) -> T: ...

class B(A):
    pass

class C(A):
    def copy(self: T) -> T: ...

reveal_type(C().copy)  # E: Revealed type is 'def () -> __main__.C'
reveal_type(C().copy())  # E: Revealed type is '__main__.C'
reveal_type(cast(A, C()).copy)  # E: Revealed type is 'def () -> __main__.A'
reveal_type(cast(A, C()).copy())  # E: Revealed type is '__main__.A' 

[case testSelfTypeSuper]
# flags: --hide-error-context
from typing import TypeVar, cast
 
T = TypeVar('T')
 
class A:
    def copy(self: T) -> T: ...

class B(A):
    def copy(self: T) -> T:
        reveal_type(self)  # E: Revealed type is 'T`-1'
        reveal_type(super().copy)  # E: Revealed type is 'def () -> T`-1'
        return super().copy()

[case testSelfTypeRecursiveBinding]
# flags: --hide-error-context
from typing import TypeVar, Callable, Type
 
T = TypeVar('T')
class A:
    def copy(self: T, factory: Callable[[T], T]) -> T:
        return factory(self)

    @classmethod
    def new(cls: Type[T], factory: Callable[[T], T]) -> T:
        reveal_type(cls)   # E: Revealed type is 'Type[T`-1]'
        reveal_type(cls())   # E: Revealed type is 'T`-1'
        cls(2)  # E: Too many arguments for "A"
        return cls()

class B(A):
    pass

reveal_type(A().copy) # E: Revealed type is 'def (factory: def (__main__.A) -> __main__.A) -> __main__.A'
reveal_type(B().copy) # E: Revealed type is 'def (factory: def (__main__.B) -> __main__.B) -> __main__.B'
reveal_type(A.new) # E: Revealed type is 'def (factory: def (__main__.A) -> __main__.A) -> __main__.A'
reveal_type(B.new) # E: Revealed type is 'def (factory: def (__main__.B) -> __main__.B) -> __main__.B'

[builtins fixtures/classmethod.pyi]

[case testSelfTypeBound]
# flags: --hide-error-context
from typing import TypeVar, Callable, cast
 
T = TypeVar('T')

class A:
    def copy(self: T) -> T:
        ...

class C(A):    
    def copy(self: C) -> C:  # E: Return type of "copy" incompatible with supertype "A"
        ...

class D(A):    
    def copy(self: A) -> A:  # E: Return type of "copy" incompatible with supertype "A"
        ...

class E(A):    
    def copy(self: A) -> E:  # E: Return type of "copy" incompatible with supertype "A"
        ...

class B(A):
    x = 1
    def copy(self: T) -> T:
        reveal_type(self.x)  # E: Revealed type is 'builtins.int'
        return cast(T, None)

-- # TODO: fail for this
-- [case testSelfTypeBare]
-- class E:
--     def copy(self: T, other: T) -> T: ...

[case testSelfTypeClone]
# flags: --hide-error-context
from typing import TypeVar, Type

T = TypeVar('T', bound='C')

class C:
    def copy(self: T) -> T:
        return self

    @classmethod
    def new(cls: Type[T]) -> T:
        return cls()

def clone(arg: T) -> T:
    reveal_type(arg.copy)  # E: Revealed type is 'def () -> T`-1'
    return arg.copy()


def make(cls: Type[T]) -> T:
    reveal_type(cls.new)  # E: Revealed type is 'def () -> T`-1'
    return cls.new()

[builtins fixtures/classmethod.pyi]