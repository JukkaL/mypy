[case testPerFileIncompleteDefsBasicPyprojectTOML]
# flags: --config-file tmp/pyproject.toml
import standard, incomplete

[file standard.py]
def incomplete(x) -> int:
    return 0
[file incomplete.py]
def incomplete(x) -> int:  # E: Function is missing a type annotation for one or more arguments
    return 0
[file pyproject.toml]
\[tool.mypy]
disallow_incomplete_defs = false
\[tool.mypy-incomplete]
disallow_incomplete_defs = true

[case testPerFileStrictOptionalBasicPyprojectTOML]
# flags: --config-file tmp/pyproject.toml
import standard, optional

[file standard.py]
x = 0
if int():
    x = None
[file optional.py]
x = 0
if int():
    x = None  # E: Incompatible types in assignment (expression has type "None", variable has type "int")

[file pyproject.toml]
\[tool.mypy]
strict_optional = false
\[tool.mypy-optional]
strict_optional = true

[case testPerFileStrictOptionalBasicImportStandardPyprojectTOML]
# flags: --config-file tmp/pyproject.toml
import standard, optional

[file standard.py]
from typing import Optional
def f(x: int) -> None: pass
an_int = 0  # type: int
optional_int = None  # type: Optional[int]
f(an_int)  # ints can be used as ints
f(optional_int)  # optional ints can be used as ints in this file

[file optional.py]
import standard
def f(x: int) -> None: pass
standard.an_int = None  # E: Incompatible types in assignment (expression has type "None", variable has type "int")
standard.optional_int = None  # OK -- explicitly declared as optional
f(standard.an_int)  # ints can be used as ints
f(standard.optional_int)  # E: Argument 1 to "f" has incompatible type "None"; expected "int"

[file pyproject.toml]
\[tool.mypy]
strict_optional = false
\[tool.mypy-optional]
strict_optional = true

[case testPerFileStrictOptionalBasicImportOptionalPyprojectTOML]
# flags: --config-file tmp/pyproject.toml
import standard, optional

[file standard.py]
import optional
def f(x: int) -> None: pass
f(optional.x)  # OK -- in non-strict Optional context
f(optional.y)  # OK -- in non-strict Optional context

[file optional.py]
from typing import Optional
def f(x: int) -> None: pass
x = 0  # type: Optional[int]
y = None  # type: None

[file pyproject.toml]
\[tool.mypy]
strict_optional = false
\[tool.mypy-optional]
strict_optional = true

[case testPerFileStrictOptionalListItemImportOptionalPyprojectTOML]
# flags: --config-file tmp/pyproject.toml
import standard, optional

[file standard.py]
import optional
from typing import List
def f(x: List[int]) -> None: pass
f(optional.x)  # OK -- in non-strict Optional context
f(optional.y)  # OK -- in non-strict Optional context

[file optional.py]
from typing import Optional, List
def f(x: List[int]) -> None: pass
x = []  # type: List[Optional[int]]
y = []  # type: List[int]

[file pyproject.toml]
\[tool.mypy]
strict_optional = false
\[tool.mypy-optional]
strict_optional = true
[builtins fixtures/list.pyi]

[case testPerFileStrictOptionalNoneArgumentsPyprojectTOML]
# flags: --config-file tmp/pyproject.toml
import standard, optional

[file standard.py]
def f(x: int = None) -> None: pass

[file optional.py]
import standard
def f(x: int = None) -> None: pass
standard.f(None)

[file pyproject.toml]
\[tool.mypy]
strict_optional = false
\[tool.mypy-optional]
strict_optional = true

[case testAlwaysTrueAlwaysFalseConfigFilePyprojectTOML]
# flags: --config-file tmp/pyproject.toml
from somewhere import YOLO, BLAH
if not YOLO:
    1+()
if BLAH:
    1+()
[file pyproject.toml]
\[tool.mypy]
ignore_missing_imports = true
always_true = [
    "YOLO1",
    "YOLO"
]
always_false = [
    "BLAH",
    "BLAH1"
]
[builtins fixtures/bool.pyi]

[case testDisableErrorCodeConfigFilePyprojectTOML]
# flags: --config-file tmp/pyproject.toml --disallow-untyped-defs
import foo
def bar():
    pass
[file pyproject.toml]
\[tool.mypy]
disable_error_code = [
    "import",
    "no-untyped-def"
]

[case testStrictInConfigAnyGenericPyprojectTOML]
# flags: --config-file tmp/pyproject.toml
from typing import TypeVar, Generic

T = TypeVar('T')

class A(Generic[T]):
    pass

def f(c: A) -> None:  # E: Missing type parameters for generic type "A"
    pass
[file pyproject.toml]
\[tool.mypy]
strict = true
[out]

[case testStrictFalseInConfigAnyGenericPyprojectTOML]
# flags: --config-file tmp/pyproject.toml
from typing import TypeVar, Generic

T = TypeVar('T')

class A(Generic[T]):
    pass

def f(c: A) -> None:
    pass
[file pyproject.toml]
\[tool.mypy]
strict = false
[out]

[case testStrictEqualityPerFilePyprojectTOML]
# flags: --config-file tmp/pyproject.toml
import b
42 == 'no'  # E: Non-overlapping equality check (left operand type: "Literal[42]", right operand type: "Literal['no']")
[file b.py]
42 == 'no'
[file pyproject.toml]
\[tool.mypy]
strict_equality = true
\[tool.mypy-b]
strict_equality = false
[builtins fixtures/bool.pyi]

[case testNoImplicitReexportPyprojectTOML]
# flags: --config-file tmp/pyproject.toml
from other_module_2 import a

[file other_module_1.py]
a = 5

[file other_module_2.py]
from other_module_1 import a

[file pyproject.toml]
\[tool.mypy]
implicit_reexport = true
\[tool.mypy-other_module_2]
implicit_reexport = false
[out]
main:2: error: Module "other_module_2" has no attribute "a"

[case testDisallowSubclassingAnyPyprojectTOML]
# flags: --config-file tmp/pyproject.toml
import m
import y

[file m.py]
from typing import Any

x = None  # type: Any

class ShouldBeFine(x): ...

[file y.py]
from typing import Any

x = None  # type: Any

class ShouldNotBeFine(x): ...  # E: Class cannot subclass 'x' (has type 'Any')

[file pyproject.toml]
\[tool.mypy]
disallow_subclassing_any = true
\[tool.mypy-m]
disallow_subclassing_any = false

[case testNoImplicitOptionalPerModulePyprojectTOML]
# flags: --config-file tmp/pyproject.toml
import m

[file m.py]
def f(a: str = None) -> int:
    return 0

[file pyproject.toml]
\[tool.mypy]
no_implicit_optional = true
\[tool.mypy-m]
no_implicit_optional = false

[case testNoImplicitOptionalPerModulePython2PyprojectTOML]
# flags: --config-file tmp/pyproject.toml --python-version 2.7
import m

[file m.py]
def f(a = None):
    # type: (str) -> int
    return 0

[file pyproject.toml]
\[tool.mypy]
no_implicit_optional = true
\[tool.mypy-m]
no_implicit_optional = false

[case testDisableErrorCodePyprojectTOML]
# flags: --disable-error-code attr-defined
x = 'should be fine'
x.trim()
