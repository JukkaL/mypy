-- Test cases for warning generation.

-- Redundant casts
-- ---------------

[case testRedundantCast]
# flags: --warn-redundant-casts
from typing import cast
a = 1
b = cast(str, a)
c = cast(int, a)
[out]
main:5: note: Redundant cast to "int"

[case testRedundantCastWithIsinstance]
# flags: --warn-redundant-casts
from typing import cast, Union
x = 1  # type: Union[int, str]
if isinstance(x, str):
    cast(str, x)
[builtins fixtures/isinstance.pyi]
[out]
main:5: note: Redundant cast to "str"

[case testCastToSuperclassNotRedundant]
# flags: --warn-redundant-casts
from typing import cast, TypeVar, List
T = TypeVar('T')
def add(xs: List[T], ys: List[T]) -> List[T]: pass
class A: pass
class B(A): pass
a = A()
b = B()
# Without the cast, the following line would fail to type check.
c = add([cast(A, b)], [a])
[builtins fixtures/list.pyi]


-- Unused 'type: ignore' comments
-- ------------------------------

[case testUnusedTypeIgnore]
# flags: --warn-unused-ignores
a = 1
a = 'a' # type: ignore
a = 2 # type: ignore # N: unused 'type: ignore' comment
a = 'b' # E: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testUnusedTypeIgnoreImport]
# flags: --warn-unused-ignores
import banana # type: ignore
import m # type: ignore
from m import * # type: ignore
[file m.py]
pass
[out]
main:3: note: unused 'type: ignore' comment
main:4: note: unused 'type: ignore' comment


-- No return
-- ---------

[case testNoReturn]
# flags: --warn-no-return
def f() -> int:
    pass

def g() -> int:
    if bool():
        return 1
[builtins fixtures/list.pyi]
[out]
main:5: error: Missing return statement

[case testNoReturnWhile]
# flags: --warn-no-return
def h() -> int:
    while True:
        if bool():
            return 1

def i() -> int:
    while 1:
        if bool():
            return 1
        if bool():
            break

def j() -> int:
    while 1:
        if bool():
            return 1
        if bool():
            continue
[builtins fixtures/list.pyi]
[out]
main:7: error: Missing return statement

[case testNoReturnExcept]
# flags: --warn-no-return
def f() -> int:
    try:
        return 1
    except:
        pass
def g() -> int:
    try:
        pass
    except:
        return 1
    else:
        return 1
def h() -> int:
    try:
        pass
    except:
        pass
    else:
        pass
    finally:
        return 1
[builtins fixtures/exception.pyi]
[out]
main:2: error: Missing return statement

[case testNoReturnEmptyBodyWithDocstring]
def f() -> int:
    """Return the number of peppers."""
    # This might be an @abstractmethod, for example
    pass
[out]


-- Returning Any
-- -------------

[case testReturnAnyFromTypedFunction]
# flags: --warn-return-any
from typing import Any
def g() -> Any: pass
def f() -> int: return g()
[out]
main:4: warning: Returning Any from function declared to return "int"

[case testReturnAnyForNotImplementedInBinaryMagicMethods]
# flags: --warn-return-any
from typing import Any
class A:
    def __init__(self, x: Any) -> None:
        self.x = x
    def __eq__(self, other: Any) -> bool:
        if self.__class__ is other.__class__:
            return bool(self.x == other.x)
        return NotImplemented
    def __lt__(self, other: Any) -> bool: return NotImplemented
    def __gt__(self, other: Any) -> bool: return NotImplemented
    def __le__(self, other: Any) -> bool: return NotImplemented
    def __ge__(self, other: Any) -> bool: return NotImplemented
    def __ne__(self, other: Any) -> bool:
        # The logic here is similar to __eq__, except the
        # "return" is inside the if-then-else. The intention
        # is to also verify that both ways of inferring
        # Union[bool, type(NotImplemented)] are checked.
        if self.__class__ is other.__class__:
            return bool(self.x != other.x)
        else:
            return NotImplemented
# TODO: If the programmer specifies "-> Union[bool, type(NotImplemented)]",
#       mypy suggests changing this to "-> Union[bool, type[NotImplemented]]",
#       which gives a run-time error (issue #4767)
[builtins fixtures/notimplemented.pyi]
[out]

[case testReturnNotImplementedAllMagicMethods]
# flags: --warn-return-any
from typing import Any
class A:
    # The commented-out items give a warning: Returning Any from function declared to return "A" 
    # def __abs__(self) -> 'A': return NotImplemented
    def __add__(self, other: Any) -> 'A': return NotImplemented
    def __and__(self, other: Any) -> 'A': return NotImplemented
    # def __complex__(self) -> 'A': return NotImplemented
    # def __concat__(self, other: Any) -> 'A': return NotImplemented
    # def __contains__(self, other: Any) -> 'A': return NotImplemented
    # def __call__(self, *args, **kwargs) -> Any: return NotImplemented  # <======  crashes
    # def __del__(self) -> None: return NotImplemented  # Returning Any fromfunction declared to return "None"
    def __delitem__(self, other: Any) -> 'A': return NotImplemented
    def __eq__(self, other: Any) -> bool: return NotImplemented
    # def __float__(self) -> 'A': return NotImplemented
    def __floordiv__(self, other: Any) -> 'A': return NotImplemented
    def __ge__(self, other: Any) -> bool: return NotImplemented
    def __getitem__(self, other: Any) -> 'A': return NotImplemented
    def __gt__(self, other: Any) -> bool: return NotImplemented
    def __iadd__(self, other: Any) -> 'A': return NotImplemented
    def __iand__(self, other: Any) -> 'A': return NotImplemented
    def __iconcat__(self, other: Any) -> 'A': return NotImplemented
    def __ifloordiv__(self, other: Any) -> 'A': return NotImplemented
    def __ilshift__(self, other: Any) -> 'A': return NotImplemented
    # def __int__(self) -> 'A': return NotImplemented
    # def __imatmul__(self, other: Any) -> 'A': return NotImplemented
    # def __imod__(self, other: Any) -> 'A': return NotImplemented
    def __imul__(self, other: Any) -> 'A': return NotImplemented
    # def __index__(self) -> 'A': return NotImplemented
    # def __inv__(self) -> 'A': return NotImplemented
    # def __invert__(self) -> 'A': return NotImplemented
    def __ior__(self, other: Any) -> 'A': return NotImplemented
    def __ipow__(self, other: Any) -> 'A': return NotImplemented
    def __irshift__(self, other: Any) -> 'A': return NotImplemented
    def __isub__(self, other: Any) -> 'A': return NotImplemented
    def __itruediv__(self, other: Any) -> 'A': return NotImplemented
    def __ixor__(self, other: Any) -> 'A': return NotImplemented
    def __le__(self, other: Any) -> bool: return NotImplemented
    def __lshift__(self, other: Any) -> 'A': return NotImplemented
    def __lt__(self, other: Any) -> bool: return NotImplemented
    # def __matmul__(self, other: Any) -> 'A': return NotImplemented
    # def __mod__(self, other: Any) -> 'A': return NotImplemented
    def __mul__(self, other: Any) -> 'A': return NotImplemented
    def __ne__(self, other: Any) -> bool: return NotImplemented
    # def __neg__(self) -> 'A': return NotImplemented
    # def __not__(self) -> 'A': return NotImplemented
    def __or__(self, other: Any) -> 'A': return NotImplemented
    # def __pos__(self) -> 'A': return NotImplemented
    def __pow__(self, other: Any) -> 'A': return NotImplemented
    def __rshift__(self, other: Any) -> 'A': return NotImplemented
    def __setitem__(self, other: Any) -> 'A': return NotImplemented
    def __sub__(self, other: Any) -> 'A': return NotImplemented
    def __truediv__(self, other: Any) -> 'A': return NotImplemented
    def __xor__(self, other: Any) -> 'A': return NotImplemented
    # # The "reverse" methods:
    def __radd__(self, other: Any) -> 'A': return NotImplemented
    def __rsub__(self, other: Any) -> 'A': return NotImplemented
    def __rmul__(self, other: Any) -> 'A': return NotImplemented
    def __rmatmul__(self, other: Any) -> 'A': return NotImplemented
    def __rtruediv__(self, other: Any) -> 'A': return NotImplemented
    def __rfloordiv__(self, other: Any) -> 'A': return NotImplemented
    def __rmod__(self, other: Any) -> 'A': return NotImplemented
    # def __rdivmod__(self, other: Any) -> 'A': return NotImplemented
    def __rpow__(self, other: Any) -> 'A': return NotImplemented
    def __rlshift__(self, other: Any) -> 'A': return NotImplemented
    def __rrshift__(self, other: Any) -> 'A': return NotImplemented
    def __rand__(self, other: Any) -> 'A': return NotImplemented
    def __rxor__(self, other: Any) -> 'A': return NotImplemented
    def __ror__(self, other: Any) -> 'A': return NotImplemented
[builtins fixtures/notimplemented.pyi]
[out]

[case testReturnAnyForNotImplementedInNormalMethods]
# flags: --warn-return-any
class A:
    def some(self) -> bool: return NotImplemented
[builtins fixtures/notimplemented.pyi]
[out]
main:3: warning: Returning Any from function declared to return "bool"

[case testReturnAnyFromTypedFunctionWithSpecificFormatting]
# flags: --warn-return-any
from typing import Any, Tuple
typ = Tuple[int, int, int, int, int, int, int, int, int, int, int, int, int,
            int, int, int, int, int, int, int, int, int, int, int, int, int,
            int, int, int, int, int, int, int, int, int, int, int, int, int,
            int, int, int, int, int, int, int, int, int, int, int, int, int,
            int, int, int, int, int, int, int, int, int, int, int, int, int,
            int, int, int, int, int, int, int, int, int, int, int, int, int,
            int, int, int, int, int, int, int, int, int, int, int, int, int]
def g() -> Any: pass
def f() -> typ: return g()
[out]
main:11: warning: Returning Any from function declared to return <tuple: 91 items>

[case testReturnAnySilencedFromTypedFunction]
# flags: --warn-return-any
from typing import Any
def g() -> Any: pass
def f() -> int:
    result = g() # type: int
    return result
[out]

[case testReturnAnyFromUntypedFunction]
# flags: --warn-return-any
from typing import Any
def g() -> Any: pass
def f(): return g()
[out]

[case testReturnAnyFromAnyTypedFunction]
# flags: --warn-return-any
from typing import Any
def g() -> Any: pass
def f() -> Any: return g()
[out]

[case testOKReturnAnyIfProperSubtype]
# flags: --warn-return-any --strict-optional
from typing import Any, Optional

class Test(object):

    def __init__(self) -> None:
        self.attr = "foo"  # type: Any

    def foo(self, do_it: bool) -> Optional[Any]:
        if do_it:
            return self.attr  # Should not warn here
        else:
            return None
[builtins fixtures/list.pyi]
[out]

[case testReturnAnyDeferred]
# flags: --warn-return-any
def foo(a1: A) -> int:
    if a1._x:
        return 1
    n = 1
    return n

class A:
    def __init__(self, x: int) -> None:
        self._x = x
