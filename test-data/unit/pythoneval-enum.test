-- Test cases for type checking mypy programs using full stubs and running
-- using CPython.
--
-- These are mostly regression tests -- no attempt is made to make these
-- complete.
--
-- This test file checks Enum

[case testEnumBasics]
from enum import Enum
class Medal(Enum):
    gold = 1
    silver = 2
    bronze = 3
m = Medal.gold
m = 1
[out]
_program.py:7: error: Incompatible types in assignment (expression has type "int", variable has type "Medal")

[case testEnumNameAndValue]
from enum import Enum
class Truth(Enum):
    true = True
    false = False
x = ''
x = Truth.true.name
print(Truth.true.name)
print(Truth.false.value)
[out]
true
False

[case testEnumUnique]
import enum
@enum.unique
class E(enum.Enum):
    x = 1
    y = 1  # NOTE: This duplicate value is not detected by mypy at the moment
x = 1
x = E.x
[out]
_program.py:7: error: Incompatible types in assignment (expression has type "E", variable has type "int")

[case testIntEnum_assignToIntVariable]
from enum import IntEnum
class N(IntEnum):
    x = 1
    y = 1
n = 1
n = N.x  # Subclass of int, so it's okay
s = ''
s = N.y
[out]
_program.py:8: error: Incompatible types in assignment (expression has type "N", variable has type "str")

[case testIntEnum_functionTakingIntEnum]
from enum import IntEnum
class SomeIntEnum(IntEnum):
    x = 1
def takes_some_int_enum(n: SomeIntEnum):
    pass
takes_some_int_enum(SomeIntEnum.x)
takes_some_int_enum(1)  # Error
takes_some_int_enum(SomeIntEnum(1))  # How to deal with the above
[out]
_program.py:7: error: Argument 1 to "takes_some_int_enum" has incompatible type "int"; expected "SomeIntEnum"

[case testIntEnum_functionTakingInt]
from enum import IntEnum
class SomeIntEnum(IntEnum):
    x = 1
def takes_int(i: int):
    pass
takes_int(SomeIntEnum.x)
takes_int(2)

[case testIntEnum_functionReturningIntEnum]
from enum import IntEnum
class SomeIntEnum(IntEnum):
    x = 1
def returns_some_int_enum() -> SomeIntEnum:
    return SomeIntEnum.x
an_int = 1
an_int = returns_some_int_enum()

an_enum = SomeIntEnum.x
an_enum = returns_some_int_enum()
[out]

[case testEnumMethods]
from enum import Enum

class Color(Enum):
    red = 1
    green = 2

    def m(self, x: int): pass
    @staticmethod
    def m2(x: int): pass

Color.red.m('')
Color.m2('')
[out]
_program.py:11: error: Argument 1 to "m" of "Color" has incompatible type "str"; expected "int"
_program.py:12: error: Argument 1 to "m2" of "Color" has incompatible type "str"; expected "int"

[case testIntEnum_ExtendedIntEnum_functionTakingExtendedIntEnum]
from enum import IntEnum
class ExtendedIntEnum(IntEnum):
    pass
class SomeExtIntEnum(ExtendedIntEnum):
    x = 1

def takes_int(i: int):
    pass
takes_int(SomeExtIntEnum.x)

def takes_some_ext_int_enum(s: SomeExtIntEnum):
    pass
takes_some_ext_int_enum(SomeExtIntEnum.x)

[case testNamedTupleEnum]
from typing import NamedTuple
from enum import Enum

N = NamedTuple('N', [('bar', int)])

class E(N, Enum):
    X = N(1)

def f(x: E) -> None: pass

f(E.X)

[case testEnumCall]
from enum import IntEnum
class E(IntEnum):
    a = 1
x = None  # type: int
reveal_type(E(x))
[out]
_program.py:5: error: Revealed type is '_testEnumCall.E'

[case testEnumIndex]
from enum import IntEnum
class E(IntEnum):
    a = 1
s = None  # type: str
reveal_type(E[s])
[out]
_program.py:5: error: Revealed type is '_testEnumIndex.E'

[case testEnumIndexError]
from enum import IntEnum
class E(IntEnum):
    a = 1
E[1]
[out]
_program.py:4: error: Enum index should be a string (actual index type "int")

[case testFunctionalEnumString]
from enum import Enum, IntEnum
E = Enum('E', 'foo bar')
I = IntEnum('I', ' bar, baz ')
reveal_type(E.foo)
reveal_type(E.bar.value)
reveal_type(I.bar)
reveal_type(I.baz.value)
[out]
_program.py:4: error: Revealed type is '_testFunctionalEnumString.E'
_program.py:5: error: Revealed type is 'Any'
_program.py:6: error: Revealed type is '_testFunctionalEnumString.I'
_program.py:7: error: Revealed type is 'builtins.int'

[case testFunctionalEnumListOfStrings]
from enum import Enum, IntEnum
E = Enum('E', ('foo', 'bar'))
F = IntEnum('F', ['bar', 'baz'])
reveal_type(E.foo)
reveal_type(F.baz)
[out]
_program.py:4: error: Revealed type is '_testFunctionalEnumListOfStrings.E'
_program.py:5: error: Revealed type is '_testFunctionalEnumListOfStrings.F'

[case testFunctionalEnumListOfPairs]
from enum import Enum, IntEnum
E = Enum('E', [('foo', 1), ['bar', 2]])
F = IntEnum('F', (['bar', 1], ('baz', 2)))
reveal_type(E.foo)
reveal_type(F.baz)
reveal_type(E.foo.value)
reveal_type(F.bar.name)
[out]
_program.py:4: error: Revealed type is '_testFunctionalEnumListOfPairs.E'
_program.py:5: error: Revealed type is '_testFunctionalEnumListOfPairs.F'
_program.py:6: error: Revealed type is 'Any'
_program.py:7: error: Revealed type is 'builtins.str'

[case testFunctionalEnumDict]
from enum import Enum, IntEnum
E = Enum('E', {'foo': 1, 'bar': 2})
F = IntEnum('F', {'bar': 1, 'baz': 2})
reveal_type(E.foo)
reveal_type(F.baz)
reveal_type(E.foo.value)
reveal_type(F.bar.name)
[out]
_program.py:4: error: Revealed type is '_testFunctionalEnumDict.E'
_program.py:5: error: Revealed type is '_testFunctionalEnumDict.F'
_program.py:6: error: Revealed type is 'Any'
_program.py:7: error: Revealed type is 'builtins.str'

[case testFunctionalEnumErrors]
from enum import Enum, IntEnum
A = Enum('A')
B = Enum('B', 42)
C = Enum('C', 'a b', 'x')
D = Enum('D', foo)
bar = 'x y z'
E = Enum('E', bar)
I = IntEnum('I')
J = IntEnum('I', 42)
K = IntEnum('I', 'p q', 'z')
L = Enum('L', ' ')
M = Enum('M', ())
N = IntEnum('M', [])
P = Enum('P', [42])
Q = Enum('Q', [('a', 42, 0)])
R = IntEnum('R', [[0, 42]])
S = Enum('S', {1: 1})
[out]
_program.py:2: error: Too few arguments for Enum()
_program.py:3: error: Enum() expects a string, tuple, list or dict literal as the second argument
_program.py:4: error: Too many arguments for Enum()
_program.py:5: error: Enum() expects a string, tuple, list or dict literal as the second argument
_program.py:5: error: Name 'foo' is not defined
_program.py:7: error: Enum() expects a string, tuple, list or dict literal as the second argument
_program.py:8: error: Too few arguments for IntEnum()
_program.py:9: error: IntEnum() expects a string, tuple, list or dict literal as the second argument
_program.py:10: error: Too many arguments for IntEnum()
_program.py:11: error: Enum() needs at least one item
_program.py:12: error: Enum() needs at least one item
_program.py:13: error: IntEnum() needs at least one item
_program.py:14: error: Enum() with tuple or list expects strings or (name, value) pairs
_program.py:15: error: Enum() with tuple or list expects strings or (name, value) pairs
_program.py:16: error: IntEnum() with tuple or list expects strings or (name, value) pairs
_program.py:17: error: Enum() with dict literal requires string literals
