-- Tests for error codes
--
-- These implicitly use --show-error-codes.

[case testErrorCodeNoAttribute]
import m
m.x  # E: Module has no attribute "x"  [attr-defined]
'x'.foobar  # E: "str" has no attribute "foobar"  [attr-defined]
[file m.py]
[builtins fixtures/module.pyi]

[case testErrorCodeUndefinedName]
x # E: Name 'x' is not defined  [name-defined]
def f() -> None:
    y # E: Name 'y' is not defined  [name-defined]
[file m.py]
[builtins fixtures/module.pyi]

[case testErrorCodeUnclassifiedError]
class A:
    def __init__(self) -> int: \
        # E: The return type of "__init__" must be None  [misc]
        pass

[case testErrorCodeNoteHasNoCode]
reveal_type(1) # N: Revealed type is 'builtins.int'

[case testErrorCodeSyntaxError]
1 '' # E: invalid syntax  [syntax]

[case testErrorCodeSyntaxError2]
def f(): # E: Type signature has too many arguments  [syntax]
    # type: (int) -> None
    1

[case testErrorCodeSyntaxError_python2]
1 '' # E: invalid syntax  [syntax]

[case testErrorCodeSyntaxError2_python2]
def f(): # E: Type signature has too many arguments  [syntax]
    # type: (int) -> None
    1

[case testErrorCodeIgnore1]
'x'.foobar  # type: ignore[attr-defined]
'x'.foobar  # type: ignore[xyz]  # E: "str" has no attribute "foobar"  [attr-defined]
'x'.foobar  # type: ignore

[case testErrorCodeIgnore2]
a = 'x'.foobar  # type: int  # type: ignore[attr-defined]
b = 'x'.foobar  # type: int  # type: ignore[xyz]  # E: "str" has no attribute "foobar"  [attr-defined]
c = 'x'.foobar  # type: int  # type: ignore

[case testErrorCodeIgnore1_python2]
'x'.foobar  # type: ignore[attr-defined]
'x'.foobar  # type: ignore[xyz]  # E: "str" has no attribute "foobar"  [attr-defined]
'x'.foobar  # type: ignore

[case testErrorCodeIgnore2_python2]
a = 'x'.foobar  # type: int  # type: ignore[attr-defined]
b = 'x'.foobar  # type: int  # type: ignore[xyz]  # E: "str" has no attribute "foobar"  [attr-defined]
c = 'x'.foobar  # type: int  # type: ignore

[case testErrorCodeIgnoreMultiple1]
a = 'x'.foobar(b)  # type: ignore[name-defined, attr-defined]
a = 'x'.foobar(b)  # type: ignore[name-defined, xyz]  # E: "str" has no attribute "foobar"  [attr-defined]
a = 'x'.foobar(b)  # type: ignore[xyz, w, attr-defined]  # E: Name 'b' is not defined  [name-defined]

[case testErrorCodeIgnoreMultiple2]
a = 'x'.foobar(b) # type: int # type: ignore[name-defined, attr-defined]
b = 'x'.foobar(b) # type: int # type: ignore[name-defined, xyz]  # E: "str" has no attribute "foobar"  [attr-defined]

[case testErrorCodeIgnoreMultiple1_python2]
a = 'x'.foobar(b)  # type: ignore[name-defined, attr-defined]
a = 'x'.foobar(b)  # type: ignore[name-defined, xyz]  # E: "str" has no attribute "foobar"  [attr-defined]
a = 'x'.foobar(b)  # type: ignore[xyz, w, attr-defined]  # E: Name 'b' is not defined  [name-defined]

[case testErrorCodeIgnoreMultiple2_python2]
a = 'x'.foobar(b) # type: int # type: ignore[name-defined, attr-defined]
b = 'x'.foobar(b) # type: int # type: ignore[name-defined, xyz]  # E: "str" has no attribute "foobar"  [attr-defined]

[case testErrorCodeIgnoreAfterArgComment]
def f(x  # type: xyz  # type: ignore[name-defined]  # Comment
      ):
    # type () -> None
    pass

def g(x  # type: xyz  # type: ignore  # Comment
      ):
    # type () -> None
    pass

def h(x  # type: xyz  # type: ignore[foo]  # E: Name 'xyz' is not defined  [name-defined]
      ):
    # type () -> None
    pass

[case testErrorCodeIgnoreAfterArgComment_python2]
def f(x  # type: xyz  # type: ignore[name-defined]  # Comment
      ):
    # type () -> None
    pass

def g(x  # type: xyz  # type: ignore  # Comment
      ):
    # type () -> None
    pass

def h(x  # type: xyz  # type: ignore[foo]  # E: Name 'xyz' is not defined  [name-defined]
      ):
    # type () -> None
    pass

[case testErrorCodeArgKindAndCount]
def f(x: int) -> None: pass  # N: "f" defined here
f()  # E: Too few arguments for "f"  [call-arg]
f(1, 2)  # E: Too many arguments for "f"  [call-arg]
f(y=1)  # E: Unexpected keyword argument "y" for "f"  [call-arg]

def g(*, x: int) -> None: pass
g()  # E: Missing named argument "x" for "g"  [call-arg]

[case testErrorCodeSuperArgs_python2]
class A:
    def f(self):
        pass
class B(A):
    def f(self):  # type: () -> None
        super().f()  # E: Too few arguments for "super"  [call-arg]

[case testErrorCodeArgType]
def f(x: int) -> None: pass
f('')  # E: Argument 1 to "f" has incompatible type "str"; expected "int"  [arg-type]

class A:
    def g(self, *, x: int) -> None: pass

A().g(x='')  # E: Argument "x" to "g" of "A" has incompatible type "str"; expected "int"  [arg-type]

[case testErrorCodeInvalidType]
def f(): pass

x: f  # E: Function "__main__.f" is not valid as a type  [valid-type] \
      # N: Perhaps you need "Callable[...]" or a callback protocol?

import sys
y: sys  # E: Module "sys" is not valid as a type  [valid-type]
z: y  # E: Variable "__main__.y" is not valid as a type  [valid-type]

[case testErrorCodeNeedTypeAnnotation]
from typing import TypeVar

T = TypeVar('T')
def f() -> T: pass
x = f()  # E: Need type annotation for 'x'  [var-annotated]
y = []  # E: Need type annotation for 'y' (hint: "y: List[<type>] = ...")  [var-annotated]
[builtins fixtures/list.pyi]
