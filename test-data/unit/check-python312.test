[case test695TypeAlias]
type MyInt = int  # E: PEP 695 type aliases are not yet supported

def f(x: MyInt) -> MyInt:
    return reveal_type(x)  # N: Revealed type is "builtins.int"

type MyList[T] = list[T]  # E: PEP 695 type aliases are not yet supported \
                          # E: Name "T" is not defined

def g(x: MyList[int]) -> MyList[int]:  # E: Variable "__main__.MyList" is not valid as a type \
                                       # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
    return reveal_type(x)  # N: Revealed type is "MyList?[builtins.int]"

type MyInt2 = int  # type: ignore[valid-type]

def h(x: MyInt2) -> MyInt2:
    return reveal_type(x)  # N: Revealed type is "builtins.int"

[case test695Class]
class MyGen[T]:  # E: PEP 695 generics are not yet supported
    def __init__(self, x: T) -> None:  # E: Name "T" is not defined
        self.x = x

def f(x: MyGen[int]):  # E: "MyGen" expects no type arguments, but 1 given
    reveal_type(x.x)  # N: Revealed type is "Any"

[case test695Function]
def f[T](x: T) -> T:  # E: PEP 695 generics are not yet supported \
                      # E: Name "T" is not defined
    return reveal_type(x)  # N: Revealed type is "Any"

reveal_type(f(1))  # N: Revealed type is "Any"

async def g[T](x: T) -> T:  # E: PEP 695 generics are not yet supported \
                            # E: Name "T" is not defined
    return reveal_type(x)  # N: Revealed type is "Any"

reveal_type(g(1))  # E: Value of type "Coroutine[Any, Any, Any]" must be used \
                   # N: Are you missing an await? \
                   # N: Revealed type is "typing.Coroutine[Any, Any, Any]"

[case test695TypeVar]
from typing import Callable
type Alias1[T: int] = list[T]  # E: PEP 695 type aliases are not yet supported
type Alias2[**P] = Callable[P, int]  # E: PEP 695 type aliases are not yet supported \
                                     # E: Value of type "int" is not indexable \
                                     # E: Name "P" is not defined
type Alias3[*Ts] = tuple[*Ts]  # E: PEP 695 type aliases are not yet supported \
                               # E: Name "Ts" is not defined

class Cls1[T: int]: ...  # E: PEP 695 generics are not yet supported
class Cls2[**P]: ...  # E: PEP 695 generics are not yet supported
class Cls3[*Ts]: ...  # E: PEP 695 generics are not yet supported

def func1[T: int](x: T) -> T: ...  # E: PEP 695 generics are not yet supported
def func2[**P](x: Callable[P, int]) -> Callable[P, str]: ...  # E: PEP 695 generics are not yet supported \
                                                              # E: The first argument to Callable must be a list of types, parameter specification, or "..." \
                                                              # N: See https://mypy.readthedocs.io/en/stable/kinds_of_types.html#callable-types-and-lambdas \
                                                              # E: Name "P" is not defined
def func3[*Ts](x: tuple[*Ts]) -> tuple[int, *Ts]: ...  # E: PEP 695 generics are not yet supported \
                                                       # E: Name "Ts" is not defined
[builtins fixtures/tuple.pyi]

[case test695TypeAliasType]
from typing import Callable, TypeAliasType, TypeVar, TypeVarTuple

T = TypeVar("T")
Ts = TypeVarTuple("Ts")

TestType = TypeAliasType("TestType", int | str)
x: TestType = 42
y: TestType = 'a'
z: TestType = object()  # E: Incompatible types in assignment (expression has type "object", variable has type "Union[int, str]")

BadAlias1 = TypeAliasType("BadAlias1", tuple[*Ts])  # E: TypeVarTuple "Ts" is not included in type_params
ba1: BadAlias1[int]  # E: Bad number of arguments for type alias, expected 0, given 1
reveal_type(ba1)  # N: Revealed type is "builtins.tuple[Any, ...]"

BadAlias2 = TypeAliasType("BadAlias2", Callable[[*Ts], str])  # E: TypeVarTuple "Ts" is not included in type_params
ba2: BadAlias2[int]  # E: Bad number of arguments for type alias, expected 0, given 1
reveal_type(ba2)  # N: Revealed type is "def (*Any) -> builtins.str"

[builtins fixtures/tuple.pyi]
[typing fixtures/typing-full.pyi]

[case testPEP695GenericFunctionSyntax]
# flags: --enable-incomplete-feature=NewGenericSyntax

def ident[T](x: T) -> T:
    y: T = x
    y = 1  # E: Incompatible types in assignment (expression has type "int", variable has type "T")
    return x

reveal_type(ident(1))  # N: Revealed type is "builtins.int"

a: T  # E: Name "T" is not defined

[case testPEP695GenericClassSyntax]
# flags: --enable-incomplete-feature=NewGenericSyntax

class C[T]:
    x: T

    def __init__(self, x: T) -> None:
        self.x = x

    def ident(self, x: T) -> T:
        y: T = x
        if int():
            return self.x
        else:
            return y

reveal_type(C("x"))  # N: Revealed type is "__main__.C[builtins.str]"
c: C[int] = C(1)
reveal_type(c.x)  # N: Revealed type is "builtins.int"
reveal_type(c.ident(1))  # N: Revealed type is "builtins.int"

[case testPEP695InferVarianceSimpleFromMethod]
# flags: --enable-incomplete-feature=NewGenericSyntax

class Invariant[T]:
    def f(self, x: T) -> None:
        pass

    def g(self) -> T | None:
        return None

a: Invariant[object]
b: Invariant[int]
if int():
    a = b  # E: Incompatible types in assignment (expression has type "Invariant[int]", variable has type "Invariant[object]")
if int():
    b = a  # E: Incompatible types in assignment (expression has type "Invariant[object]", variable has type "Invariant[int]")

class Covariant[T]:
    def g(self) -> T | None:
        return None

c: Covariant[object]
d: Covariant[int]
if int():
    c = d
if int():
    d = c  # E: Incompatible types in assignment (expression has type "Covariant[object]", variable has type "Covariant[int]")

class Contravariant[T]:
    def f(self, x: T) -> None:
        pass

e: Contravariant[object]
f: Contravariant[int]
if int():
    e = f  # E: Incompatible types in assignment (expression has type "Contravariant[int]", variable has type "Contravariant[object]")
if int():
    f = e

[case testPEP695InferVarianceSimpleFromAttribute]
# flags: --enable-incomplete-feature=NewGenericSyntax

class Invariant1[T]:
    def __init__(self, x: T) -> None:
        self.x = x

a: Invariant1[object]
b: Invariant1[int]
if int():
    a = b  # E: Incompatible types in assignment (expression has type "Invariant1[int]", variable has type "Invariant1[object]")
if int():
    b = a  # E: Incompatible types in assignment (expression has type "Invariant1[object]", variable has type "Invariant1[int]")

class Invariant2[T]:
    def __init__(self) -> None:
        self.x: list[T] = []

a2: Invariant2[object]
b2: Invariant2[int]
if int():
    a2 = b2  # E: Incompatible types in assignment (expression has type "Invariant2[int]", variable has type "Invariant2[object]")
if int():
    b2 = a2  # E: Incompatible types in assignment (expression has type "Invariant2[object]", variable has type "Invariant2[int]")

class Invariant3[T]:
    def __init__(self) -> None:
        self.x: T | None = None

a3: Invariant3[object]
b3: Invariant3[int]
if int():
    a3 = b3  # E: Incompatible types in assignment (expression has type "Invariant3[int]", variable has type "Invariant3[object]")
if int():
    b3 = a3  # E: Incompatible types in assignment (expression has type "Invariant3[object]", variable has type "Invariant3[int]")

[case testPEP695InferVarianceRecursive]
# flags: --enable-incomplete-feature=NewGenericSyntax

class Invariant[T]:
    def f(self, x: Invariant[T]) -> Invariant[T]:
        return x

class Covariant[T]:
    def f(self) -> Covariant[T]:
        return self

class Contravariant[T]:
    def f(self, x: Contravariant[T]) -> None:
        pass

a: Invariant[object]
b: Invariant[int]
if int():
    a = b  # E: Incompatible types in assignment (expression has type "Invariant[int]", variable has type "Invariant[object]")
if int():
    b = a  # E: Incompatible types in assignment (expression has type "Invariant[object]", variable has type "Invariant[int]")

c: Covariant[object]
d: Covariant[int]
if int():
    c = d
if int():
    d = c  # E: Incompatible types in assignment (expression has type "Covariant[object]", variable has type "Covariant[int]")

e: Contravariant[object]
f: Contravariant[int]
if int():
    e = f  # E: Incompatible types in assignment (expression has type "Contravariant[int]", variable has type "Contravariant[object]")
if int():
    f = e

[case testPEP695InferVarianceCalculateOnDemand]
# flags: --enable-incomplete-feature=NewGenericSyntax

class Covariant[T]:
    def __init__(self) -> None:
        self.x = [1]

    def f(self) -> None:
        c = Covariant[int]()
        # We need to know that T is covariant here
        self.g(c)
        c2 = Covariant[object]()
        self.h(c2)  # E: Argument 1 to "h" of "Covariant" has incompatible type "Covariant[object]"; expected "Covariant[int]"

    def g(self, x: Covariant[object]) -> None: pass
    def h(self, x: Covariant[int]) -> None: pass

[case testPEP695InferVarianceNotReadyWhenNeeded]
# flags: --enable-incomplete-feature=NewGenericSyntax

class Covariant[T]:
    def f(self) -> None:
        c = Covariant[int]()
        # We need to know that T is covariant here
        self.g(c)
        c2 = Covariant[object]()
        self.h(c2)  # E: Argument 1 to "h" of "Covariant" has incompatible type "Covariant[object]"; expected "Covariant[int]"

    def g(self, x: Covariant[object]) -> None: pass
    def h(self, x: Covariant[int]) -> None: pass

    def __init__(self) -> None:
        self.x = [1]

class Invariant[T]:
    def f(self) -> None:
        c = Invariant(1)
        # We need to know that T is invariant here, and for this we need the type
        # of self.x, which won't be available on the first type checking pass,
        # since __init__ is defined later in the file. In this case we fall back
        # covariance.
        self.g(c)
        c2 = Invariant(object())
        self.h(c2)  # E: Argument 1 to "h" of "Invariant" has incompatible type "Invariant[object]"; expected "Invariant[int]"

    def g(self, x: Invariant[object]) -> None: pass
    def h(self, x: Invariant[int]) -> None: pass

    def __init__(self, x: T) -> None:
        self.x = x

# Now we should have the variance correct.
a: Invariant[object]
b: Invariant[int]
if int():
    a = b  # E: Incompatible types in assignment (expression has type "Invariant[int]", variable has type "Invariant[object]")
if int():
    b = a  # E: Incompatible types in assignment (expression has type "Invariant[object]", variable has type "Invariant[int]")

[case testPEP695InferVarianceNotReadyForJoin]
# flags: --enable-incomplete-feature=NewGenericSyntax

class Invariant[T]:
    def f(self) -> None:
        # Assume covariance if variance us not ready
        reveal_type([Invariant(1), Invariant(object())]) \
            # N: Revealed type is "builtins.list[__main__.Invariant[builtins.object]]"

    def __init__(self, x: T) -> None:
        self.x = x

reveal_type([Invariant(1), Invariant(object())])   # N: Revealed type is "builtins.list[builtins.object]"

[case testPEP695InferVarianceNotReadyForMeet]
# flags: --enable-incomplete-feature=NewGenericSyntax

from typing import TypeVar, Callable

S = TypeVar("S")
def c(a: Callable[[S], None], b: Callable[[S], None]) -> S: ...

def a1(x: Invariant[int]) -> None: pass
def a2(x: Invariant[object]) -> None: pass

class Invariant[T]:
    def f(self) -> None:
        reveal_type(c(a1, a2))  # N: Revealed type is "__main__.Invariant[builtins.int]"

    def __init__(self, x: T) -> None:
        self.x = x

reveal_type(c(a1, a2))  # N: Revealed type is "Never"

[case testPEP695InheritInvariant]
# flags: --enable-incomplete-feature=NewGenericSyntax

class Invariant[T]:
    x: T

class Subclass[T](Invariant[T]):
    pass

x: Invariant[int]
y: Invariant[object]
if int():
    x = y  # E: Incompatible types in assignment (expression has type "Invariant[object]", variable has type "Invariant[int]")
if int():
    y = x  # E: Incompatible types in assignment (expression has type "Invariant[int]", variable has type "Invariant[object]")

a: Subclass[int]
b: Subclass[object]
if int():
    a = b  # E: Incompatible types in assignment (expression has type "Subclass[object]", variable has type "Subclass[int]")
if int():
    b = a  # E: Incompatible types in assignment (expression has type "Subclass[int]", variable has type "Subclass[object]")

[case testPEP695InheritanceMakesInvariant]
# flags: --enable-incomplete-feature=NewGenericSyntax
class Covariant[T]:
    def f(self) -> T:
        ...

class Subclass[T](Covariant[list[T]]):
    pass

x: Covariant[int] = Covariant[object]()  # E: Incompatible types in assignment (expression has type "Covariant[object]", variable has type "Covariant[int]")
y: Covariant[object] = Covariant[int]()

a: Subclass[int] = Subclass[object]()  # E: Incompatible types in assignment (expression has type "Subclass[object]", variable has type "Subclass[int]")
b: Subclass[object] = Subclass[int]()  # E: Incompatible types in assignment (expression has type "Subclass[int]", variable has type "Subclass[object]")

[case testPEP695InheritCoOrContravariant]
# flags: --enable-incomplete-feature=NewGenericSyntax
class Contravariant[T]:
    def f(self, x: T) -> None: pass

class CovSubclass[T](Contravariant[T]):
    pass

a: CovSubclass[int] = CovSubclass[object]()
b: CovSubclass[object] = CovSubclass[int]()  # E: Incompatible types in assignment (expression has type "CovSubclass[int]", variable has type "CovSubclass[object]")

class Covariant[T]:
    def f(self) -> T: ...

class CoSubclass[T](Covariant[T]):
    pass

c: CoSubclass[int] = CoSubclass[object]()  # E: Incompatible types in assignment (expression has type "CoSubclass[object]", variable has type "CoSubclass[int]")
d: CoSubclass[object] = CoSubclass[int]()

class InvSubclass[T](Covariant[T]):
    def g(self, x: T) -> None: pass

e: InvSubclass[int] = InvSubclass[object]()  # E: Incompatible types in assignment (expression has type "InvSubclass[object]", variable has type "InvSubclass[int]")
f: InvSubclass[object] = InvSubclass[int]()  # E: Incompatible types in assignment (expression has type "InvSubclass[int]", variable has type "InvSubclass[object]")
