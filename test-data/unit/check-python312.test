[case test695TypeAlias]
type MyInt = int  # E: PEP 695 type aliases are not yet supported

def f(x: MyInt) -> MyInt:
    return reveal_type(x)  # N: Revealed type is "builtins.int"

type MyList[T] = list[T]  # E: PEP 695 type aliases are not yet supported \
                          # E: Name "T" is not defined

def g(x: MyList[int]) -> MyList[int]:  # E: Variable "__main__.MyList" is not valid as a type \
                                       # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
    return reveal_type(x)  # N: Revealed type is "MyList?[builtins.int]"

type MyInt2 = int  # type: ignore[valid-type]

def h(x: MyInt2) -> MyInt2:
    return reveal_type(x)  # N: Revealed type is "builtins.int"

[case test695Class]
class MyGen[T]:  # E: PEP 695 generics are not yet supported
    def __init__(self, x: T) -> None:  # E: Name "T" is not defined
        self.x = x

def f(x: MyGen[int]):  # E: "MyGen" expects no type arguments, but 1 given
    reveal_type(x.x)  # N: Revealed type is "Any"

[case test695Function]
def f[T](x: T) -> T:  # E: PEP 695 generics are not yet supported \
                      # E: Name "T" is not defined
    return reveal_type(x)  # N: Revealed type is "Any"

reveal_type(f(1))  # N: Revealed type is "Any"

async def g[T](x: T) -> T:  # E: PEP 695 generics are not yet supported \
                            # E: Name "T" is not defined
    return reveal_type(x)  # N: Revealed type is "Any"

reveal_type(g(1))  # E: Value of type "Coroutine[Any, Any, Any]" must be used \
                   # N: Are you missing an await? \
                   # N: Revealed type is "typing.Coroutine[Any, Any, Any]"

[case test695TypeVar]
from typing import Callable
type Alias1[T: int] = list[T]  # E: PEP 695 type aliases are not yet supported
type Alias2[**P] = Callable[P, int]  # E: PEP 695 type aliases are not yet supported \
                                     # E: Value of type "int" is not indexable \
                                     # E: Name "P" is not defined
type Alias3[*Ts] = tuple[*Ts]  # E: PEP 695 type aliases are not yet supported \
                               # E: Name "Ts" is not defined

class Cls1[T: int]: ...  # E: PEP 695 generics are not yet supported
class Cls2[**P]: ...  # E: PEP 695 generics are not yet supported
class Cls3[*Ts]: ...  # E: PEP 695 generics are not yet supported

def func1[T: int](x: T) -> T: ...  # E: PEP 695 generics are not yet supported
def func2[**P](x: Callable[P, int]) -> Callable[P, str]: ...  # E: PEP 695 generics are not yet supported \
                                                              # E: The first argument to Callable must be a list of types, parameter specification, or "..." \
                                                              # N: See https://mypy.readthedocs.io/en/stable/kinds_of_types.html#callable-types-and-lambdas \
                                                              # E: Name "P" is not defined
def func3[*Ts](x: tuple[*Ts]) -> tuple[int, *Ts]: ...  # E: PEP 695 generics are not yet supported \
                                                       # E: Name "Ts" is not defined
[builtins fixtures/tuple.pyi]

[case test695TypeAliasType]
from typing import Callable, TypeAliasType, TypeVar, TypeVarTuple

T = TypeVar("T")
Ts = TypeVarTuple("Ts")

TestType = TypeAliasType("TestType", int | str)
x: TestType = 42
y: TestType = 'a'
z: TestType = object()  # E: Incompatible types in assignment (expression has type "object", variable has type "Union[int, str]")

BadAlias1 = TypeAliasType("BadAlias1", tuple[*Ts])  # E: TypeVarTuple "Ts" is not included in type_params
ba1: BadAlias1[int]  # E: Bad number of arguments for type alias, expected 0, given 1
reveal_type(ba1)  # N: Revealed type is "builtins.tuple[Any, ...]"

BadAlias2 = TypeAliasType("BadAlias2", Callable[[*Ts], str])  # E: TypeVarTuple "Ts" is not included in type_params
ba2: BadAlias2[int]  # E: Bad number of arguments for type alias, expected 0, given 1
reveal_type(ba2)  # N: Revealed type is "def (*Any) -> builtins.str"

[builtins fixtures/tuple.pyi]
[typing fixtures/typing-full.pyi]

[case testPEP695GenericFunctionSyntax]
# flags: --enable-incomplete-feature=NewGenericSyntax

def ident[T](x: T) -> T:
    y: T = x
    y = 1  # E: Incompatible types in assignment (expression has type "int", variable has type "T")
    return x

reveal_type(ident(1))  # N: Revealed type is "builtins.int"

a: T  # E: Name "T" is not defined

[case testPEP695GenericClassSyntax]
# flags: --enable-incomplete-feature=NewGenericSyntax

class C[T]:
    x: T

    def __init__(self, x: T) -> None:
        self.x = x

    def ident(self, x: T) -> T:
        y: T = x
        if int():
            return self.x
        else:
            return y

reveal_type(C("x"))  # N: Revealed type is "__main__.C[builtins.str]"
c: C[int] = C(1)
reveal_type(c.x)  # N: Revealed type is "builtins.int"
reveal_type(c.ident(1))  # N: Revealed type is "builtins.int"

[case testPEP695InferVarianceSimple]
# flags: --enable-incomplete-feature=NewGenericSyntax

class Invariant[T]:
    def f(self, x: T) -> None:
        pass

    def g(self) -> T | None:
        return None

a: Invariant[object]
b: Invariant[int]
if int():
    a = b  # E: Incompatible types in assignment (expression has type "Invariant[int]", variable has type "Invariant[object]")
if int():
    b = a  # E: Incompatible types in assignment (expression has type "Invariant[object]", variable has type "Invariant[int]")

class Covariant[T]:
    def g(self) -> T | None:
        return None

c: Covariant[object]
d: Covariant[int]
if int():
    c = d
if int():
    d = c  # E: Incompatible types in assignment (expression has type "Covariant[object]", variable has type "Covariant[int]")

class Contravariant[T]:
    def f(self, x: T) -> None:
        pass

e: Contravariant[object]
f: Contravariant[int]
if int():
    e = f  # E: Incompatible types in assignment (expression has type "Contravariant[int]", variable has type "Contravariant[object]")
if int():
    f = e
