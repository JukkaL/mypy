[case testAttrsSimple]
# TODO(David):
# Add tests for:
# o type inference

import attr
@attr.s
class A:
    a = attr.ib()
    _b = attr.ib()
    c = attr.ib(18)
    _d = attr.ib(validator=None, default=18)
    E = 18

reveal_type(A)  # E: Revealed type is 'def (a: Any, b: Any, c: Any =, d: Any =) -> __main__.A'
A(1,2)
[builtins fixtures/bool.pyi]

[case testAttrsUntypedNoUntypedDefs]
# flags: --disallow-untyped-defs
import attr
@attr.s    # E: Function is missing a type annotation for one or more arguments
class A:
    a = attr.ib()  # E: Need type annotation for variable
    _b = attr.ib()  # E: Need type annotation for variable
    c = attr.ib(18)  # E: Need type annotation for variable
    _d = attr.ib(validator=None, default=18)   # E: Need type annotation for variable
    E = 18
[builtins fixtures/bool.pyi]

[case testAttrsAnnotated]
import attr
from typing import List, ClassVar
@attr.s
class A:
    a: int = attr.ib()
    _b: List[str] = attr.ib()
    c: str = attr.ib('18')
    _d: int = attr.ib(validator=None, default=18)
    E = 7
    F: ClassVar[int] = 22
reveal_type(A)  # E: Revealed type is 'def (a: builtins.int, b: builtins.list[builtins.str], c: builtins.str =, d: builtins.int =) -> __main__.A'
A(1, ['2'])
[builtins fixtures/list.pyi]

[case testAttrsPython2Annotations]
import attr
from typing import List, ClassVar
@attr.s
class A:
    a = attr.ib()   # type: int
    _b = attr.ib()  # type: List[str]
    c = attr.ib('18') # type: str
    _d = attr.ib(validator=None, default=18) # type: int
    E = 7
    F: ClassVar[int] = 22
reveal_type(A)  # E: Revealed type is 'def (a: builtins.int, b: builtins.list[builtins.str], c: builtins.str =, d: builtins.int =) -> __main__.A'
A(1, ['2'])
[builtins fixtures/list.pyi]

[case testAttrsAutoAttribs]
import attr
from typing import List, ClassVar
@attr.s(auto_attribs=True)
class A:
    a: int
    _b: List[str]
    c: str = '18'
    _d: int = attr.ib(validator=None, default=18)
    E = 7
    F: ClassVar[int] = 22
reveal_type(A)  # E: Revealed type is 'def (a: builtins.int, b: builtins.list[builtins.str], c: builtins.str =, d: builtins.int =) -> __main__.A'
A(1, ['2'])
[builtins fixtures/list.pyi]

[case testAttrsSeriousNames]
from attr import attrib, attrs
@attrs
class A:
    a = attrib()
    _b: int = attrib()
    c = attrib(18)
    _d = attrib(validator=None, default=18)
    CLASS_VAR = 18
reveal_type(A)  # E: Revealed type is 'def (a: Any, b: builtins.int, c: Any =, d: Any =) -> __main__.A'
A(1,2)
[builtins fixtures/bool.pyi]

[case testAttrsInitFalse]
from attr import attrib, attrs
@attrs(auto_attribs=True, init=False)
class A:
    a: int
    _b: int
    c: int = 18
    _d: int = attrib(validator=None, default=18)
reveal_type(A)  # E: Revealed type is 'def () -> __main__.A'
[builtins fixtures/bool.pyi]

[case testAttrsInitAttribFalse]
from attr import attrib, attrs

@attrs
class A:
    a = attrib(init=False)
    b = attrib()

reveal_type(A)  # E: Revealed type is 'def (b: Any) -> __main__.A'

[builtins fixtures/bool.pyi]

[case testAttrsCmpFalse]
from attr import attrib, attrs
@attrs(auto_attribs=True, cmp=False)
class A:
    a: int
reveal_type(A)  # E: Revealed type is 'def (a: builtins.int) -> __main__.A'
reveal_type(A.__eq__)  # E: Revealed type is 'def (builtins.object, builtins.object) -> builtins.bool'
A(1) < A(2)  # E: Unsupported left operand type for < ("A")
[builtins fixtures/attr.pyi]

[case testAttrsInheritance]
import attr
@attr.s
class A:
    a: int = attr.ib()
@attr.s
class B:
    b: str = attr.ib()
@attr.s
class C(A, B):
    c: bool = attr.ib()
reveal_type(C)  # E: Revealed type is 'def (a: builtins.int, b: builtins.str, c: builtins.bool) -> __main__.C'
[builtins fixtures/bool.pyi]

[case testAttrsNestedInClasses]
import attr
@attr.s
class C:
    y = attr.ib()
    @attr.s
    class D:
        x: int = attr.ib()
reveal_type(C)  # E: Revealed type is 'def (y: Any) -> __main__.C'
reveal_type(C.D)  # E: Revealed type is 'def (x: builtins.int) -> __main__.C.D'
[builtins fixtures/bool.pyi]

[case testAttrsInheritanceOverride]
import attr

@attr.s
class A:
    a: int = attr.ib()
    x: int = attr.ib()

@attr.s
class B(A):
    b: str = attr.ib()
    x: int = attr.ib(default=22)

@attr.s
class C(B):
    c: bool = attr.ib()  # No error here because the x below overwrites the x above.
    x: int = attr.ib()

reveal_type(A)  # E: Revealed type is 'def (a: builtins.int, x: builtins.int) -> __main__.A'
reveal_type(B)  # E: Revealed type is 'def (a: builtins.int, b: builtins.str, x: builtins.int =) -> __main__.B'
reveal_type(C)  # E: Revealed type is 'def (a: builtins.int, b: builtins.str, c: builtins.bool, x: builtins.int) -> __main__.C'
[builtins fixtures/bool.pyi]

[case testAttrsTypeEquals]
import attr

@attr.s
class A:
    a = attr.ib(type=int)
    b = attr.ib(18, type=int)
reveal_type(A) # E: Revealed type is 'def (a: builtins.int, b: builtins.int =) -> __main__.A'
[builtins fixtures/bool.pyi]

[case testAttrsFrozen]
import attr

@attr.s(frozen=True)
class A:
    a = attr.ib()

a = A(5)
a.a = 16  # E: Property "a" defined in "A" is read-only
[builtins fixtures/bool.pyi]

[case testAttrsDataClass]
import attr
from typing import List, ClassVar
@attr.dataclass
class A:
    a: int
    _b: List[str]
    c: str = '18'
    _d: int = attr.ib(validator=None, default=18)
    E = 7
    F: ClassVar[int] = 22
reveal_type(A)  # E: Revealed type is 'def (a: builtins.int, b: builtins.list[builtins.str], c: builtins.str =, d: builtins.int =) -> __main__.A'
A(1, ['2'])
[builtins fixtures/list.pyi]

[case testAttrsTypeAlias]
from typing import List
import attr
Alias = List[int]
@attr.s(auto_attribs=True)
class A:
    Alias2 = List[str]
    x: Alias
    y: Alias2 = attr.ib()
reveal_type(A) # E: Revealed type is 'def (x: builtins.list[builtins.int], y: builtins.list[builtins.str]) -> __main__.A'
[builtins fixtures/list.pyi]

[case testAttrsTypeVariable]
from typing import TypeVar, Generic, List
import attr
T = TypeVar('T')
@attr.s(auto_attribs=True)
class A(Generic[T]):
    x: List[T]
    y: T = attr.ib()
reveal_type(A) # E: Revealed type is 'def [T] (x: builtins.list[T`1], y: T`1) -> __main__.A[T`1]'

a = A([1], 2)
reveal_type(a)  # E: Revealed type is '__main__.A[builtins.int*]'
[builtins fixtures/list.pyi]

[case testAttrsForwardReference]
import attr
@attr.s(auto_attribs=True)
class A:
    parent: B

@attr.s(auto_attribs=True)
class B:
    parent: A

reveal_type(A) # E: Revealed type is 'def (parent: __main__.B) -> __main__.A'
reveal_type(B) # E: Revealed type is 'def (parent: __main__.A) -> __main__.B'
A(B(None))
[builtins fixtures/list.pyi]

[case testAttrsForwardReferenceInClass]
import attr
@attr.s(auto_attribs=True)
class A:
    parent: A.B

    @attr.s(auto_attribs=True)
    class B:
        parent: A

reveal_type(A) # E: Revealed type is 'def (parent: __main__.A.B) -> __main__.A'
reveal_type(A.B) # E: Revealed type is 'def (parent: __main__.A) -> __main__.A.B'
A(A.B(None))
[builtins fixtures/list.pyi]

[case testAttrsImporting]
from helper import A
reveal_type(A)  # E: Revealed type is 'def (a: builtins.int, b: builtins.str) -> helper.A'
[file helper.py]
import attr
@attr.s(auto_attribs=True)
class A:
   a: int
   b: str = attr.ib()
[builtins fixtures/list.pyi]

[case testAttrsOtherMethods]
import attr
@attr.s(auto_attribs=True)
class A:
    a: int
    b: str = attr.ib()
    @classmethod
    def new(cls) -> A:
       reveal_type(cls)  # E: Revealed type is 'def (a: builtins.int, b: builtins.str) -> __main__.A'
       return cls(6, 'hello')
    def foo(self) -> int:
       return self.a
reveal_type(A)  # E: Revealed type is 'def (a: builtins.int, b: builtins.str) -> __main__.A'
a = A.new()
reveal_type(a.foo) # E: Revealed type is 'def () -> builtins.int'
[builtins fixtures/classmethod.pyi]

[case testAttrsDefaultDecorator]
import attr
@attr.s
class C(object):
    x: int = attr.ib(default=1)
    y: int = attr.ib()
    @y.default
    def name_does_not_matter(self):
        return self.x + 1
C()
[builtins fixtures/list.pyi]

[case testAttrsLocalVariablesInClassMethod]
import attr
@attr.s(auto_attribs=True)
class A:
    a: int
    b: int = attr.ib()
    @classmethod
    def new(cls, foo: int) -> A:
       a = foo
       b = a
       return cls(a, b)
[builtins fixtures/classmethod.pyi]

[case testAttrsUnionForward]
import attr
from typing import Union, List

@attr.s(auto_attribs=True)
class A:
    frob: List['AOrB']

class B:
   pass

AOrB = Union[A, B]

reveal_type(A)  # E: Revealed type is 'def (frob: builtins.list[Union[__main__.A, __main__.B]]) -> __main__.A'
reveal_type(B)  # E: Revealed type is 'def () -> __main__.B'

A([B()])
[builtins fixtures/list.pyi]

[case testAttrsUsingConvert]
import attr

def convert(s:int) -> str:
    return 'hello'

@attr.s
class C:
    x: str = attr.ib(convert=convert)

# Because of the convert the __init__ takes an int, but the variable is a str.
reveal_type(C)  # E: Revealed type is 'def (x: builtins.int) -> __main__.C'
reveal_type(C(15).x)  # E: Revealed type is 'builtins.str'
[builtins fixtures/list.pyi]

[case testAttrsUsingConverter]
import attr

def converter(s:int) -> str:
    return 'hello'

@attr.s
class C:
    x: str = attr.ib(converter=converter)

# Because of the converter the __init__ takes an int, but the variable is a str.
reveal_type(C)  # E: Revealed type is 'def (x: builtins.int) -> __main__.C'
reveal_type(C(15).x)  # E: Revealed type is 'builtins.str'
[builtins fixtures/list.pyi]

[case testAttrsUsingConvertAndConverter]
import attr

def converter(s:int) -> str:
    return 'hello'

@attr.s
class C:
    x: str = attr.ib(converter=converter, convert=converter)  # E: Can't pass both `convert` and `converter`.

[builtins fixtures/list.pyi]


[case testAttrsCmpWithSubclasses]
import attr
@attr.s
class A: pass
@attr.s
class B: pass
@attr.s
class C(A, B): pass
@attr.s
class D(A): pass

reveal_type(A.__lt__)  # E: Revealed type is 'def [AT] (self: AT`1, other: AT`1) -> builtins.bool'
reveal_type(B.__lt__)  # E: Revealed type is 'def [AT] (self: AT`1, other: AT`1) -> builtins.bool'
reveal_type(C.__lt__)  # E: Revealed type is 'def [AT] (self: AT`1, other: AT`1) -> builtins.bool'
reveal_type(D.__lt__)  # E: Revealed type is 'def [AT] (self: AT`1, other: AT`1) -> builtins.bool'

A() < A()
B() < B()
A() < B() # E: Unsupported operand types for > ("B" and "A")

C() > A()
C() > B()
C() > C()
C() > D() # E: Unsupported operand types for < ("D" and "C")

D() >= A()
D() >= B()  # E: Unsupported operand types for <= ("B" and "D")
D() >= C()  # E: Unsupported operand types for <= ("C" and "D")
D() >= D()

A() <= 1  # E: Unsupported operand types for <= ("A" and "int")
B() <= 1  # E: Unsupported operand types for <= ("B" and "int")
C() <= 1  # E: Unsupported operand types for <= ("C" and "int")
D() <= 1  # E: Unsupported operand types for <= ("D" and "int")

A() == A()
B() == A()
C() == A()
D() == A()

A() == int
B() == int
C() == int
D() == int
[builtins fixtures/list.pyi]

[case testAttrsComplexSuperclass]
import attr
@attr.s
class C:
    x: int = attr.ib(default=1)
    y: int = attr.ib()
    @y.default
    def name_does_not_matter(self):
        return self.x + 1
@attr.s
class A(C):
    z: int = attr.ib(default=18)
reveal_type(C)  # E: Revealed type is 'def (x: builtins.int =, y: builtins.int =) -> __main__.C'
reveal_type(A)  # E: Revealed type is 'def (x: builtins.int =, y: builtins.int =, z: builtins.int =) -> __main__.A'
[builtins fixtures/list.pyi]

[case testAttrsMultiAssign]
import attr
@attr.s
class A:
   x, y, z = attr.ib(), attr.ib(type=int), attr.ib(default=17)
reveal_type(A) # E: Revealed type is 'def (x: Any, y: builtins.int, z: Any =) -> __main__.A'
[builtins fixtures/list.pyi]

[case testAttrsMultiAssign2]
import attr
@attr.s
class A:
   x = y = z = attr.ib()
reveal_type(A) # E: Revealed type is 'def (x: Any, y: Any, z: Any) -> __main__.A'
[builtins fixtures/list.pyi]
