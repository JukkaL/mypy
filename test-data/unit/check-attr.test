[case testAttrsSimple]
# TODO(David):
# Add tests for:
# o type aliases (both inside and outside of a class)
# o type variables
# o decorated generic classes
# o type inference
# o forward references (both inside and outside of class)
# o importing decorated classes
# o instance and class methods in decorated types

import attr
@attr.s
class A:
    a = attr.ib()
    _b = attr.ib()
    c = attr.ib(18)
    _d = attr.ib(validator=None, default=18)
    CLASS_VAR = 18
reveal_type(A)  # E: Revealed type is 'def (a: Any, b: Any, c: Any =, d: Any =) -> __main__.A'
reveal_type(A.__eq__)  # E: Revealed type is 'def (self: __main__.A, other: __main__.A) -> builtins.bool'
reveal_type(A.__lt__)  # E: Revealed type is 'def (self: __main__.A, other: __main__.A) -> builtins.bool'
A(1,2)
[builtins fixtures/bool.pyi]

[case testUntypedNoUntypedAttrS]
# flags: --disallow-untyped-defs
import attr
@attr.s
class A:
    normal = attr.ib()  # E: Need type annotation for variable
    _private = attr.ib()  # E: Need type annotation for variable
    def_arg = attr.ib(18)  # E: Need type annotation for variable
    _def_kwarg = attr.ib(validator=None, default=18)   # E: Need type annotation for variable

    CLASS_VAR = 18
[builtins fixtures/bool.pyi]

[case testAttrsAnnotated]
import attr
from typing import List, ClassVar
@attr.s
class A:
    a: int = attr.ib()
    _b: List[str] = attr.ib()
    c: str = attr.ib('18')
    _d: int = attr.ib(validator=None, default=18)
    E = 7
    F: ClassVar[int] = 22
reveal_type(A)  # E: Revealed type is 'def (a: builtins.int, b: builtins.list[builtins.str], c: builtins.str =, d: builtins.int =) -> __main__.A'
reveal_type(A.__eq__)  # E: Revealed type is 'def (self: __main__.A, other: __main__.A) -> builtins.bool'
reveal_type(A.__lt__)  # E: Revealed type is 'def (self: __main__.A, other: __main__.A) -> builtins.bool'
A(1, ['2'])
[builtins fixtures/list.pyi]

[case testAttrsAutoAttribs]
import attr
from typing import List, ClassVar
@attr.s(auto_attribs=True)
class A:
    a: int = attr.ib()
    _b: List[str] = attr.ib()
    c: str = attr.ib('18')
    _d: int = attr.ib(validator=None, default=18)
    E = 7
    F: ClassVar[int] = 22
reveal_type(A)  # E: Revealed type is 'def (a: builtins.int, b: builtins.list[builtins.str], c: builtins.str =, d: builtins.int =) -> __main__.A'
reveal_type(A.__eq__)  # E: Revealed type is 'def (self: __main__.A, other: __main__.A) -> builtins.bool'
reveal_type(A.__lt__)  # E: Revealed type is 'def (self: __main__.A, other: __main__.A) -> builtins.bool'
A(1, ['2'])
[builtins fixtures/list.pyi]

[case testAttrsSeriousNames]
from attr import attrib, attrs
@attrs
class A:
    a = attrib()
    _b: int = attrib()
    c = attrib(18)
    _d = attrib(validator=None, default=18)
    CLASS_VAR = 18
reveal_type(A)  # E: Revealed type is 'def (a: Any, b: builtins.int, c: Any =, d: Any =) -> __main__.A'
reveal_type(A.__eq__)  # E: Revealed type is 'def (self: __main__.A, other: __main__.A) -> builtins.bool'
reveal_type(A.__lt__)  # E: Revealed type is 'def (self: __main__.A, other: __main__.A) -> builtins.bool'
A(1,2)
[builtins fixtures/bool.pyi]

[case testAttrsInitFalse]
from attr import attrib, attrs
@attrs(auto_attribs=True, init=False)
class A:
    a: int
    _b: int
    c: int = 18
    _d: int = attrib(validator=None, default=18)
reveal_type(A)  # E: Revealed type is 'def () -> __main__.A'
reveal_type(A.__eq__)  # E: Revealed type is 'def (self: __main__.A, other: __main__.A) -> builtins.bool'
reveal_type(A.__lt__)  # E: Revealed type is 'def (self: __main__.A, other: __main__.A) -> builtins.bool'
[builtins fixtures/bool.pyi]

[case testAttrsCmpFalse]
from attr import attrib, attrs
@attrs(auto_attribs=True, cmp=False)
class A:
    a: int
reveal_type(A)  # E: Revealed type is 'def (a: builtins.int) -> __main__.A'
reveal_type(A.__eq__)  # E: Revealed type is 'def (builtins.object, builtins.object) -> builtins.bool'
A(1) < A(2)  # E: Unsupported left operand type for < ("A")
[builtins fixtures/attr.pyi]


[case testAttrsInheritance]
import attr
@attr.s
class A:
    a: int = attr.ib()
@attr.s
class B:
    b: str = attr.ib()
@attr.s  # type: ignore  # Incompatible base classes because of __cmp__ methods.
class C(B, A):
    c: bool = attr.ib()
reveal_type(C)  # E: Revealed type is 'def (a: builtins.int, b: builtins.str, c: builtins.bool) -> __main__.C'
[builtins fixtures/bool.pyi]

[case testAttrsNestedInClasses]
import attr
@attr.s
class C:
    y = attr.ib()
    @attr.s
    class D:
        x: int = attr.ib()
reveal_type(C)  # E: Revealed type is 'def (y: Any) -> __main__.C'
reveal_type(C.D)  # E: Revealed type is 'def (x: builtins.int) -> __main__.C.D'
[builtins fixtures/bool.pyi]
