-- Simple protocol types
-- ---------------------

[case testCannotInstantiateProtocol]
from typing import Protocol

class P(Protocol):
    def meth(self) -> None:
        pass

P() # E: Cannot instantiate protocol class "__main__.P"
[out]

[case testSimpleProtocolOneMethod]
from typing import Protocol

class P(Protocol):
    def meth(self) -> None:
        pass

class B: pass

class C:
    def meth(self) -> None:
        pass

x: P

def fun(x: P) -> None:
    x.meth()
    x.meth(x) # E: Too many arguments for "meth" of "P"
    x.bad # E: "P" has no attribute "bad"

x = C()
x = B() # E: Incompatible types in assignment (expression has type "B", variable has type "P")

fun(C())
fun(B()) # E: Argument 1 to "fun" has incompatible type "B"; expected "P"
[out]

[case testSimpleProtocolOneAbstractMethod]
from typing import Protocol
from abc import abstractmethod

class P(Protocol):
    @abstractmethod
    def meth(self) -> None:
        pass

class B: pass

class C:
    def meth(self) -> None:
        pass

class D(B):
    def meth(self) -> None:
        pass

x: P

def fun(x: P) -> None:
    x.meth()
    x.meth(x) # E: Too many arguments for "meth" of "P"
    x.bad # E: "P" has no attribute "bad"

x = C()
x = D()
x = B() # E: Incompatible types in assignment (expression has type "B", variable has type "P")
fun(C())
fun(D())
fun(B()) # E: Argument 1 to "fun" has incompatible type "B"; expected "P"
[out]

[case testSimpleProtocolOneMethodOverride]
from typing import Protocol, Union

class P(Protocol):
    def meth(self) -> Union[int, str]:
        pass
class SubP(P, Protocol):
    def meth(self) -> int:
        pass

class B: pass
class C:
    def meth(self) -> int:
        pass

x: SubP
def fun(x: SubP) -> str:
    x.bad # E: "SubP" has no attribute "bad"
    return x.meth() # E: Incompatible return value type (got "int", expected "str")

x = C()
x = B() # E: Incompatible types in assignment (expression has type "B", variable has type "SubP")

reveal_type(fun(C())) # E: Revealed type is 'builtins.str'
fun(B()) # E: Argument 1 to "fun" has incompatible type "B"; expected "SubP"
[out]

[case testSimpleProtocolTwoMethodsMerge]
from typing import Protocol

[out]

[case testSimpleProtocolTwoMethodsExtend]
from typing import Protocol

[out]

-- Semanal errors in protocol types
-- --------------------------------

-- Generic protocol types
-- ----------------------

-- Recursive protocol types
-- ------------------------

-- @property, @classmethod and @staticmethod in protocol types
-- -----------------------------------------------------------

-- Meet and join of protocol types
-- -------------------------------

-- Unions of protocol types
-- ------------------------

-- Type[] with protocol types
-- --------------------------

-- isinsatnce() with @runtime protocols
-- ------------------------------------

[case testSimpleRuntimeProtocolCheck]
from typing import Protocol, runtime

class P(Protocol):
    def meth(self) -> None:
        pass

@runtime
class R(Protocol):
    def meth(self) -> int:
        pass

x: object

if isinstance(x, P):  # E: Only @runtime protocols can be used with instance and class checks
    reveal_type(x)  # E: Revealed type is '__main__.P'

if isinstance(x, R):
    reveal_type(x)  # E: Revealed type is '__main__.R'
    reveal_type(x.meth())  # E: Revealed type is 'builtins.int'  # TODO: this should be Any
[builtins fixtures/isinstance.pyi]
[out]

-- Non-Instances and protocol types (Callable vs __call__ etc.)
-- ------------------------------------------------------------

-- Standard protocol types (SupportsInt, Reversible, etc.)
-- -------------------------------------------------------
