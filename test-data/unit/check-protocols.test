-- Simple protocol types
-- ---------------------

[case testCannotInstantiateProtocol]
from typing import Protocol

class P(Protocol):
    def meth(self) -> None:
        pass

P() # E: Cannot instantiate protocol class "__main__.P"
[out]

[case testSimpleProtocolOneMethod]
from typing import Protocol

class P(Protocol):
    def meth(self) -> None:
        pass

class B: pass
class C:
    def meth(self) -> None:
        pass

x: P
def fun(x: P) -> None:
    x.meth()
    x.meth(x) # E: Too many arguments for "meth" of "P"
    x.bad # E: "P" has no attribute "bad"

x = C()
x = B() # E: Incompatible types in assignment (expression has type "B", variable has type "P") \
    # N: '__main__.B' missing following '__main__.P' protocol members: \
    # N: meth

fun(C())
fun(B()) # E: Argument 1 to "fun" has incompatible type "B"; expected "P" \
    # N: '__main__.B' missing following '__main__.P' protocol members: \
    # N: meth

def fun2() -> P:
    return C()
def fun3() -> P:
    return B() # E: Incompatible return value type (got "B", expected "P") \
               # N: '__main__.B' missing following '__main__.P' protocol members: \
               # N: meth
[out]

[case testSimpleProtocolOneAbstractMethod]
from typing import Protocol
from abc import abstractmethod

class P(Protocol):
    @abstractmethod
    def meth(self) -> None:
        pass

class B: pass
class C:
    def meth(self) -> None:
        pass
class D(B):
    def meth(self) -> None:
        pass

x: P
def fun(x: P) -> None:
    x.meth()
    x.meth(x) # E: Too many arguments for "meth" of "P"
    x.bad # E: "P" has no attribute "bad"

x = C()
x = D()
x = B() # E: Incompatible types in assignment (expression has type "B", variable has type "P") \
    # N: '__main__.B' missing following '__main__.P' protocol members: \
    # N: meth
fun(C())
fun(D())
fun(B()) # E: Argument 1 to "fun" has incompatible type "B"; expected "P" \
    # N: '__main__.B' missing following '__main__.P' protocol members: \
    # N: meth
[out]

[case testSimpleProtocolOneMethodOverride]
from typing import Protocol, Union

class P(Protocol):
    def meth(self) -> Union[int, str]:
        pass
class SubP(P, Protocol):
    def meth(self) -> int:
        pass

class B: pass
class C:
    def meth(self) -> int:
        pass
z: P
x: SubP
def fun(x: SubP) -> str:
    x.bad # E: "SubP" has no attribute "bad"
    return x.meth() # E: Incompatible return value type (got "int", expected "str")

z = x
x = C()
x = B() # E: Incompatible types in assignment (expression has type "B", variable has type "SubP") \
    # N: '__main__.B' missing following '__main__.SubP' protocol members: \
    # N: meth

reveal_type(fun(C())) # E: Revealed type is 'builtins.str'
fun(B()) # E: Argument 1 to "fun" has incompatible type "B"; expected "SubP" \
    # N: '__main__.B' missing following '__main__.SubP' protocol members: \
    # N: meth
[out]

[case testSimpleProtocolTwoMethodsMerge]
from typing import Protocol

class P1(Protocol):
    def meth1(self) -> int:
        pass
class P2(Protocol):
    def meth2(self) -> str:
        pass
class P(P1, P2, Protocol): pass

class B: pass
class C1:
    def meth1(self) -> int:
        pass
class C2(C1):
    def meth2(self) -> str:
        pass
class C:
    def meth1(self) -> int:
        pass
    def meth2(self) -> str:
        pass

class AnotherP(Protocol):
    def meth1(self) -> int:
        pass
    def meth2(self) -> str:
        pass

x: P
reveal_type(x.meth1())  # E: Revealed type is 'builtins.int'
reveal_type(x.meth2())  # E: Revealed type is 'builtins.str'

c: C
c1: C1
c2: C2
y: AnotherP

x = c
x = B()  # E: Incompatible types in assignment (expression has type "B", variable has type "P") \
    # N: '__main__.B' missing following '__main__.P' protocol members: \
    # N: meth1, meth2
x = c1 # E: Incompatible types in assignment (expression has type "C1", variable has type "P") \
    # N: '__main__.C1' missing following '__main__.P' protocol members: \
    # N: meth2
x = c2
x = y
y = x
[out]

[case testSimpleProtocolTwoMethodsExtend]
from typing import Protocol

class P1(Protocol):
    def meth1(self) -> int:
        pass
class P2(P1, Protocol):
    def meth2(self) -> str:
        pass

class Cbad:
    def meth1(self) -> int:
        pass

class C:
    def meth1(self) -> int:
        pass
    def meth2(self) -> str:
        pass

x: P2
reveal_type(x.meth1()) # E: Revealed type is 'builtins.int'
reveal_type(x.meth2()) # E: Revealed type is 'builtins.str'

x = C() # OK
x = Cbad() # E: Incompatible types in assignment (expression has type "Cbad", variable has type "P2") \
    # N: '__main__.Cbad' missing following '__main__.P2' protocol members: \
    # N: meth2
[out]

[case testCannotAssignNormalToProtocol]
from typing import Protocol

class P(Protocol):
    def meth(self) -> int:
        pass
class C:
    def meth(self) -> int:
        pass

x: C
y: P
x = y # E: Incompatible types in assignment (expression has type "P", variable has type "C")
[out]

[case testIndependentProtocolSubtyping]
from typing import Protocol

class P1(Protocol):
    def meth(self) -> int:
        pass
class P2(Protocol):
    def meth(self) -> int:
        pass

x1: P1
x2: P2

x1 = x2
x2 = x1

def f1(x: P1) -> None: pass
def f2(x: P2) -> None: pass

f1(x2)
f2(x1)
[out]

[case testNoneDisablesProtocolImplementation]
from typing import Protocol

class MyHashable(Protocol):
    def __my_hash__(self) -> int:
        return 0

class C:
    __my_hash__ = None

var: MyHashable = C()  # E: Incompatible types in assignment (expression has type "C", variable has type "MyHashable")
[out]

[case testNoneDisablesProtocolSubclassingWithStrictOptional]
# flags: --strict-optional
from typing import Protocol

class MyHashable(Protocol):
    def __my_hash__(self) -> int:
        return 0

class C(MyHashable):
    __my_hash__ = None  # E: Incompatible types in assignment \
(expression has type None, base class "MyHashable" defined the type as Callable[[MyHashable], int])
[out]

-- Semanal errors in protocol types
-- --------------------------------

[case testBasicSemanalErrorsInProtocols]
from typing import Protocol, Generic, TypeVar, Iterable

T = TypeVar('T', covariant=True)
S = TypeVar('S', covariant=True)

class P1(Protocol[T, T]): # E: Duplicate type variables in Generic[...] or Protocol[...]
    def meth(self) -> T:
        pass

class P2(Protocol[T], Protocol[S]): # E: Only single Generic[...] or Protocol[...] can be in bases
    def meth(self) -> T:
        pass

class P3(Protocol[T], Generic[S]): # E: Only single Generic[...] or Protocol[...] can be in bases
    def meth(self) -> T:
        pass

class P4(Protocol[T]):
    attr: Iterable[S] # E: Invalid type "__main__.S"

class P5(Iterable[S], Protocol[T]): # E: If Generic[...] or Protocol[...] is present it should list all type variables
    def meth(self) -> T:
        pass
[out]

[case testProhibitSelfDefinitionInProtocols]
from typing import Protocol

class P(Protocol):
    def __init__(self, a: int) -> None:
        self.a = a # E: Protocol members cannot be defined via assignment to self \
                   # E: "P" has no attribute "a"

class B: pass
class C:
    def __init__(self, a: int) -> None:
        pass

x: P
x = B()
# The above has an incompatible __init__, but mypy ignores this for nominal subtypes?
x = C(1)

class P2(Protocol):
    a: int
    def __init__(self) -> None:
        self.a = 1

class B2(P2):
    a: int

x2: P2 = B2()  # OK
[out]

[case testProtocolsInMypyExtensions]
from mypy_extensions import Protocol, runtime

@runtime
class P(Protocol):
    def meth(self) -> int:
        pass

x: object
if isinstance(x, P):
    reveal_type(x)  # E: Revealed type is '__main__.P'
    reveal_type(x.meth())  # E: Revealed type is 'builtins.int'

class C:
    def meth(self) -> int:
        pass

z: P = C()
[builtins fixtures/dict.pyi]
[out]

[case testProtocolsCannotInheritFromNormal]
from typing import Protocol

class C: pass
class D: pass

class P(C, Protocol): # E: All bases of a protocol must be protocols
    attr: int

class P2(P, D, Protocol): # E: All bases of a protocol must be protocols
    pass

p: P2
reveal_type(p.attr) # E: Revealed type is 'builtins.int'
[out]

-- Generic protocol types
-- ----------------------

[case testAutomaticProtocolVariance]
from typing import TypeVar, Protocol

T = TypeVar('T')

# In case of these errors we proceed with inferred variance.
class Pco(Protocol[T]): # E: Invariant type variable 'T' used in protocol where covariant one is expected
    def meth(self) -> T:
        pass
class Pcontra(Protocol[T]): # E: Invariant type variable 'T' used in protocol where contravariant one is expected
    def meth(self, x: T) -> None:
        pass
class Pinv(Protocol[T]):
    attr: T

class A: pass
class B(A): pass

x1: Pco[B]
y1: Pco[A]
x1 = y1 # E: Incompatible types in assignment (expression has type Pco[A], variable has type Pco[B]) \
        # N: Following members of __main__.Pco[__main__.A] have conflicts: \
        # N: meth: expected def () -> __main__.B*, got def () -> __main__.A*
y1 = x1

x2: Pcontra[B]
y2: Pcontra[A]
y2 = x2 # E: Incompatible types in assignment (expression has type Pcontra[B], variable has type Pcontra[A]) \
        # N: Following members of __main__.Pcontra[__main__.B] have conflicts: \
        # N: meth: expected def (x: __main__.A*), got def (x: __main__.B*)
x2 = y2

x3: Pinv[B]
y3: Pinv[A]
y3 = x3 # E: Incompatible types in assignment (expression has type Pinv[B], variable has type Pinv[A]) \
        # N: Following members of __main__.Pinv[__main__.B] have conflicts: \
        # N: attr: expected __main__.A*, got __main__.B*
x3 = y3 # E: Incompatible types in assignment (expression has type Pinv[A], variable has type Pinv[B]) \
        # N: Following members of __main__.Pinv[__main__.A] have conflicts: \
        # N: attr: expected __main__.B*, got __main__.A*
[out]

[case testGenericProtocolsInference1]
from typing import Protocol, Sequence, TypeVar

T = TypeVar('T', covariant=True)

class Closeable(Protocol[T]):
    def close(self) -> T:
        pass

class F:
    def close(self) -> int:
        return 0

def close(arg: Closeable[T]) -> T:
    return arg.close()

def close_all(args: Sequence[Closeable[T]]) -> T:
    for arg in args:
            arg.close()
    return args[0].close()

arg: Closeable[int]

reveal_type(close(F())) # E: Revealed type is 'builtins.int*'
reveal_type(close(arg)) # E: Revealed type is 'builtins.int*'
reveal_type(close_all([F()])) # E: Revealed type is 'builtins.int*'
reveal_type(close_all([arg])) # E: Revealed type is 'builtins.int*'
[builtins fixtures/isinstancelist.pyi]
[out]

[case testProtocolGenericInference2]
from typing import Generic, TypeVar, Protocol
T = TypeVar('T')
S = TypeVar('S')

class P(Protocol[T, S]):
    x: T
    y: S

class C:
    x: int
    y: int

def fun3(x: P[T, T]) -> T:
    pass
reveal_type(fun3(C())) # E: Revealed type is 'builtins.int*'
[out]

[case testProtocolGenericInferenceCovariant]
from typing import Generic, TypeVar, Protocol
T = TypeVar('T', covariant=True)
S = TypeVar('S', covariant=True)
U = TypeVar('U')

class P(Protocol[T, S]):
    def x(self) -> T: pass
    def y(self) -> S: pass

class C:
    def x(self) -> int: pass
    def y(self) -> int: pass

def fun4(x: U, y: P[U, U]) -> U:
    pass
reveal_type(fun4('a', C())) # E: Revealed type is 'builtins.object*'
[out]

[case testGenericSubProtocols]
from typing import TypeVar, Protocol, Tuple, Generic

T = TypeVar('T')
S = TypeVar('S')

class P1(Protocol[T]):
    attr1: T
class P2(P1[T], Protocol[T, S]):
    attr2: Tuple[T, S]

class C:
    def __init__(self, a1: int, a2: Tuple[int, int]) -> None:
        self.attr1 = a1
        self.attr2 = a2

c: C
var: P2[int, int] = c
var2: P2[int, str] = c # E: Incompatible types in assignment (expression has type "C", variable has type P2[int, str]) \
                       # N: Following members of __main__.C have conflicts: \
                       # N: attr2: expected Tuple[builtins.int*, builtins.str*], got Tuple[builtins.int, builtins.int]

class D(Generic[T]):
    attr1: T
class E(D[T]):
    attr2: Tuple[T, T]

def f(x: T) -> T:
    z: P2[T, T] = E[T]()
    y: P2[T, T] = D[T]() # E: Incompatible types in assignment (expression has type D[T], variable has type P2[T, T]) \
                         # N: '__main__.D' missing following '__main__.P2' protocol members: \
                         # N: attr2
    return x
[builtins fixtures/isinstancelist.pyi]
[out]

[case testGenericSubProtocolsExtensionInvariant]
from typing import TypeVar, Protocol, Union

T = TypeVar('T')
S = TypeVar('S')

class P1(Protocol[T]):
    attr1: T
class P2(Protocol[T]):
    attr2: T
class P(P1[T], P2[S], Protocol):
    pass

class C:
    attr1: int
    attr2: str

class A:
    attr1: A
class B:
    attr2: B
class D(A, B): pass

x: P = D()  # Same as P[Any, Any]

var: P[Union[int, P], Union[P, str]] = C() # E: Incompatible types in assignment (expression has type "C", variable has type P[Union[int, P[Any, Any]], Union[P[Any, Any], str]]) \
                                           # N: Following members of __main__.C have conflicts: \
                                           # N: attr1: expected Union[builtins.int, __main__.P[Any, Any]], got builtins.int \
                                           # N: attr2: expected Union[__main__.P[Any, Any], builtins.str], got builtins.str
[out]

[case testGenericSubProtocolsExtensionCovariant]
from typing import TypeVar, Protocol, Union

T = TypeVar('T', covariant=True)
S = TypeVar('S', covariant=True)

class P1(Protocol[T]):
    def attr1(self) -> T: pass
class P2(Protocol[T]):
    def attr2(self) -> T: pass
class P(P1[T], P2[S], Protocol):
    pass

class C:
    def attr1(self) -> int: pass
    def attr2(self) -> str: pass

var: P[Union[int, P], Union[P, str]] = C() # OK for covariant
var2: P[Union[str, P], Union[P, int]] = C() # E: Incompatible types in assignment (expression has type "C", variable has type P[Union[str, P[Any, Any]], Union[P[Any, Any], int]]) \
                                            # N: Following members of __main__.C have conflicts: \
                                            # N: attr1: expected def () -> Union[builtins.str, __main__.P[Any, Any]], got def () -> builtins.int \
                                            # N: attr2: expected def () -> Union[__main__.P[Any, Any], builtins.int], got def () -> builtins.str
[out]

[case testSelfTypesWithProtocolsBehaveAsWithNominal]
from typing import Protocol, TypeVar

T = TypeVar('T', bound=Shape)
class Shape(Protocol):
    def combine(self: T, other: T) -> T:
        pass

class NonProtoShape:
    def combine(self: T, other: T) -> T:
        pass
class Circle:
    def combine(self: T, other: Shape) -> T:
        pass
class Triangle:
    def combine(self, other: Shape) -> Shape:
        pass
class Bad:
    def combine(self, other: int) -> str:
        pass

def f(s: Shape) -> None: pass
s: Shape

f(NonProtoShape())
f(Circle())
s = Triangle() # E: Incompatible types in assignment (expression has type "Triangle", variable has type "Shape") \
               # N: Following members of __main__.Triangle have conflicts: \
               # N: combine: expected def (other: __main__.Triangle*) -> __main__.Triangle*, got def (other: __main__.Shape) -> __main__.Shape
s = Bad() # E: Incompatible types in assignment (expression has type "Bad", variable has type "Shape") \
          # N: Following members of __main__.Bad have conflicts: \
          # N: combine: expected def (other: __main__.Bad*) -> __main__.Bad*, got def (other: builtins.int) -> builtins.str

n2: NonProtoShape = s # E: Incompatible types in assignment (expression has type "Shape", variable has type "NonProtoShape")
[out]

[case testBadVarianceInProtocols]
from typing import Protocol, TypeVar

T_co = TypeVar('T_co', covariant=True)
T_contra = TypeVar('T_contra', contravariant=True)

class Proto(Protocol[T_co, T_contra]):  # type: ignore
    def one(self, x: T_co) -> None:  # E: Cannot use a covariant type variable as a parameter
        pass
    def other(self) -> T_contra:  # E: Cannot use a contravariant type variable as return type
        pass

# Check that we respect user overrides of variance after the errors are reported
x: Proto[int, float]
y: Proto[float, int]
y = x # OK
[builtins fixtures/list.pyi]
[out]

[case testSubtleBadVarianceInProtocols]
from typing import Protocol, TypeVar, Iterable, Sequence

T_co = TypeVar('T_co', covariant=True)
T_contra = TypeVar('T_contra', contravariant=True)

class Proto(Protocol[T_co, T_contra]): # E: Covariant type variable 'T_co' used in protocol where contravariant one is expected \
                                       # E: Contravariant type variable 'T_contra' used in protocol where covariant one is expected
    def one(self, x: Iterable[T_co]) -> None:
        pass
    def other(self) -> Sequence[T_contra]:
        pass

# Check that we respect user overrides of variance after the errors are reported
x: Proto[int, float]
y: Proto[float, int]
y = x # OK
[builtins fixtures/list.pyi]
[out]

-- Recursive protocol types
-- ------------------------

[case testRecursiveProtocols1]
from typing import Protocol, Sequence, List, Generic, TypeVar

T = TypeVar('T')

class Traversable(Protocol):
    @property
    def leaves(self) -> Sequence[Traversable]: pass

class C: pass

class D(Generic[T]):
    leaves: List[D[T]]

t: Traversable
t = D[int]() # OK
t = C() # E: Incompatible types in assignment (expression has type "C", variable has type "Traversable") \
        # N: '__main__.C' missing following '__main__.Traversable' protocol members: \
        # N: leaves
[builtins fixtures/list.pyi]
[out]

[case testRecursiveProtocols2]
from typing import Protocol, TypeVar

T = TypeVar('T')
class Linked(Protocol[T]):
    val: T
    def next(self) -> Linked[T]: pass

class L:
    val: int
    def next(self) -> L: pass

def last(seq: Linked[T]) -> T:
    pass

reveal_type(last(L())) # E: Revealed type is 'builtins.int*'
[builtins fixtures/list.pyi]
[out]

[case testMutuallyRecursiveProtocols]
from typing import Protocol, Sequence, List

class P1(Protocol):
    @property
    def attr1(self) -> Sequence[P2]: pass

class P2(Protocol):
    @property
    def attr2(self) -> Sequence[P1]: pass

class C: pass

class A:
    attr1: List[B]

class B:
    attr2: List[A]

t: P1
t = A() # OK
t = B() # E: Incompatible types in assignment (expression has type "B", variable has type "P1") \
        # N: '__main__.B' missing following '__main__.P1' protocol members: \
        # N: attr1
t = C() # E: Incompatible types in assignment (expression has type "C", variable has type "P1") \
        # N: '__main__.C' missing following '__main__.P1' protocol members: \
        # N: attr1
[builtins fixtures/list.pyi]
[out]

-- @property, @classmethod and @staticmethod in protocol types
-- -----------------------------------------------------------

[case testCannotInstantiateAbstractMethodExplicitProtocolSubtypes]
from typing import Protocol
from abc import abstractmethod

class P(Protocol):
    @abstractmethod
    def meth(self) -> int:
        pass

class A(P):
    pass

A() # E: Cannot instantiate abstract class 'A' with abstract attribute 'meth'

class C(A):
    def meth(self) -> int:
        pass
class C2(P):
    def meth(self) -> int:
        pass

C()
C2()
[out]

[case testCannotInstantiateAbstractVariableExplicitProtocolSubtypes]
from typing import Protocol

class P(Protocol):
    attr: int

class A(P):
    pass

A() # E: Cannot instantiate abstract class 'A' with abstract attribute 'attr'

class C(A):
    attr: int
class C2(P):
    def __init__(self) -> None:
        self.attr = 1

C()
C2()

class P2(Protocol):
    attr: int = 1

class B(P2): pass
B() # OK, attr is not abstract
[out]

[case testClassVarsInProtocols]
from typing import Protocol, ClassVar

class PInst(Protocol):
   v: int

class PClass(Protocol):
   v: ClassVar[int]

class CInst:
   v: int

class CClass:
   v: ClassVar[int]

x: PInst
y: PClass

x = CInst()
x = CClass() # E: Incompatible types in assignment (expression has type "CClass", variable has type "PInst") \
             # N: Protocol member __main__.PInst.v: expected instance variable, got class variable
y = CClass()
y = CInst()  # E: Incompatible types in assignment (expression has type "CInst", variable has type "PClass") \
             # N: Protocol member __main__.PClass.v: expected class variable, got instance variable
[out]

[case testPropertyInProtocols]
from typing import Protocol

class PP(Protocol):
    @property
    def attr(self) -> int:
        pass

class P(Protocol):
    attr: int

x: P
y: PP
y = x

x2: P
y2: PP
x2 = y2 # E: Incompatible types in assignment (expression has type "PP", variable has type "P") \
        # N: Protocol member __main__.P.attr: expected settable variable, got read-only attribute
[builtins fixtures/property.pyi]
[out]

[case testSettablePropertyInProtocols]
from typing import Protocol

class PPS(Protocol):
    @property
    def attr(self) -> int:
        pass
    @attr.setter
    def attr(self, x: int) -> None:
        pass

class PP(Protocol):
    @property
    def attr(self) -> int:
        pass

class P(Protocol):
    attr: int

x: P
z: PPS
z = x

x2: P
z2: PPS
x2 = z2

y3: PP
z3: PPS
y3 = z3

y4: PP
z4: PPS
z4 = y4 # E: Incompatible types in assignment (expression has type "PP", variable has type "PPS") \
        # N: Protocol member __main__.PPS.attr: expected settable variable, got read-only attribute
[builtins fixtures/property.pyi]
[out]

[case testStaticAndClassMethodsInProtocols]
from typing import Protocol, Type, TypeVar

class P(Protocol):
    def meth(self, x: int) -> str:
        pass

class PC(Protocol):
    @classmethod
    def meth(cls, x: int) -> str:
        pass

class B:
    @staticmethod
    def meth(x: int) -> str:
        pass

class C:
    def meth(self, x: int) -> str:
        pass

x: P
x = C()
x = B()

y: PC
y = B()
y = C() # E: Incompatible types in assignment (expression has type "C", variable has type "PC") \
        # N: Protocol member __main__.PC.meth: expected class or static method
[builtins fixtures/classmethod.pyi]
[out]

[case testOverloadedMethodsInProtocols]
from typing import overload, Protocol, Union

class P(Protocol):
    @overload
    def f(self, x: int) -> int: pass
    @overload
    def f(self, x: str) -> str: pass
    def f(self, x): pass

class C:
    def f(self, x: Union[int, str]) -> None:
        pass
class D:
    def f(self, x: int) -> None:
        pass

x: P = C()
x = D() # E: Incompatible types in assignment (expression has type "D", variable has type "P") \
        # N: Following members of __main__.D have conflicts: \
        # N: f: expected Overload(def (x: builtins.int) -> builtins.int, def (x: builtins.str) -> builtins.str), got def (x: builtins.int)
[out]

-- Join and meet with protocol types
-- ---------------------------------

[case testJoinProtocolWithProtocol]
from typing import Protocol

class P(Protocol):
    attr: int
class P2(Protocol):
    attr: int
    attr2: str

x: P
y: P2

l = [x, y]

reveal_type(l) # E: Revealed type is 'builtins.list[__main__.P*]'
[builtins fixtures/list.pyi]
[out]

[case testJoinProtocolWithNormal]
from typing import Protocol

class P(Protocol):
    attr: int

class C:
    attr: int

x: P
y: C

l = [x, y]

reveal_type(l) # E: Revealed type is 'builtins.list[__main__.P*]'
[builtins fixtures/list.pyi]
[out]

[case testMeetProtocolWithProtocol]
from typing import Protocol, Callable, TypeVar

class P(Protocol):
    attr: int
class P2(Protocol):
    attr: int
    attr2: str

T = TypeVar('T')
def f(x: Callable[[T, T], None]) -> T: pass
def g(x: P, y: P2) -> None: pass
reveal_type(f(g)) # E: Revealed type is '__main__.P2*'
[out]

[case testMeetProtocolWithNormal]
from typing import Protocol, Callable, TypeVar

class P(Protocol):
    attr: int
class C:
    attr: int

T = TypeVar('T')
def f(x: Callable[[T, T], None]) -> T: pass
def g(x: P, y: C) -> None: pass
reveal_type(f(g)) # E: Revealed type is '__main__.C*'
[out]

[case testInferProtocolFromProtocol]
from typing import Protocol, Sequence, TypeVar, Generic

T = TypeVar('T')
class Box(Protocol[T]):
    content: T
class Linked(Protocol[T]):
    val: T
    def next(self) -> Linked[T]: pass

class L(Generic[T]):
    val: Box[T]
    def next(self) -> L[T]: pass

def last(seq: Linked[T]) -> T:
    pass

reveal_type(last(L[int]())) # E: Revealed type is '__main__.Box*[builtins.int*]'
reveal_type(last(L[str]()).content) # E: Revealed type is 'builtins.str*'
[out]

[case testOverloadOnProtocol]
from typing import overload, Protocol, runtime

@runtime
class P1(Protocol):
    attr1: int
class P2(Protocol):
    attr2: str

class C1:
    attr1: int
class C2:
    attr2: str
class C: pass

@overload
def f(x: P1) -> int: ...
@overload
def f(x: P2) -> str: ...
def f(x):
    if isinstance(x, P1):
        return P1.attr1
    if isinstance(x, P2): # E: Only @runtime protocols can be used with instance and class checks
        return P1.attr2

reveal_type(f(C1())) # E: Revealed type is 'builtins.int'
reveal_type(f(C2())) # E: Revealed type is 'builtins.str'

f(C()) # E: No overload variant of "f" matches argument types [__main__.C]

[builtins fixtures/isinstance.pyi]
[out]

-- Unions of protocol types
-- ------------------------

[case testBasicUnionsOfProtocols]
from typing import Union, Protocol

class P1(Protocol):
    attr1: int
class P2(Protocol):
    attr2: int

class C1:
    attr1: int
class C2:
    attr2: int
class C(C1, C2):
    pass

class B: ...

x: Union[P1, P2]

x = C1()
x = C2()
x = C()
x = B() # E: Incompatible types in assignment (expression has type "B", variable has type "Union[P1, P2]")
[out]

[case testUnionsOfNormalClassesWithProtocols]
from typing import Protocol, Union

class P1(Protocol):
    attr1: int
class P2(Protocol):
    attr2: int

class C1:
    attr1: int
class C2:
    attr2: int
class C(C1, C2):
    pass

class D1:
    attr1: int

def f1(x: P1) -> None:
    pass
def f2(x: P2) -> None:
    pass

x: Union[C1, C2]
y: Union[C1, D1]
z: Union[C, D1]

f1(x) # E: Argument 1 to "f1" has incompatible type "Union[C1, C2]"; expected "P1"
f1(y)
f1(z)
f2(x) # E: Argument 1 to "f2" has incompatible type "Union[C1, C2]"; expected "P2"
f2(z) # E: Argument 1 to "f2" has incompatible type "Union[C, D1]"; expected "P2"
[out]

-- Type[] with protocol types
-- --------------------------

[case testInstantiationProtocolInTypeForFunctions]
from typing import Type, Protocol

class P(Protocol):
    def m(self) -> None: pass
class P1(Protocol):
    def m(self) -> None: pass
class Pbad(Protocol):
    def mbad(self) -> int: pass
class B(P): pass
class C:
    def m(self) -> None:
        pass

def f(cls: Type[P]) -> P:
    return cls()  # OK
def g() -> P:
    return P()  # E: Cannot instantiate protocol class "__main__.P"

f(P)  # E: Only concrete class can be given where 'Type[__main__.P]' is expected
f(B)  # OK
f(C)  # OK
x: Type[P1]
xbad: Type[Pbad]
f(x)  # OK
f(xbad)  # E: Argument 1 to "f" has incompatible type Type[Pbad]; expected Type[P]
[out]

[case testInstantiationProtocolInTypeForAliases]
from typing import Type, Protocol

class P(Protocol):
    def m(self) -> None: pass
class C:
    def m(self) -> None:
        pass

def f(cls: Type[P]) -> P:
    return cls()  # OK

Alias = P
GoodAlias = C
Alias()  # E: Cannot instantiate protocol class "__main__.P"
GoodAlias()
f(Alias)  # E: Only concrete class can be given where 'Type[__main__.P]' is expected
f(GoodAlias)
[out]

[case testInstantiationProtocolInTypeForVariables]
from typing import Type, Protocol

class P(Protocol):
    def m(self) -> None: pass
class B(P): pass
class C:
    def m(self) -> None:
        pass

var: Type[P]
var()
var = P # E: Can only assign concrete classes to a variable of type 'Type[__main__.P]'
var = B # OK
var = C # OK

var_old = None # type: Type[P] # Old syntax for variable annotations
var_old()
var_old = P # E: Can only assign concrete classes to a variable of type 'Type[__main__.P]'
var_old = B # OK
var_old = C # OK
[out]

[case testInstantiationProtocolInTypeForClassMethods]
from typing import Type, Protocol

class Logger:
    @staticmethod
    def log(a: Type[C]):
        pass
class C(Protocol):
    @classmethod
    def action(cls) -> None:
        cls() #OK for classmethods
        Logger.log(cls)  #OK for classmethods
[builtins fixtures/classmethod.pyi]
[out]

-- isinsatnce() with @runtime protocols
-- ------------------------------------

[case testSimpleRuntimeProtocolCheck]
from typing import Protocol, runtime

class P(Protocol):
    def meth(self) -> None:
        pass

@runtime
class R(Protocol):
    def meth(self) -> int:
        pass

x: object

if isinstance(x, P):  # E: Only @runtime protocols can be used with instance and class checks
    reveal_type(x)  # E: Revealed type is '__main__.P'

if isinstance(x, R):
    reveal_type(x)  # E: Revealed type is '__main__.R'
    reveal_type(x.meth())  # E: Revealed type is 'builtins.int'
[builtins fixtures/isinstance.pyi]
[out]

[case testRuntimeIterableProtocolCheck]
from typing import Iterable, List, Union

x: Union[int, List[str]]

if isinstance(x, Iterable):
    reveal_type(x) # E: Revealed type is 'builtins.list[builtins.str]'
[builtins fixtures/isinstancelist.pyi]
[out]

[case testConcreteClassesInProtocolsIsInstance]
from typing import Protocol, runtime, TypeVar, Generic

T = TypeVar('T')

@runtime
class P1(Protocol):
    def meth1(self) -> int:
        pass
@runtime
class P2(Protocol):
    def meth2(self) -> int:
        pass
@runtime
class P(P1, P2, Protocol):
    pass

class C1(Generic[T]):
    def meth1(self) -> T:
        pass
class C2:
    def meth2(self) -> int:
        pass
class C(C1[int], C2): pass

c = C()
if isinstance(c, P1):
    reveal_type(c) # E: Revealed type is '__main__.C'
else:
    reveal_type(c) # Unreachable
if isinstance(c, P):
    reveal_type(c) # E: Revealed type is '__main__.C'
else:
    reveal_type(c) # Unreachable

c1i: C1[int]
if isinstance(c1i, P1):
    reveal_type(c1i) # E: Revealed type is '__main__.C1[builtins.int]'
else:
    reveal_type(c1i) # Unreachable
if isinstance(c1i, P):
    reveal_type(c1i) # Unreachable
else:
    reveal_type(c1i) # E: Revealed type is '__main__.C1[builtins.int]'

c1s: C1[str]
if isinstance(c1s, P1):
    reveal_type(c1s) # Unreachable
else:
    reveal_type(c1s) # E: Revealed type is '__main__.C1[builtins.str]'

c2: C2
if isinstance(c2, P):
    reveal_type(c2) # Unreachable
else:
    reveal_type(c2) # E: Revealed type is '__main__.C2'

[builtins fixtures/isinstancelist.pyi]
[out]

[case testConcreteClassesUnionInProtocolsIsInstance]
from typing import Protocol, runtime, TypeVar, Generic, Union

T = TypeVar('T')

@runtime
class P1(Protocol):
    def meth1(self) -> int:
        pass
@runtime
class P2(Protocol):
    def meth2(self) -> int:
        pass

class C1(Generic[T]):
    def meth1(self) -> T:
        pass
class C2:
    def meth2(self) -> int:
        pass

x: Union[C1[int], C2]
if isinstance(x, P1):
    reveal_type(x) # E: Revealed type is '__main__.C1[builtins.int]'
else:
    # This happens because of rules in restrict_subtype_away, maybe we can relax rules for protocols?
    reveal_type(x) # E: Revealed type is 'Union[__main__.C1[builtins.int], __main__.C2]'

if isinstance(x, P2):
    reveal_type(x) # E: Revealed type is '__main__.C2'
else:
    reveal_type(x) # E: Revealed type is '__main__.C1[builtins.int]'
[builtins fixtures/isinstancelist.pyi]
[out]

-- Non-Instances and protocol types (Callable vs __call__ etc.)
-- ------------------------------------------------------------

[case testBasicTupleStructuralSubtyping]
from typing import Tuple, TypeVar, Protocol

T = TypeVar('T', covariant=True)

class MyProto(Protocol[T]):
    def __len__(self) -> T:
        pass

t: Tuple[int, str]

def f(x: MyProto[int]) -> None:
    pass

f(t)  # OK
[builtins fixtures/isinstancelist.pyi]
[out]

[case testBasicNamedTupleStructuralSubtyping]
from typing import NamedTuple, TypeVar, Protocol

T = TypeVar('T', covariant=True)
S = TypeVar('S', covariant=True)

class P(Protocol[T, S]):
    @property
    def x(self) -> T: pass
    @property
    def y(self) -> S: pass

class N(NamedTuple):
    x: int
    y: str
class N2(NamedTuple):
    x: int
class N3(NamedTuple):
    x: int
    y: int

z: N
z3: N3

def fun(x: P[int, str]) -> None:
    pass
def fun2(x: P[int, int]) -> None:
    pass
def fun3(x: P[T, T]) -> T:
    return x.x

fun(z)
fun2(z) # E: Argument 1 to "fun2" has incompatible type "N"; expected P[int, int] \
        # N: Following members of __main__.N have conflicts: \
        # N: y: expected builtins.int*, got builtins.str

fun(N2(1)) # E: Argument 1 to "fun" has incompatible type "N2"; expected P[int, str] \
           # N: '__main__.N2' missing following '__main__.P' protocol members: \
           # N: y

reveal_type(fun3(z)) # E: Revealed type is 'builtins.object*'

reveal_type(fun3(z3)) # E: Revealed type is 'builtins.int*'
[builtins fixtures/list.pyi]
[out]


[case testBasicCallableStructuralSubtyping]
from typing import Callable, Generic, TypeVar

def apply(f: Callable[[int], int], x: int) -> int:
    return f(x)

class Add5:
    def __call__(self, x: int) -> int:
        return x + 5

apply(Add5(), 5)

T = TypeVar('T')
def apply_gen(f: Callable[[T], T]) -> T:
    pass

reveal_type(apply_gen(Add5())) # E: Revealed type is 'builtins.int*'
def apply_str(f: Callable[[str], int], x: str) -> int:
    return f(x)
apply_str(Add5(), 'a') # E: Argument 1 to "apply_str" has incompatible type "Add5"; expected Callable[[str], int] \
                       # N: __main__.Add5.__call__ has type def (x: builtins.int) -> builtins.int
[builtins fixtures/isinstancelist.pyi]
[out]

[case testStructuralSupportForPartial]
from typing import Callable, TypeVar, Generic, Any

T = TypeVar('T')

class partial(Generic[T]):
    def __init__(self, func: Callable[..., T], *args: Any) -> None: ...
    def __call__(self, *args: Any) -> T: ...

def inc(a: int, temp: str) -> int:
    pass

def foo(f: Callable[[int], T]) -> T:
    return f(1)

reveal_type(foo(partial(inc, 'temp'))) # E: Revealed type is 'builtins.int*'
[builtins fixtures/list.pyi]
[out]

-- Standard protocol types (SupportsInt, Sized, etc.)
-- --------------------------------------------------

-- More tests could be added for types from typing converted to protocols

[case testBasicSizedProtocol]
from typing import Sized

class Foo:
    def __len__(self) -> int:
        return 42

def bar(a: Sized) -> int:
    return a.__len__()

bar(Foo())
bar(1)

[builtins fixtures/isinstancelist.pyi]
[out]
main:11: error: Argument 1 to "bar" has incompatible type "int"; expected "Sized"
main:11: note: 'builtins.int' missing following 'typing.Sized' protocol members:
main:11: note: __len__

[case testBasicSupportsIntProtocol]
from typing import SupportsInt

class Bar:
    def __int__(self):
        return 1

def foo(a: SupportsInt):
    pass

foo(Bar())
foo('no way')

[builtins fixtures/isinstancelist.pyi]
[out]
main:11: error: Argument 1 to "foo" has incompatible type "str"; expected "SupportsInt"
main:11: note: 'builtins.str' missing following 'typing.SupportsInt' protocol members:
main:11: note: __int__

-- Additional test and corner cases for protocols
-- ----------------------------------------------

[case testAnyWithProtocols]
from typing import Protocol, Any, TypeVar

T = TypeVar('T')

class P1(Protocol):
    attr1: int
class P2(Protocol[T]):
    attr2: T
class P3(Protocol):
    attr: P3

def f1(x: P1) -> None: pass
def f2(x: P2[str]) -> None: pass
def f3(x: P3) -> None: pass

class C1:
    attr1: Any
class C2:
    attr2: Any
class C3:
    attr: Any

f1(C1())
f2(C2())
f3(C3())

f2(C3())  # E: Argument 1 to "f2" has incompatible type "C3"; expected P2[str] \
          # N: '__main__.C3' missing following '__main__.P2' protocol members: \
          # N: attr2
a: Any
f1(a)
f2(a)
f3(a)
[out]

[case testErrorsForProtocolsInDifferentPlaces]
from typing import Protocol

class P(Protocol):
    attr1: int
    attr2: str
    attr3: int

class C:
    attr1: str
    @property
    def attr2(self) -> int: pass

x: P = C() # E: Incompatible types in assignment (expression has type "C", variable has type "P") \
           # N: '__main__.C' missing following '__main__.P' protocol members: \
           # N: attr3 \
           # N: Following members of __main__.C have conflicts: \
           # N: attr1: expected builtins.int, got builtins.str \
           # N: attr2: expected builtins.str, got builtins.int \
           # N: Protocol member __main__.P.attr2: expected settable variable, got read-only attribute

def f(x: P) -> P:
    return C() # E: Incompatible return value type (got "C", expected "P") \
               # N: '__main__.C' missing following '__main__.P' protocol members: \
               # N: attr3 \
               # N: Following members of __main__.C have conflicts: \
               # N: attr1: expected builtins.int, got builtins.str \
               # N: attr2: expected builtins.str, got builtins.int \
               # N: Protocol member __main__.P.attr2: expected settable variable, got read-only attribute

f(C()) # E: Argument 1 to "f" has incompatible type "C"; expected "P" \
       # N: '__main__.C' missing following '__main__.P' protocol members: \
       # N: attr3 \
       # N: Following members of __main__.C have conflicts: \
       # N: attr1: expected builtins.int, got builtins.str \
       # N: attr2: expected builtins.str, got builtins.int \
       # N: Protocol member __main__.P.attr2: expected settable variable, got read-only attribute
[builtins fixtures/list.pyi]
[out]

[case testIterableProtocolOnClass]
from typing import TypeVar, Iterator
T = TypeVar('T', bound='A')

class A:
    def __iter__(self: T) -> Iterator[T]: pass

class B(A): pass

reveal_type(list(b for b in B()))  # E: Revealed type is 'builtins.list[__main__.B*]'
reveal_type(list(B()))  # E: Revealed type is 'builtins.list[__main__.B*]'
[builtins fixtures/list.pyi]
[out]

[case testIterableProtocolOnMetaclass]
from typing import TypeVar, Iterator, Type
T = TypeVar('T')

class EMeta(type):
    def __iter__(self: Type[T]) -> Iterator[T]: pass

class E(metaclass=EMeta):
    pass

class C(E):
    pass

reveal_type(list(c for c in C))  # E: Revealed type is 'builtins.list[__main__.C*]'
reveal_type(list(C))  # E: Revealed type is 'builtins.list[__main__.C*]'
[builtins fixtures/list.pyi]
[out]

[case testClassesGetattrWithProtocols]
from typing import Protocol

class P(Protocol):
    attr: int

class PP(Protocol):
    @property
    def attr(self) -> int:
        pass

class C:
    def __getattr__(self, attr: str) -> int:
        pass

class D:
    def __getattr__(self, attr: str) -> str:
        pass

def fun(x: P) -> None:
    reveal_type(P.attr) # E: Revealed type is 'builtins.int'
def fun_p(x: PP) -> None:
    reveal_type(P.attr) # E: Revealed type is 'builtins.int'

fun(C())  # E: Argument 1 to "fun" has incompatible type "C"; expected "P" \
          # N: Protocol member __main__.P.attr: expected settable variable, got read-only attribute
fun_p(D())  # E: Argument 1 to "fun_p" has incompatible type "D"; expected "PP" \
            # N: Following members of __main__.D have conflicts: \
            # N: attr: expected builtins.int, got builtins.str
fun_p(C())  # OK
[builtins fixtures/list.pyi]
[out]

[case testIpmlicitTypesInProtocols]
from typing import Protocol

class P(Protocol):
    x = 1  # We could actually prohibit inferred types in protocol declarations

class C:
    x: int

class D:
    x: str

x: P
x = D() # E: Incompatible types in assignment (expression has type "D", variable has type "P") \
        # N: Following members of __main__.D have conflicts: \
        # N: x: expected builtins.int, got builtins.str
x = C() # OK
[builtins fixtures/list.pyi]
[out]
