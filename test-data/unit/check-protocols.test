-- Simple protocol types
-- ---------------------

[case testCannotInstantiateProtocol]
from typing import Protocol

class P(Protocol):
    def meth(self) -> None:
        pass

P() # E: Cannot instantiate protocol class "__main__.P"
[out]

[case testSimpleProtocolOneMethod]
from typing import Protocol

class P(Protocol):
    def meth(self) -> None:
        pass

class B: pass

class C:
    def meth(self) -> None:
        pass

x: P

def fun(x: P) -> None:
    x.meth()
    x.meth(x) # E: Too many arguments for "meth" of "P"
    x.bad # E: "P" has no attribute "bad"

x = C()
x = B() # E: Incompatible types in assignment (expression has type "B", variable has type "P")\
    # N: __main__.B missing following __main__.P protocol members:\
    # N: meth

fun(C())
fun(B()) # E: Argument 1 to "fun" has incompatible type "B"; expected "P"\
    # N: __main__.B missing following __main__.P protocol members:\
    # N: meth

def fun2() -> P:
    return C()
def fun3() -> P:
    return B() # E: Incompatible return value type (got "B", expected "P")\
               # N: __main__.B missing following __main__.P protocol members:\
               # N: meth
[out]

[case testSimpleProtocolOneAbstractMethod]
from typing import Protocol
from abc import abstractmethod

class P(Protocol):
    @abstractmethod
    def meth(self) -> None:
        pass

class B: pass

class C:
    def meth(self) -> None:
        pass

class D(B):
    def meth(self) -> None:
        pass

x: P
def fun(x: P) -> None:
    x.meth()
    x.meth(x) # E: Too many arguments for "meth" of "P"
    x.bad # E: "P" has no attribute "bad"

x = C()
x = D()
x = B() # E: Incompatible types in assignment (expression has type "B", variable has type "P")\
    # N: __main__.B missing following __main__.P protocol members:\
    # N: meth
fun(C())
fun(D())
fun(B()) # E: Argument 1 to "fun" has incompatible type "B"; expected "P"\
    # N: __main__.B missing following __main__.P protocol members:\
    # N: meth
[out]

[case testSimpleProtocolOneMethodOverride]
from typing import Protocol, Union

class P(Protocol):
    def meth(self) -> Union[int, str]:
        pass
class SubP(P, Protocol):
    def meth(self) -> int:
        pass

class B: pass
class C:
    def meth(self) -> int:
        pass
z: P
x: SubP
def fun(x: SubP) -> str:
    x.bad # E: "SubP" has no attribute "bad"
    return x.meth() # E: Incompatible return value type (got "int", expected "str")

z = x
x = C()
x = B() # E: Incompatible types in assignment (expression has type "B", variable has type "SubP")\
    # N: __main__.B missing following __main__.SubP protocol members:\
    # N: meth

reveal_type(fun(C())) # E: Revealed type is 'builtins.str'
fun(B()) # E: Argument 1 to "fun" has incompatible type "B"; expected "SubP"\
    # N: __main__.B missing following __main__.SubP protocol members:\
    # N: meth
[out]

[case testSimpleProtocolTwoMethodsMerge]
from typing import Protocol

class P1(Protocol):
    def meth1(self) -> int:
        pass
class P2(Protocol):
    def meth2(self) -> str:
        pass
class B: pass
class C1:
    def meth1(self) -> int:
        pass
class C2(C1):
    def meth2(self) -> str:
        pass
class C:
    def meth1(self) -> int:
        pass
    def meth2(self) -> str:
        pass

class AnotherP(Protocol):
    def meth1(self) -> int:
        pass
    def meth2(self) -> str:
        pass

class P(P1, P2, Protocol): pass

x: P
reveal_type(x.meth1())  # E: Revealed type is 'builtins.int'
reveal_type(x.meth2())  # E: Revealed type is 'builtins.str'

c: C
c1: C1
c2: C2
y: AnotherP

x = c
x = B()  # E: Incompatible types in assignment (expression has type "B", variable has type "P")\
    # N: __main__.B missing following __main__.P protocol members:\
    # N: meth1, meth2
x = c1 # E: Incompatible types in assignment (expression has type "C1", variable has type "P")\
    # N: __main__.C1 missing following __main__.P protocol members:\
    # N: meth2
x = c2
x = y
y = x
[out]

[case testSimpleProtocolTwoMethodsExtend]
from typing import Protocol

class P1(Protocol):
    def meth1(self) -> int:
        pass
class P2(P1, Protocol):
    def meth2(self) -> str:
        pass

class Cbad:
    def meth1(self) -> int:
        pass

class C:
    def meth1(self) -> int:
        pass
    def meth2(self) -> str:
        pass

x: P2
reveal_type(x.meth1()) # E: Revealed type is 'builtins.int'
reveal_type(x.meth2()) # E: Revealed type is 'builtins.str'

x = C() # OK
x = Cbad() # E: Incompatible types in assignment (expression has type "Cbad", variable has type "P2")\
    # N: __main__.Cbad missing following __main__.P2 protocol members:\
    # N: meth2
[out]

[case testCannotAssignNormalToProtocol]
from typing import Protocol

class P(Protocol):
    def meth(self) -> int:
        pass
class C:
    def meth(self) -> int:
        pass

x: C
y: P
x = y # E: Incompatible types in assignment (expression has type "P", variable has type "C")
[out]

[case testIndependentProtocolSubtyping]
from typing import Protocol

class P1(Protocol):
    def meth(self) -> int:
        pass
class P2(Protocol):
    def meth(self) -> int:
        pass

x1: P1
x2: P2

x1 = x2
x2 = x1

def f1(x: P1) -> None: pass
def f2(x: P2) -> None: pass

f1(x2)
f2(x1)
[out]

-- Semanal errors in protocol types
-- --------------------------------

[case testBasicSemanalErrorsInProtocols]
from typing import Protocol, Generic, TypeVar, Iterable

T = TypeVar('T')
S = TypeVar('S')

class P1(Protocol[T, T]): # E: Duplicate type variables in Generic[...] or Protocol[...]
    def meth(self) -> T:
        pass

class P2(Protocol[T], Protocol[S]): # E: Only single Generic[...] or Protocol[...] can be in bases
    def meth(self) -> T:
        pass

class P3(Protocol[T], Generic[S]): # E: Only single Generic[...] or Protocol[...] can be in bases
    def meth(self) -> T:
        pass

class P4(Protocol[T]):
    attr: Iterable[S] # E: Invalid type "__main__.S"

class P5(Iterable[S], Protocol[T]): # E: If Generic[...] or Protocol[...] is present it should list all type variables
    def meth(self) -> T:
        pass
[out]

[case testProhibitSelfDefinitionInProtocols]
from typing import Protocol

class P(Protocol):
    def __init__(self, a: int) -> None:
        self.a = a # E: Protocol members cannot be defined via assignment to self\
                   # E: "P" has no attribute "a"

class B: pass
class C:
    def __init__(self, a: int) -> None:
        pass

x: P
x = B() # E: Incompatible types in assignment (expression has type "B", variable has type "P")
# The above is because of incompatible __init__, maybe we could allow this?
# (mypy allows incompatible __init__ in nominal subclasses.)
x = C(1)

class P2(Protocol):
    a: int
    def __init__(self) -> None:
        self.a = 1

class B2:
    a: int

x2: P2 = B2()  # OK
[out]

[case testProtocolsInMypyExtensions]
from mypy_extensions import Protocol, runtime

@runtime
class P(Protocol):
    def meth(self) -> int:
        pass

x: object
if isinstance(x, P):
    reveal_type(x)  # E: Revealed type is '__main__.P'
    reveal_type(x.meth())  # E: Revealed type is 'builtins.int'

class C:
    def meth(self) -> int:
        pass

z: P = C()
[builtins fixtures/isinstancelist.pyi]
[out]

-- Generic protocol types
-- ----------------------

[case testBasicGenericProtocols]
from typing import Protocol, Sequence, TypeVar

T = TypeVar('T')

class Closeable(Protocol[T]):
    def close(self) -> T:
        pass

class F:
    def close(self) -> int:
        return 0

def close(arg: Closeable[T]) -> T:
    return arg.close()

def close_all(args: Sequence[Closeable[T]]) -> T:
    for arg in args:
        return arg.close()
    return args[0].close()

arg: Closeable[int]

reveal_type(close(F())) # E: Revealed type is 'builtins.int*'
reveal_type(close(arg)) # E: Revealed type is 'builtins.int*'
reveal_type(close_all([F()])) # E: Revealed type is 'builtins.int*'
reveal_type(close_all([arg])) # E: Revealed type is 'builtins.int*'
[builtins fixtures/isinstancelist.pyi]
[out]

-- Recursive protocol types
-- ------------------------

[case testBasicRecursiveProtocols]
from typing import Protocol, Sequence, List, Generic, TypeVar

T = TypeVar('T')

class Traversable(Protocol):
    leaves: Sequence[Traversable]

class C: pass

class D(Generic[T]):
    @property
    def leaves(self) -> List[D[T]]:
        pass

t: Traversable
t = D[int]() # OK
t = C() # E: Incompatible types in assignment (expression has type "C", variable has type "Traversable")\
        # N: __main__.C missing following __main__.Traversable protocol members:\
        # N: leaves
[builtins fixtures/list.pyi]
[out]

-- @property, @classmethod and @staticmethod in protocol types
-- -----------------------------------------------------------

-- Meet and join of protocol types
-- -------------------------------

-- Unions of protocol types
-- ------------------------

-- Type[] with protocol types
-- --------------------------

[case testInstantiationProtocolInTypeForFunctions]
from typing import Type, Protocol

class P(Protocol):
    def m(self) -> None: pass
class P1(Protocol):
    def m(self) -> None: pass
class Pbad(Protocol):
    def mbad(self) -> int: pass
class B(P): pass
class C:
    def m(self) -> None:
        pass

def f(cls: Type[P]) -> P:
    return cls()  # OK
def g() -> P:
    return P()  # E: Cannot instantiate protocol class "__main__.P"

f(P)  # E: Only concrete class can be given where 'Type[__main__.P]' is expected
f(B)  # OK
f(C)  # OK
x: Type[P1]
xbad: Type[Pbad]
f(x)  # OK
f(xbad)  # E: Argument 1 to "f" has incompatible type Type[Pbad]; expected Type[P]
[out]

[case testInstantiationProtocolInTypeForAliases]
from typing import Type, Protocol

class P(Protocol):
    def m(self) -> None: pass
class C:
    def m(self) -> None:
        pass

def f(cls: Type[P]) -> P:
    return cls()  # OK

Alias = P
GoodAlias = C
Alias()  # E: Cannot instantiate protocol class "__main__.P"
GoodAlias()
f(Alias)  # E: Only concrete class can be given where 'Type[__main__.P]' is expected
f(GoodAlias)
[out]

[case testInstantiationProtocolInTypeForVariables]
from typing import Type, Protocol

class P(Protocol):
    def m(self) -> None: pass
class B(P): pass
class C:
    def m(self) -> None:
        pass

var: Type[P]
var()
var = P # E: Can only assign concrete classes to a variable of type 'Type[__main__.P]'
var = B # OK
var = C # OK

var_old = None # type: Type[P] # Old syntax for variable annotations
var_old()
var_old = P # E: Can only assign concrete classes to a variable of type 'Type[__main__.P]'
var_old = B # OK
var_old = C # OK
[out]

[case testInstantiationProtocolInTypeForClassMethods]
from typing import Type, Protocol

class Logger:
    @staticmethod
    def log(a: Type[C]):
        pass
class C(Protocol):
    @classmethod
    def action(cls) -> None:
        cls() #OK for classmethods
        Logger.log(cls)  #OK for classmethods
[builtins fixtures/classmethod.pyi]
[out]

-- isinsatnce() with @runtime protocols
-- ------------------------------------

[case testSimpleRuntimeProtocolCheck]
from typing import Protocol, runtime

class P(Protocol):
    def meth(self) -> None:
        pass

@runtime
class R(Protocol):
    def meth(self) -> int:
        pass

x: object

if isinstance(x, P):  # E: Only @runtime protocols can be used with instance and class checks
    reveal_type(x)  # E: Revealed type is '__main__.P'

if isinstance(x, R):
    reveal_type(x)  # E: Revealed type is '__main__.R'
    reveal_type(x.meth())  # E: Revealed type is 'builtins.int'
[builtins fixtures/isinstance.pyi]
[out]

[case testRuntimeIterableProtocolCheck]
from typing import Iterable, List, Union

x: Union[int, List[str]]

if isinstance(x, Iterable):
    reveal_type(x) # E: Revealed type is 'builtins.list[builtins.str]'
[builtins fixtures/isinstancelist.pyi]
[out]

[case testConcreteClassesInProtocolsIsInstance]
from typing import Protocol, runtime, TypeVar, Generic

T = TypeVar('T')

@runtime
class P1(Protocol):
    def meth1(self) -> int:
        pass
@runtime
class P2(Protocol):
    def meth2(self) -> int:
        pass
@runtime
class P(P1, P2, Protocol):
    pass

class C1(Generic[T]):
    def meth1(self) -> T:
        pass
class C2:
    def meth2(self) -> int:
        pass
class C(C1[int], C2): pass

c = C()
if isinstance(c, P1):
    reveal_type(c) # E: Revealed type is '__main__.C'
else:
    reveal_type(c) # Unreachable
if isinstance(c, P):
    reveal_type(c) # E: Revealed type is '__main__.C'
else:
    reveal_type(c) # Unreachable

c1i: C1[int]
if isinstance(c1i, P1):
    reveal_type(c1i) # E: Revealed type is '__main__.C1[builtins.int]'
else:
    reveal_type(c1i) # Unreachable
if isinstance(c1i, P):
    reveal_type(c1i) # Unreachable
else:
    reveal_type(c1i) # E: Revealed type is '__main__.C1[builtins.int]'

c1s: C1[str]
if isinstance(c1s, P1):
    reveal_type(c1s) # Unreachable
else:
    reveal_type(c1s) # E: Revealed type is '__main__.C1[builtins.str]'

c2: C2
if isinstance(c2, P):
    reveal_type(c2) # Unreachable
else:
    reveal_type(c2) # E: Revealed type is '__main__.C2'

[builtins fixtures/isinstancelist.pyi]
[out]

[case testConcreteClassesUnionInProtocolsIsInstance]
from typing import Protocol, runtime, TypeVar, Generic, Union

T = TypeVar('T')

@runtime
class P1(Protocol):
    def meth1(self) -> int:
        pass
@runtime
class P2(Protocol):
    def meth2(self) -> int:
        pass

class C1(Generic[T]):
    def meth1(self) -> T:
        pass
class C2:
    def meth2(self) -> int:
        pass

x: Union[C1[int], C2]
if isinstance(x, P1):
    reveal_type(x) # E: Revealed type is '__main__.C1[builtins.int]'
else:
    reveal_type(x) # E: Revealed type is '__main__.C2'

if isinstance(x, P2):
    reveal_type(x) # E: Revealed type is '__main__.C2'
else:
    reveal_type(x) # E: Revealed type is '__main__.C1[builtins.int]'
[builtins fixtures/isinstancelist.pyi]
[out]

-- Non-Instances and protocol types (Callable vs __call__ etc.)
-- ------------------------------------------------------------

[case testBasicCallableStructuralSubtyping]
from typing import Callable, Generic, TypeVar

def apply(f: Callable[[int], int], x: int) -> int:
    return f(x)

class Add5:
    def __call__(self, x: int) -> int:
        return x + 5

apply(Add5(), 5)

T = TypeVar('T')
def apply_gen(f: Callable[[T], T]) -> T:
    pass

reveal_type(apply_gen(Add5())) # E: Revealed type is 'builtins.int*'
[builtins fixtures/isinstancelist.pyi]
[out]

[case testStructuralSupportForPartial]
from typing import Callable, TypeVar, Generic, Any

T = TypeVar('T')

class partial(Generic[T]):
    def __init__(self, func: Callable[..., T], *args: Any) -> None: ...
    def __call__(self, *args: Any) -> T: ...

def inc(a: int, temp: str) -> int:
    pass

def foo(f: Callable[[int], T]) -> T:
    return f(1)

reveal_type(foo(partial(inc, 'temp'))) # E: Revealed type is 'builtins.int*'
[builtins fixtures/list.pyi]
[out]

-- Standard protocol types (SupportsInt, Reversible, etc.)
-- -------------------------------------------------------

[case testBasicSupportsIntProtocol]
from typing import SupportsInt

class Bar:
    def __int__(self):
        return 1

def foo(a: SupportsInt):
    return int(a)

foo(1)
foo(Bar())

[builtins fixtures/isinstancelist.pyi]
[out]
