[case testBasicParamSpec]
from typing_extensions import ParamSpec
P = ParamSpec('P')
[builtins fixtures/tuple.pyi]

[case testParamSpecLocations]
from typing import Callable, List
from typing_extensions import ParamSpec, Concatenate
P = ParamSpec('P')

x: P  # E: ParamSpec "P" is unbound

def foo1(x: Callable[P, int]) -> Callable[P, str]:  ...

def foo2(x: P) -> P: ...  # E: Invalid location for ParamSpec "P" \
                          # N: You can use ParamSpec as the first argument to Callable, e.g., 'Callable[P, int]'

# TODO(PEP612): uncomment once we have support for Concatenate
# def foo3(x: Concatenate[int, P]) -> int: ...  $ E: Invalid location for Concatenate

def foo4(x: List[P]) -> None: ...  # E: Invalid location for ParamSpec "P" \
                                   # N: You can use ParamSpec as the first argument to Callable, e.g., 'Callable[P, int]'

def foo5(x: Callable[[int, str], P]) -> None: ...  # E: Invalid location for ParamSpec "P" \
                                                   # N: You can use ParamSpec as the first argument to Callable, e.g., 'Callable[P, int]'

def foo6(x: Callable[[P], int]) -> None: ...  # E: Invalid location for ParamSpec "P" \
                                              # N: You can use ParamSpec as the first argument to Callable, e.g., 'Callable[P, int]'
[builtins fixtures/tuple.pyi]

[case testParamSpecContextManagerLike]
from typing import Callable, List, Iterator, TypeVar
from typing_extensions import ParamSpec
P = ParamSpec('P')
T = TypeVar('T')

def tmpcontextmanagerlike(x: Callable[P, Iterator[T]]) -> Callable[P, List[T]]: ...

@tmpcontextmanagerlike
def whatever(x: int) -> Iterator[int]:
    yield x

reveal_type(whatever)  # N: Revealed type is "def (x: builtins.int) -> builtins.list[builtins.int*]"
reveal_type(whatever(217))  # N: Revealed type is "builtins.list[builtins.int*]"
[builtins fixtures/tuple.pyi]

[case testGenericParamSpecTemporaryBehaviour]
# flags: --python-version 3.10
# TODO(PEP612): behaviour tested here should change
from typing import Generic, TypeVar, Callable, ParamSpec

T = TypeVar("T")
P = ParamSpec("P")

class X(Generic[T, P]):  # E: Free type variable expected in Generic[...]
  f: Callable[P, int]  # E: The first argument to Callable must be a list of types or "..."
  x: T
[out]

[case testInvalidParamSpecType]
# flags: --python-version 3.10
from typing import ParamSpec

P = ParamSpec("P")

class MyFunction(P):  # E: Invalid location for ParamSpec "P" \
                      # N: You can use ParamSpec as the first argument to Callable, e.g., 'Callable[P, int]'
    ...

a: MyFunction[int]  # E: "MyFunction" expects no type arguments, but 1 given

[case testParamSpecRevealType]
from typing import Callable
from typing_extensions import ParamSpec

P = ParamSpec('P')

def f(x: Callable[P, int]) -> None: ...
reveal_type(f)  # N: Revealed type is "def [P] (x: def (*P.args, **P.kwargs) -> builtins.int)"
[builtins fixtures/tuple.pyi]

[case testParamSpecSimpleFunction]
from typing import Callable, TypeVar
from typing_extensions import ParamSpec

P = ParamSpec('P')

def changes_return_type_to_str(x: Callable[P, int]) -> Callable[P, str]: ...

def returns_int(a: str, b: bool) -> int: ...

reveal_type(changes_return_type_to_str(returns_int))  # N: Revealed type is "def (a: builtins.str, b: builtins.bool) -> builtins.str"
[builtins fixtures/tuple.pyi]

[case testParamSpecSimpleClass]
from typing import Callable, TypeVar, Generic
from typing_extensions import ParamSpec

P = ParamSpec('P')

class C(Generic[P]):
    def __init__(self, x: Callable[P, None]) -> None: ...

    def m(self, *args: P.args, **kwargs: P.kwargs) -> int:
        return 1

def f(x: int, y: str) -> None: ...

reveal_type(C(f))  # N: Revealed type is "__main__.C[def (x: builtins.int, y: builtins.str)]"
reveal_type(C(f).m)  # N: Revealed type is "def (x: builtins.int, y: builtins.str) -> builtins.int"
[builtins fixtures/dict.pyi]

[case testParamSpecClassWithPrefixArgument]
from typing import Callable, TypeVar, Generic
from typing_extensions import ParamSpec

P = ParamSpec('P')

class C(Generic[P]):
    def __init__(self, x: Callable[P, None]) -> None: ...

    def m(self, a: str, *args: P.args, **kwargs: P.kwargs) -> int:
        return 1

def f(x: int, y: str) -> None: ...

reveal_type(C(f).m)  # N: Revealed type is "def (a: builtins.str, x: builtins.int, y: builtins.str) -> builtins.int"
reveal_type(C(f).m('', 1, ''))  # N: Revealed type is "builtins.int"
[builtins fixtures/dict.pyi]

[case testParamSpecDecorator]
from typing import Callable, TypeVar, Generic
from typing_extensions import ParamSpec

P = ParamSpec('P')
R = TypeVar('R')

class W(Generic[P, R]):
    f: Callable[P, R]
    x: int
    def __call__(self, *args: P.args, **kwargs: P.kwargs) -> R:
        reveal_type(self.f(*args, **kwargs))  # N: Revealed type is "R`2"
        return self.f(*args, **kwargs)

def dec() -> Callable[[Callable[P, R]], W[P, R]]:
    pass

@dec()
def f(a: int, b: str) -> None: ...

reveal_type(f)  # N: Revealed type is "__main__.W[def (a: builtins.int, b: builtins.str), None]"
reveal_type(f(1, ''))  # N: Revealed type is "None"
reveal_type(f.x)  # N: Revealed type is "builtins.int"

## TODO: How should this work?
#
# class C:
#     @dec()
#     def m(self, x: int) -> str: ...
#
# reveal_type(C().m(x=1))
[builtins fixtures/dict.pyi]

[case testParamSpecFunction]
from typing import Callable, TypeVar
from typing_extensions import ParamSpec

P = ParamSpec('P')
R = TypeVar('R')

def f(x: Callable[P, R], *args: P.args, **kwargs: P.kwargs) -> R:
    return x(*args, **kwargs)

def g(x: int, y: str) -> None: ...

reveal_type(f(g, 1, y='x'))  # N: Revealed type is "None"
f(g, 'x', y='x')  # E: Argument 2 to "f" has incompatible type "str"; expected "int"
f(g, 1, y=1)  # E: Argument "y" to "f" has incompatible type "int"; expected "str"
f(g)  # E: Missing positional arguments "x", "y" in call to "f"

[builtins fixtures/dict.pyi]

[case testParamSpecSpecialCase]
from typing import Callable, TypeVar
from typing_extensions import ParamSpec

P = ParamSpec('P')
T = TypeVar('T')

def register(func: Callable[P, T], *args: P.args, **kwargs: P.kwargs) -> Callable[P, T]: ...

def f(x: int, y: str, z: int, a: str) -> None: ...

x = register(f, 1, '', 1, '')
[builtins fixtures/dict.pyi]

[case testParamSpecInferredFromAny]
from typing import Callable, Any
from typing_extensions import ParamSpec

P = ParamSpec('P')

def f(x: Callable[P, int]) -> Callable[P, str]: ...

g: Any
reveal_type(f(g))  # N: Revealed type is "def (*Any, **Any) -> builtins.str"

f(g)(1, 3, x=1, y=2)
[builtins fixtures/tuple.pyi]

[case testParamSpecDecoratorImplementation]
from typing import Callable, Any, TypeVar, List
from typing_extensions import ParamSpec

P = ParamSpec('P')
T = TypeVar('T')

def dec(f: Callable[P, T]) -> Callable[P, List[T]]:
    def wrapper(*args: P.args, **kwargs: P.kwargs) -> List[T]:
        return [f(*args, **kwargs)]
    return wrapper

@dec
def g(x: int, y: str = '') -> int: ...

reveal_type(g)  # N: Revealed type is "def (x: builtins.int, y: builtins.str =) -> builtins.list[builtins.int*]"
[builtins fixtures/dict.pyi]

[case testParamSpecArgsAndKwargsTypes]
from typing import Callable, TypeVar, Generic
from typing_extensions import ParamSpec

P = ParamSpec('P')

class C(Generic[P]):
    def __init__(self, x: Callable[P, None]) -> None: ...

    def m(self, *args: P.args, **kwargs: P.kwargs) -> None:
        reveal_type(args)  # N: Revealed type is "P.args`1"
        reveal_type(kwargs)  # N: Revealed type is "P.kwargs`1"
[builtins fixtures/dict.pyi]

[case testParamSpecSubtypeChecking]
from typing import Callable, TypeVar, Generic, Any
from typing_extensions import ParamSpec

P = ParamSpec('P')

class C(Generic[P]):
    def __init__(self, x: Callable[P, None]) -> None: ...

    def m(self, *args: P.args, **kwargs: P.kwargs) -> None:
        args = args
        kwargs = kwargs
        o: object
        o = args
        o = kwargs
        o2: object
        args = o2  # E: Incompatible types in assignment (expression has type "object", variable has type "P.args")
        kwargs = o2  # E: Incompatible types in assignment (expression has type "object", variable has type "P.kwargs")
        a: Any
        a = args
        a = kwargs
        args = kwargs  # E: Incompatible types in assignment (expression has type "P.kwargs", variable has type "P.args")
        kwargs = args  # E: Incompatible types in assignment (expression has type "P.args", variable has type "P.kwargs")
        args = a
        kwargs = a
[builtins fixtures/dict.pyi]
