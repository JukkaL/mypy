[case testBasicParamSpec]
from typing_extensions import ParamSpec
P = ParamSpec('P')
[builtins fixtures/tuple.pyi]

[case testParamSpecLocations]
from typing import Callable, List
from typing_extensions import ParamSpec, Concatenate
P = ParamSpec('P')

x: P  # E: ParamSpec "P" is unbound

def foo1(x: Callable[P, int]) -> Callable[P, str]:  ...

def foo2(x: P) -> P: ...  # E: Invalid location for ParamSpec "P" \
                          # N: You can use ParamSpec as the first argument to Callable, e.g., 'Callable[P, int]'

def foo3(x: Concatenate[int, P]) -> int: ...  # E: Invalid location for Concatenate

def foo4(x: List[P]) -> None: ...  # E: Invalid location for ParamSpec "P" \
                                   # N: You can use ParamSpec as the first argument to Callable, e.g., 'Callable[P, int]'

def foo5(x: Callable[[int, str], P]) -> None: ...  # E: Invalid location for ParamSpec "P" \
                                                   # N: You can use ParamSpec as the first argument to Callable, e.g., 'Callable[P, int]'

def foo6(x: Callable[[P], int]) -> None: ...  # E: Invalid location for ParamSpec "P" \
                                              # N: You can use ParamSpec as the first argument to Callable, e.g., 'Callable[P, int]'
[builtins fixtures/tuple.pyi]

[case testParamSpecContextManagerLike]
from typing import Callable, List, Iterator, TypeVar
from typing_extensions import ParamSpec
P = ParamSpec('P')
T = TypeVar('T')

def tmpcontextmanagerlike(x: Callable[P, Iterator[T]]) -> Callable[P, List[T]]: ...

@tmpcontextmanagerlike
def whatever(x: int) -> Iterator[int]:
    yield x

reveal_type(whatever)  # N: Revealed type is "def (x: builtins.int) -> builtins.list[builtins.int*]"
reveal_type(whatever(217))  # N: Revealed type is "builtins.list[builtins.int*]"
[builtins fixtures/tuple.pyi]

[case testInvalidParamSpecType]
# flags: --python-version 3.10
from typing import ParamSpec

P = ParamSpec("P")

class MyFunction(P):  # E: Invalid base class "P"
    ...

[case testParamSpecRevealType]
from typing import Callable
from typing_extensions import ParamSpec

P = ParamSpec('P')

def f(x: Callable[P, int]) -> None: ...
reveal_type(f)  # N: Revealed type is "def [P] (x: def (*P.args, **P.kwargs) -> builtins.int)"
[builtins fixtures/tuple.pyi]

[case testParamSpecSimpleFunction]
from typing import Callable, TypeVar
from typing_extensions import ParamSpec

P = ParamSpec('P')

def changes_return_type_to_str(x: Callable[P, int]) -> Callable[P, str]: ...

def returns_int(a: str, b: bool) -> int: ...

reveal_type(changes_return_type_to_str(returns_int))  # N: Revealed type is "def (a: builtins.str, b: builtins.bool) -> builtins.str"
[builtins fixtures/tuple.pyi]

[case testParamSpecSimpleClass]
from typing import Callable, TypeVar, Generic
from typing_extensions import ParamSpec

P = ParamSpec('P')

class C(Generic[P]):
    def __init__(self, x: Callable[P, None]) -> None: ...

    def m(self, *args: P.args, **kwargs: P.kwargs) -> int:
        return 1

def f(x: int, y: str) -> None: ...

reveal_type(C(f))  # N: Revealed type is "__main__.C[def (x: builtins.int, y: builtins.str)]"
reveal_type(C(f).m)  # N: Revealed type is "def (x: builtins.int, y: builtins.str) -> builtins.int"
[builtins fixtures/dict.pyi]

[case testParamSpecClassWithPrefixArgument]
from typing import Callable, TypeVar, Generic
from typing_extensions import ParamSpec

P = ParamSpec('P')

class C(Generic[P]):
    def __init__(self, x: Callable[P, None]) -> None: ...

    def m(self, a: str, *args: P.args, **kwargs: P.kwargs) -> int:
        return 1

def f(x: int, y: str) -> None: ...

reveal_type(C(f).m)  # N: Revealed type is "def (a: builtins.str, x: builtins.int, y: builtins.str) -> builtins.int"
reveal_type(C(f).m('', 1, ''))  # N: Revealed type is "builtins.int"
[builtins fixtures/dict.pyi]

[case testParamSpecDecorator]
from typing import Callable, TypeVar, Generic
from typing_extensions import ParamSpec

P = ParamSpec('P')
R = TypeVar('R')

class W(Generic[P, R]):
    f: Callable[P, R]
    x: int
    def __call__(self, *args: P.args, **kwargs: P.kwargs) -> R:
        reveal_type(self.f(*args, **kwargs))  # N: Revealed type is "R`2"
        return self.f(*args, **kwargs)

def dec() -> Callable[[Callable[P, R]], W[P, R]]:
    pass

@dec()
def f(a: int, b: str) -> None: ...

reveal_type(f)  # N: Revealed type is "__main__.W[def (a: builtins.int, b: builtins.str), None]"
reveal_type(f(1, ''))  # N: Revealed type is "None"
reveal_type(f.x)  # N: Revealed type is "builtins.int"

## TODO: How should this work?
#
# class C:
#     @dec()
#     def m(self, x: int) -> str: ...
#
# reveal_type(C().m(x=1))
[builtins fixtures/dict.pyi]

[case testParamSpecFunction]
from typing import Callable, TypeVar
from typing_extensions import ParamSpec

P = ParamSpec('P')
R = TypeVar('R')

def f(x: Callable[P, R], *args: P.args, **kwargs: P.kwargs) -> R:
    return x(*args, **kwargs)

def g(x: int, y: str) -> None: ...

reveal_type(f(g, 1, y='x'))  # N: Revealed type is "None"
f(g, 'x', y='x')  # E: Argument 2 to "f" has incompatible type "str"; expected "int"
f(g, 1, y=1)  # E: Argument "y" to "f" has incompatible type "int"; expected "str"
f(g)  # E: Missing positional arguments "x", "y" in call to "f"

[builtins fixtures/dict.pyi]

[case testParamSpecSpecialCase]
from typing import Callable, TypeVar
from typing_extensions import ParamSpec

P = ParamSpec('P')
T = TypeVar('T')

def register(func: Callable[P, T], *args: P.args, **kwargs: P.kwargs) -> Callable[P, T]: ...

def f(x: int, y: str, z: int, a: str) -> None: ...

x = register(f, 1, '', 1, '')
[builtins fixtures/dict.pyi]

[case testParamSpecInferredFromAny]
from typing import Callable, Any
from typing_extensions import ParamSpec

P = ParamSpec('P')

def f(x: Callable[P, int]) -> Callable[P, str]: ...

g: Any
reveal_type(f(g))  # N: Revealed type is "def (*Any, **Any) -> builtins.str"

f(g)(1, 3, x=1, y=2)
[builtins fixtures/tuple.pyi]

[case testParamSpecDecoratorImplementation]
from typing import Callable, Any, TypeVar, List
from typing_extensions import ParamSpec

P = ParamSpec('P')
T = TypeVar('T')

def dec(f: Callable[P, T]) -> Callable[P, List[T]]:
    def wrapper(*args: P.args, **kwargs: P.kwargs) -> List[T]:
        return [f(*args, **kwargs)]
    return wrapper

@dec
def g(x: int, y: str = '') -> int: ...

reveal_type(g)  # N: Revealed type is "def (x: builtins.int, y: builtins.str =) -> builtins.list[builtins.int*]"
[builtins fixtures/dict.pyi]

[case testParamSpecArgsAndKwargsTypes]
from typing import Callable, TypeVar, Generic
from typing_extensions import ParamSpec

P = ParamSpec('P')

class C(Generic[P]):
    def __init__(self, x: Callable[P, None]) -> None: ...

    def m(self, *args: P.args, **kwargs: P.kwargs) -> None:
        reveal_type(args)  # N: Revealed type is "P.args`1"
        reveal_type(kwargs)  # N: Revealed type is "P.kwargs`1"
[builtins fixtures/dict.pyi]

[case testParamSpecSubtypeChecking1]
from typing import Callable, TypeVar, Generic, Any
from typing_extensions import ParamSpec

P = ParamSpec('P')

class C(Generic[P]):
    def __init__(self, x: Callable[P, None]) -> None: ...

    def m(self, *args: P.args, **kwargs: P.kwargs) -> None:
        args = args
        kwargs = kwargs
        o: object
        o = args
        o = kwargs
        o2: object
        args = o2  # E: Incompatible types in assignment (expression has type "object", variable has type "P.args")
        kwargs = o2  # E: Incompatible types in assignment (expression has type "object", variable has type "P.kwargs")
        a: Any
        a = args
        a = kwargs
        args = kwargs  # E: Incompatible types in assignment (expression has type "P.kwargs", variable has type "P.args")
        kwargs = args  # E: Incompatible types in assignment (expression has type "P.args", variable has type "P.kwargs")
        args = a
        kwargs = a
[builtins fixtures/dict.pyi]

[case testParamSpecSubtypeChecking2]
from typing import Callable, Generic
from typing_extensions import ParamSpec

P = ParamSpec('P')
P2 = ParamSpec('P2')

class C(Generic[P]):
    pass

def f(c1: C[P], c2: C[P2]) -> None:
    c1 = c1
    c2 = c2
    c1 = c2  # E: Incompatible types in assignment (expression has type "C[P2]", variable has type "C[P]")
    c2 = c1  # E: Incompatible types in assignment (expression has type "C[P]", variable has type "C[P2]")

def g(f: Callable[P, None], g: Callable[P2, None]) -> None:
    f = f
    g = g
    f = g  # E: Incompatible types in assignment (expression has type "Callable[P2, None]", variable has type "Callable[P, None]")
    g = f  # E: Incompatible types in assignment (expression has type "Callable[P, None]", variable has type "Callable[P2, None]")
[builtins fixtures/dict.pyi]

[case testParamSpecJoin]
from typing import Callable, Generic, TypeVar
from typing_extensions import ParamSpec

P = ParamSpec('P')
P2 = ParamSpec('P2')
P3 = ParamSpec('P3')
T = TypeVar('T')

def join(x: T, y: T) -> T: ...

class C(Generic[P, P2]):
    def m(self, f: Callable[P, None], g: Callable[P2, None]) -> None:
        reveal_type(join(f, f))  # N: Revealed type is "def (*P.args, **P.kwargs)"
        reveal_type(join(f, g))  # N: Revealed type is "builtins.function*"

    def m2(self, *args: P.args, **kwargs: P.kwargs) -> None:
        reveal_type(join(args, args))  # N: Revealed type is "P.args`1"
        reveal_type(join(kwargs, kwargs))  # N: Revealed type is "P.kwargs`1"
        reveal_type(join(args, kwargs))  # N: Revealed type is "builtins.object*"
        def f(*args2: P2.args, **kwargs2: P2.kwargs) -> None:
            reveal_type(join(args, args2))  # N: Revealed type is "builtins.object*"
            reveal_type(join(kwargs, kwargs2))  # N: Revealed type is "builtins.object*"

    def m3(self, c: C[P, P3]) -> None:
        reveal_type(join(c, c))  # N: Revealed type is "__main__.C*[P`1, P3`-1]"
        reveal_type(join(self, c))  # N: Revealed type is "builtins.object*"
[builtins fixtures/dict.pyi]

[case testParamSpecClassWithAny]
from typing import Callable, Generic, Any
from typing_extensions import ParamSpec

P = ParamSpec('P')

class C(Generic[P]):
    def __init__(self, x: Callable[P, None]) -> None: ...

    def m(self, *args: P.args, **kwargs: P.kwargs) -> int:
        return 1

c: C[Any]
reveal_type(c)  # N: Revealed type is "__main__.C[Any]"
reveal_type(c.m)  # N: Revealed type is "def (*args: Any, **kwargs: Any) -> builtins.int"
c.m(4, 6, y='x')
c = c

def f() -> None: pass

c2 = C(f)
c2 = c
c3 = C(f)
c = c3
[builtins fixtures/dict.pyi]

[case testParamSpecInferredFromLambda]
from typing import Callable, TypeVar
from typing_extensions import ParamSpec

P = ParamSpec('P')
T = TypeVar('T')

# Similar to atexit.register
def register(f: Callable[P, T], *args: P.args, **kwargs: P.kwargs) -> Callable[P, T]: ...  # N: "register" defined here

def f(x: int) -> None: pass

reveal_type(register(lambda: f(1)))  # N: Revealed type is "def ()"
reveal_type(register(lambda x: f(x), x=1))  # N: Revealed type is "def (x: Any)"
register(lambda x: f(x))  # E: Missing positional argument "x" in call to "register"
register(lambda x: f(x), y=1)  # E: Unexpected keyword argument "y" for "register"
[builtins fixtures/dict.pyi]

[case testParamSpecInvalidCalls]
from typing import Callable, Generic
from typing_extensions import ParamSpec

P = ParamSpec('P')
P2 = ParamSpec('P2')

class C(Generic[P, P2]):
    def m1(self, *args: P.args, **kwargs: P.kwargs) -> None:
        self.m1(*args, **kwargs)
        self.m2(*args, **kwargs)  # E: Argument 1 to "m2" of "C" has incompatible type "*P.args"; expected "P2.args" \
            # E: Argument 2 to "m2" of "C" has incompatible type "**P.kwargs"; expected "P2.kwargs"
        self.m1(*kwargs, **args)  # E: Argument 1 to "m1" of "C" has incompatible type "*P.kwargs"; expected "P.args" \
            # E: Argument 2 to "m1" of "C" has incompatible type "**P.args"; expected "P.kwargs"
        self.m3(*args, **kwargs)  # E: Argument 1 to "m3" of "C" has incompatible type "*P.args"; expected "int" \
            # E: Argument 2 to "m3" of "C" has incompatible type "**P.kwargs"; expected "int"
        self.m4(*args, **kwargs)  # E: Argument 1 to "m4" of "C" has incompatible type "*P.args"; expected "int" \
            # E: Argument 2 to "m4" of "C" has incompatible type "**P.kwargs"; expected "int"

        self.m1(*args, **args)  # E: Argument 2 to "m1" of "C" has incompatible type "**P.args"; expected "P.kwargs"
        self.m1(*kwargs, **kwargs)  # E: Argument 1 to "m1" of "C" has incompatible type "*P.kwargs"; expected "P.args"

    def m2(self, *args: P2.args, **kwargs: P2.kwargs) -> None:
        pass

    def m3(self, *args: int, **kwargs: int) -> None:
        pass

    def m4(self, x: int) -> None:
        pass
[builtins fixtures/dict.pyi]

[case testParamSpecOverUnannotatedDecorator]
from typing import Callable, Iterator, TypeVar, ContextManager, Any
from typing_extensions import ParamSpec

from nonexistent import deco2  # type: ignore

T = TypeVar("T")
P = ParamSpec("P")
T_co = TypeVar("T_co", covariant=True)

class CM(ContextManager[T_co]):
    def __call__(self, func: T) -> T: ...

def deco1(
    func: Callable[P, Iterator[T]]) -> Callable[P, CM[T]]: ...

@deco1
@deco2
def f():
    pass

reveal_type(f)  # N: Revealed type is "def (*Any, **Any) -> __main__.CM[Any]"

with f() as x:
    pass
[builtins fixtures/dict.pyi]
[typing fixtures/typing-full.pyi]

[case testParamSpecLiterals]
from typing_extensions import ParamSpec, TypeAlias
from typing import Generic, TypeVar

P = ParamSpec("P")
T = TypeVar("T")

class Z(Generic[P]): ...

# literals can be applied
n: Z[[int]]

# TODO: type aliases too
# nt1 = Z[[int]]
# nt2: TypeAlias = Z[[int]]

# unt1: nt1
# unt2: nt2

# literals actually keep types
reveal_type(n)  # N: Revealed type is "__main__.Z[[builtins.int]]"
# reveal_type(unt1)  $ N: Revealed type is "__main__.Z[[builtins.int]]"
# reveal_type(unt2)  $ N: Revealed type is "__main__.Z[[builtins.int]]"

# passing into a function keeps the type
def fT(a: T) -> T: ...
def fP(a: Z[P]) -> Z[P]: ...

reveal_type(fT(n))  # N: Revealed type is "__main__.Z*[[builtins.int]]"
reveal_type(fP(n))  # N: Revealed type is "__main__.Z[[builtins.int]]"

# literals can be in function args and return type
def k(a: Z[[int]]) -> Z[[str]]: ...

# functions work
reveal_type(k(n))  # N: Revealed type is "__main__.Z[[builtins.str]]"

# literals can be matched in arguments
def kb(a: Z[[bytes]]) -> Z[[str]]: ...

# TODO: return type is a bit weird, return Any
reveal_type(kb(n))  # N: Revealed type is "__main__.Z[[builtins.str]]" \
                    # E: Argument 1 to "kb" has incompatible type "Z[[int]]"; expected "Z[[bytes]]"


n2: Z[bytes]

reveal_type(kb(n2))  # N: Revealed type is "__main__.Z[[builtins.str]]"
[builtins fixtures/tuple.pyi]

[case testParamSpecConcatenateFromPep]
from typing_extensions import ParamSpec, Concatenate
from typing import Callable, TypeVar, Generic

P = ParamSpec("P")
R = TypeVar("R")

# CASE 1
class Request:
    ...

def with_request(f: Callable[Concatenate[Request, P], R]) -> Callable[P, R]:
    def inner(*args: P.args, **kwargs: P.kwargs) -> R:
        return f(Request(), *args, **kwargs)
    return inner

@with_request
def takes_int_str(request: Request, x: int, y: str) -> int:
    # use request
    return x + 7

reveal_type(takes_int_str)  # N: Revealed type is "def (x: builtins.int, y: builtins.str) -> builtins.int*"

takes_int_str(1, "A") # Accepted
takes_int_str("B", 2) # E: Argument 1 to "takes_int_str" has incompatible type "str"; expected "int" \
                      # E: Argument 2 to "takes_int_str" has incompatible type "int"; expected "str"

# CASE 2
T = TypeVar("T")
P_2 = ParamSpec("P_2")

class X(Generic[T, P]):
  f: Callable[P, int]
  x: T

def f1(x: X[int, P_2]) -> str: ...                    # Accepted
def f2(x: X[int, Concatenate[int, P_2]]) -> str: ...  # Accepted
def f3(x: X[int, [int, bool]]) -> str: ...            # Accepted
# Is ellipsis allowed by PEP? This shows up:
# def f4(x: X[int, ...]) -> str: ...                    # Accepted
# TODO: this is not rejected:
# def f5(x: X[int, int]) -> str: ...                    # Rejected

# CASE 3
def bar(x: int, *args: bool) -> int: ...
def add(x: Callable[P, int]) -> Callable[Concatenate[str, P], bool]: ...

reveal_type(add(bar))       # N: Revealed type is "def (builtins.str, x: builtins.int, *args: builtins.bool) -> builtins.bool"

def remove(x: Callable[Concatenate[int, P], int]) -> Callable[P, bool]: ...

reveal_type(remove(bar))    # N: Revealed type is "def (*args: builtins.bool) -> builtins.bool"

def transform(
  x: Callable[Concatenate[int, P], int]
) -> Callable[Concatenate[str, P], bool]: ...

# In the PEP, "__a" appears. What is that? Autogenerated names? To what spec?
reveal_type(transform(bar)) # N: Revealed type is "def (builtins.str, *args: builtins.bool) -> builtins.bool"

# CASE 4
def expects_int_first(x: Callable[Concatenate[int, P], int]) -> None: ...

@expects_int_first  # E: Argument 1 to "expects_int_first" has incompatible type "Callable[[str], int]"; expected "Callable[[int], int]"
def one(x: str) -> int: ...

@expects_int_first  # E: Argument 1 to "expects_int_first" has incompatible type "Callable[[NamedArg(int, 'x')], int]"; expected "Callable[[int], int]"
def two(*, x: int) -> int: ...

@expects_int_first  # E: Argument 1 to "expects_int_first" has incompatible type "Callable[[KwArg(int)], int]"; expected "Callable[[int], int]"
def three(**kwargs: int) -> int: ...

@expects_int_first # Accepted
def four(*args: int) -> int: ...
[builtins fixtures/tuple.pyi]
[builtins fixtures/dict.pyi]

[case testParamSpecTwiceSolving]
from typing_extensions import ParamSpec, Concatenate
from typing import Callable, TypeVar

P = ParamSpec("P")
R = TypeVar("R")

def f(one: Callable[Concatenate[int, P], R], two: Callable[Concatenate[str, P], R]) -> Callable[P, R]: ...

a: Callable[[int, bytes], str]
b: Callable[[str, bytes], str]

reveal_type(f(a, b))  # N: Revealed type is "def (builtins.bytes) -> builtins.str*"
[builtins fixtures/tuple.pyi]

[case testParamSpecConcatenateInReturn]
from typing_extensions import ParamSpec, Concatenate
from typing import Callable, Protocol

P = ParamSpec("P")

def f(i: Callable[Concatenate[int, P], str]) -> Callable[Concatenate[int, P], str]: ...

n: Callable[[int, bytes], str]

reveal_type(f(n))  # N: Revealed type is "def (builtins.int, builtins.bytes) -> builtins.str"
[builtins fixtures/tuple.pyi]

[case testParamSpecConcatenateNamedArgs]
# this is one noticeable deviation from PEP but I believe it is for the better
from typing_extensions import ParamSpec, Concatenate
from typing import Callable, TypeVar

P = ParamSpec("P")
R = TypeVar("R")

# TODO: figure out how to only run this under >= 3.8
# def f1(c: Callable[P, R]) -> Callable[Concatenate[int, P], R]:
#     def result(x: int, /, *args: P.args, **kwargs: P.kwargs) -> R: ...
#
#     return result  # Accepted

def f2(c: Callable[P, R]) -> Callable[Concatenate[int, P], R]:
    def result(x: int, *args: P.args, **kwargs: P.kwargs) -> R: ...

    return result  # E: Incompatible return value type (got "Callable[Concatenate[Arg(int, 'x'), P], R]", expected "Callable[Concatenate[int, P], R]")

# reason for rejection:
f2(lambda x: 42)(42, x=42)
[builtins fixtures/tuple.pyi]

[case testParamSpecConcatenateWithTypeVar]
from typing_extensions import ParamSpec, Concatenate
from typing import Callable, TypeVar

P = ParamSpec("P")
R = TypeVar("R")
S = TypeVar("S")

def f(c: Callable[Concatenate[S, P], R]) -> Callable[Concatenate[S, P], R]: ...

def a(n: int) -> None: ...

n = f(a)

reveal_type(n)  # N: Revealed type is "def (builtins.int*)"
reveal_type(n(42))  # N: Revealed type is "None"
[builtins fixtures/tuple.pyi]

[case testCallablesAsParameters]
# credits to https://github.com/microsoft/pyright/issues/2705
from typing_extensions import ParamSpec, Concatenate
from typing import Generic, Callable, Any

P = ParamSpec("P")

class Foo(Generic[P]):
    def __init__(self, func: Callable[P, Any]) -> None: ...
def bar(baz: Foo[Concatenate[int, P]]) -> Foo[P]: ...

# TODO: how to mark this as py>=3.8
# def test(a: int, /, b: str) -> str: ...

#abc = Foo(test)
#reveal_type(abc)
#bar(abc)
[builtins fixtures/tuple.pyi]
