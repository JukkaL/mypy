-- Test case for final qualifier
--

-- Definitions

[case testFinalDefiningModuleVar]
from typing import Final
x: Final = int()
y: Final[float] = int()
z: Final[int] = int()
bad: Final[str] = str()
reveal_type(x)  # E: Revealed type is 'builtins.int'
reveal_type(y)  # E: Revealed type is 'builtins.float'
reveal_type(z)  # E: Revealed type is 'builtins.int'
[out]

[case testFinalDefiningInstanceVar]
from typing import Final
class C:
    x: Final = int()
    y: Final[float] = int()
    z: Final[int] = int()
    bad: Final[str] = int()  # E: Incompatible types in assignment (expression has type "int", variable has type "str")
reveal_type(C.x)  # E: Revealed type is 'builtins.int'
reveal_type(C.y)  # E: Revealed type is 'builtins.float'
reveal_type(C.z)  # E: Revealed type is 'builtins.int'
reveal_type(C().x)  # E: Revealed type is 'builtins.int'
reveal_type(C().y)  # E: Revealed type is 'builtins.float'
reveal_type(C().z)  # E: Revealed type is 'builtins.int'
[out]

[case testFinalDefiningInstanceVarImplicit]
from typing import Final, Tuple, Any

class C:
    def __init__(self, x: Tuple[int, Any]) -> None:
        self.x: Final = x
        self.y: Final[float] = 1
reveal_type(C((1, 2)).x)  # E: Revealed type is 'Tuple[builtins.int, Any]'
reveal_type(C((1, 2)).y)  # E: Revealed type is 'builtins.float'
[out]

[case testFinalBadDefinitionTooManyArgs]
from typing import Final

x: Final[int, str]  # E: Final declaration outside stubs must have right hand side \
                    # E: Final[...] takes at most one type argument
reveal_type(x)  # E: Revealed type is 'builtins.int'

class C:
    def __init__(self) -> None:
        self.x: Final[float, float] = 1  # E: Final[...] takes at most one type argument
reveal_type(C().x)  # E: Revealed type is 'builtins.float'
[out]

[case testFinalInvalidDefinitions]
from typing import Final, Any
x = y = 1  # type: Final[float]  # E: Invalid final declaration, ignoring
z: Any
z[0]: Final  # E: Unexpected type declaration \
             # E: Invalid final declaration, ignoring
[out]

[case testFinalDefiningInstanceVarStubs]
# Allow skipping r.h.s.
import mod
[file mod.pyi]
from typing import Final
x: Final
y: Final[int]
class C:
    x: Final
    y: Final[int]
    def __init__(self) -> None:
        self.z: Final
[out]

[case testFinalDefiningFunc]

[out]

[case testFinalDefiningFuncOverloaded]

[out]

[case testFinalDefiningFuncOverloadedStubs]

[out]

[case testFinalDefiningMeth]

[out]

[case testFinalDefiningProperty]

[out]

[case testFinalDefiningOuterOnly]
from typing import Final, Callable, Tuple, Any
x: Tuple[Final]  # E: Final can be only used as an outermost type qualifier in assignments
y: Callable[[], Tuple[Final[int]]]  # E: Final can be only used as an outermost type qualifier in assignments
[out]

[case testFinalDefiningNotInMethod]
from typing import Final

def f(x: Final[int]) -> int: ...  # E: Final can be only used as an outermost type qualifier in assignments
def g(x: int) -> Final[int]: ...  # E: Final can be only used as an outermost type qualifier in assignments
[out]

[case testFinalDefiningNoRhs]
from typing import Final
x: Final  # E: Final declaration outside stubs must have right hand side
y: Final[int]  # E: Final declaration outside stubs must have right hand side
class C:
    x: Final  # E: Final declaration outside stubs must have right hand side
    y: Final[int]  # E: Final declaration outside stubs must have right hand side
    def __init__(self) -> None:
        self.z: Final  # E: Final declaration outside stubs must have right hand side
reveal_type(x)  # E: Revealed type is 'Any'
reveal_type(y)  # E: Revealed type is 'builtins.int'
reveal_type(C().x)  # E: Revealed type is 'Any'
reveal_type(C().y)  # E: Revealed type is 'builtins.int'
reveal_type(C().z)  # E: Revealed type is 'Any'
[out]

[case testFinalDefiningNoTypevarsExplicit]
from typing import Final, TypeVar, Generic, Tuple, Any

T = TypeVar('T')
d: Any

class C(Generic[T]):
    x: Final[Tuple[T, T]] = d  # E: Constant declared in class body can't depend on type variables
[out]

[case testFinalDefiningTypevarsImplicit]
from typing import Final, TypeVar, Generic, Tuple, Any

T = TypeVar('T')

class C(Generic[T]):
    def __init__(self, x: Tuple[T, T]) -> None:
        self.x: Final = x
        self.y: Final = 1

reveal_type(C((1, 2)).x)  # E: Revealed type is 'Tuple[builtins.int*, builtins.int*]'
C.x  # E: Can't access instance constant on class object \
     # E: Access to generic instance variables via class is ambiguous
C.y  # E: Can't access instance constant on class object
[out]

[case testFinalDefiningNotInOtherMethod]
from typing import Final, Any, Tuple

class C:
    def meth(self, x: Tuple[int, Any]) -> None:
        self.x: Final = x  # E: Can only declare final attributes in class body or __init__ method
        self.y: Final[float] = 1  # E: Can only declare final attributes in class body or __init__ method
[out]

[case testFinalDefiningOnlyOnSelf]
from typing import Final, Any, Tuple

class U:
    x: Any
    y: Any
class C:
    def __init__(self, x: Tuple[int, Any]) -> None:
        slf = U()
        slf.x: Final = x  # E: Final can be only applied to a name or an attribute on self
        slf.y: Final[float] = 1  # E: Type cannot be declared in assignment to non-self attribute \
                                 # E: Final can be only applied to a name or an attribute on self
[out]

-- Reassignments

[case testFinalReassignModuleVar]
from typing import Final

x: Final = 1
x = 2  # E: Can't assign to constant "x"
def f() -> int:
    global x
    x = 3  # E: Can't assign to constant "x"
    return x

y = 1
y: Final = 2  # E: Name 'y' already defined on line 10 \
              # E: Final can't redefine an existing name, ignoring
y = 3  # No error here, first definition wins

z: Final = 1
z: Final = 2  # E: Name 'z' already defined on line 14 \
              # E: Final can't redefine an existing name, ignoring \
              # E: Can't assign to constant "z"
z = 3  # E: Can't assign to constant "z"
[out]

[case testFinalReassignFuncScope]
from typing import Final

def f() -> None:
    nl: Final = 0
    x: Final = 1
    x = 1  # E: Can't assign to constant "x"

    y: Final = 1
    y: Final = 2  # E: Final can't redefine an existing name, ignoring \
                  # E: Can't assign to constant "y"
    def nested() -> None:
        nonlocal nl
        nl = 1  # E: Can't assign to constant "nl"
[out]

[case testFinalReassignModuleVarExternal]
import mod
mod.x = 2  # E: Can't assign to constant "x"
[file mod.pyi]
from typing import Final
x: Final[int]
[out]

[case testFinalReassignModuleFuncExternal]

[out]

[case testFinalReassignModuleFuncOverloaded]

[out]

[case testFinalReassignInstanceVarClassBody]
from typing import Final

class C:
    x: Final = 1
    x = 2  # E: Can't assign to constant "x"

    y = 1
    y: Final = 2  # E: Final can't redefine an existing name, ignoring
[out]

[case testFinalReassignInstanceVarInit]
from typing import Final

class C:
    def __init__(self) -> None:
        self.x: Final = 1
        self.y = 1
        self.y: Final = 2  # E: Final can't redefine an existing name, ignoring
    def meth(self) -> None:
        self.x = 2  # E: Can't assign to constant "x"
[out]

[case testFinalReassignInstanceVarClassVsInit]
from typing import Final

class C:
    y: Final = 1
    def __init__(self) -> None:
        self.x: Final = 1
        self.y = 2  # E: Can't assign to constant "y"
    x = 2  # E: Can't assign to constant "x"
[out]

[case testFinalReassignInstanceVarMethod]
from typing import Final

class C:
    x: Final = 1
    def __init__(self) -> None:
        self.y: Final = 1
    def meth(self) -> None:
        self.x = 2  # E: Can't assign to constant "x"
        self.y = 2  # E: Can't assign to constant "y"
    def other(self) -> None:
        self.x = 2  # E: Can't assign to constant "x"
        self.y = 2  # E: Can't assign to constant "y"
    @classmethod
    def cm(cls) -> None:
        cls.x = 2  # E: Can't assign to constant "x"
        cls.y  # E: Can't access instance constant on class object
[builtins fixtures/classmethod.pyi]
[out]

[case testFinalReassignInstanceVarExternalClass]
from typing import Final

class C:
    x: Final = 1
    def __init__(self) -> None:
        self.y: Final = 1

class D(C): pass

C.x = 2  # E: Can't assign to constant "x"
D.x = 2  # E: Can't assign to constant "x"
D.y = 2  # E: Can't access instance constant on class object \
         # E: Can't assign to constant "y"
[out]

[case testFinalReassignInstanceVarExternalInstance]
from typing import Final

class C:
    x: Final = 1
    def __init__(self) -> None:
        self.y: Final = 1

class D(C): pass

C().x = 2  # E: Can't assign to constant "x"
D().x = 2  # E: Can't assign to constant "x"
D().y = 2  # E: Can't assign to constant "y"
[out]

-- Overriding

[case testFinalOverridingVarClassBody]
from typing import Final

class A:
    x = 0
    def __init__(self) -> None:
        self.y = 0
class B(A):
    x: Final = 1
    def __init__(self) -> None:
        self.y: Final = 1
class C(B):
    x: int = 2  # E: Cannot override constant (previously declared on base class "B") \
                # E: Can't assign to constant "x"
    y: int = 2  # E: Cannot override constant (previously declared on base class "B") \
                # E: Can't assign to constant "y"
    x = 3  # E: Can't assign to constant "x"
    y = 3  # E: Can't assign to constant "y"
class D(C):
    pass
D.x = 4  # E: Can't assign to constant "x"
D.y = 4  # E: Can't assign to constant "y"
[out]

[case testFinalOverridingVarClassBodyExplicit]
from typing import Final

class A:
    x = 0
    def __init__(self) -> None:
        self.y = 0
class B(A):
    x: Final = 1
    def __init__(self) -> None:
        self.y: Final = 1
class C(B):
    x: Final = 2  # E: Cannot override constant (previously declared on base class "B")
    y: Final = 2  # E: Cannot override constant (previously declared on base class "B")
[out]

[case testFinalOverridingVarInit]
from typing import Final

class A:
    x = 0
    def __init__(self) -> None:
        self.y = 0
class B(A):
    x: Final = 1
    def __init__(self) -> None:
        self.y: Final = 1
class C(B):
    def __init__(self) -> None:
        self.x = 2  # E: Can't assign to constant "x"
        self.y = 2  # E: Can't assign to constant "y"
    def meth(self) -> None:
        self.x = 3  # E: Can't assign to constant "x"
        self.y = 3  # E: Can't assign to constant "y"
[out]

[case testFinalOverridingVarInit2]
from typing import Final

class A:
    x = 0
    def __init__(self) -> None:
        self.y = 0
class B(A):
    x: Final = 1
    def __init__(self) -> None:
        self.y: Final = 1
class C(B):
    def __init__(self) -> None:
        self.x: Final = 2  # E: Cannot override constant (previously declared on base class "B")
        self.y: Final = 2  # E: Cannot override constant (previously declared on base class "B")
[out]

[case testFinalOverridingVarOtherMethod]
from typing import Final

class A:
    x = 0
    def __init__(self) -> None:
        self.y = 0
class B(A):
    x: Final = 1
    def __init__(self) -> None:
        self.y: Final = 1
class C(B):
    def meth(self) -> None:
        self.x: int = 2    # E: Can't assign to constant "x" \
                           # E: Cannot override constant (previously declared on base class "B")
        self.y: int = 2    # E: Can't assign to constant "y" \
                           # E: Cannot override constant (previously declared on base class "B")
        self.x = 3  # E: Can't assign to constant "x"
        self.y = 3  # E: Can't assign to constant "y"
[out]

[case testFinalOverridingVarMultipleInheritanceClass]
from typing import Final

class A:
    x: Final = 1
class B:
    x = 2
class C(A, B): ...
class D(B, A): ...  # E: Cannot override constant (previously declared on base class "A")
C.x = 3  # E: Can't assign to constant "x"
D.x = 3  # E: Can't assign to constant "x"
C().x = 4  # E: Can't assign to constant "x"
D().x = 4  # E: Can't assign to constant "x"
[out]

[case testFinalOverridingVarMultipleInheritanceInit]
from typing import Final

class A:
    def __init__(self) -> None:
        self.x: Final = 1
class B:
    def __init__(self) -> None:
        self.x = 2
class C(A, B): ...
class D(B, A): ...  # E: Cannot override constant (previously declared on base class "A")
C.x = 3  # E: Can't access instance constant on class object \
         # E: Can't assign to constant "x"
D.x = 3  # E: Can't assign to constant "x"
C().x = 4  # E: Can't assign to constant "x"
D().x = 4  # E: Can't assign to constant "x"
[out]

[case testFinalOverridingVarMultipleInheritanceMixed]
from typing import Final

class A:
    x: Final = 1
class B:
    def __init__(self) -> None:
        self.x = 2
class C(A, B): ...
class D(B, A): ...  # E: Cannot override constant (previously declared on base class "A")
C.x = 3  # E: Can't assign to constant "x"
D.x = 3  # E: Can't assign to constant "x"
C().x = 4  # E: Can't assign to constant "x"
D().x = 4  # E: Can't assign to constant "x"
[out]

[case testFinalOverridingVarWithMethod]
from typing import Final


[out]

[case testFinalOverridingMethodWithVar]

[out]

[case testFinalOverridingMethodWithVarImplicit]

[out]

[case testFinalOverridingMethodMultipleinheritance]

[out]

[case testFinalOverridingMethodMultiplaInheritance2]

[out]

[case testFinalOverridingClassMethod]

[out]

[case testFinalOverridingStaticMethod]

[out]

[case testFinalOverridingProperty]

[out]

[case testFinalOverridingMethodOverloads]

[out]
